require('./sourcemap-register.js');/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 4013:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bootrom = void 0;
exports.bootrom = new Uint32Array([
    0x20041f00, 0x000000ef, 0x00000035, 0x00000031, 0x0201754d, 0x00c8007a,
    0x0000001d, 0x88022300, 0xd003429a, 0x30048843, 0xd1f74291, 0x47701c18,
    0xe7fdbf30, 0xf00046f4, 0x489ef805, 0x60012100, 0x46e76041, 0x2100489c,
    0x600143c9, 0x47706041, 0x00a4a191, 0x00001e09, 0x20294328, 0x30323032,
    0x73615220, 0x72656270, 0x50207972, 0x72542069, 0x6e696461, 0x744c2067,
    0x33500064, 0x335202d9, 0x334c02fd, 0x33540327, 0x534d035f, 0x345326dd,
    0x434d26d1, 0x34432641, 0x42552629, 0x544425b5, 0x45440185, 0x5657018b,
    0x46490137, 0x584524a1, 0x455223f5, 0x5052237d, 0x434623c5, 0x58432361,
    0x43452331, 0x00000045, 0x00505247, 0x00585243, 0x01a84653, 0x02284453,
    0x01a65a46, 0x27585346, 0x2e4c4546, 0x2e545344, 0x3dac4544, 0x48730000,
    0x29006801, 0xf7ffd11f, 0x4971ff9d, 0x680a4b71, 0xd001421a, 0xe793600b,
    0x4e704f6f, 0x42b0cf0f, 0x4059d107, 0xd1041840, 0x60383f10, 0x8808f382,
    0xf0024798, 0xbf20f9e1, 0x08896d21, 0x6560d3fb, 0x1c6ebf40, 0x4c614730,
    0x21044f65, 0x6da16139, 0x08496d21, 0xa50bd2fb, 0xf7ff2000, 0x2801ffed,
    0xf7ffd1f6, 0x60b8ffe9, 0xffe6f7ff, 0x8808f380, 0xffe2f7ff, 0xf7ffa501,
    0x46c0ffdf, 0x61392100, 0xe75d4780, 0x6d20bf20, 0xd3fb0840, 0x28006da0,
    0x4770d0de, 0x43372601, 0xbe0047b8, 0x3811e7fa, 0xbd007ac0, 0x4042b500,
    0xf0002a00, 0xd2f6f802, 0x4670468e, 0x00204700, 0x00002b69, 0x00002b65,
    0x00002c31, 0x00002cfd, 0x00002827, 0x00002827, 0x00002db1, 0x0000284d,
    0x0000284f, 0x00002881, 0x00002883, 0x000028d7, 0x000028d9, 0x000028e7,
    0x000028e9, 0x000029bf, 0x00002975, 0x000029dd, 0x00000031, 0x000029e5,
    0x00002a4f, 0x0000280b, 0x00002a73, 0x000028af, 0x000028b1, 0x0000289d,
    0x0000289f, 0x00003581, 0x00003583, 0x0000358b, 0x0000358d, 0x0000363d,
    0x00002e61, 0x00002e55, 0x00002fbd, 0x00003119, 0x0000346b, 0x0000346b,
    0x000032dd, 0x00003565, 0x00003567, 0x00003573, 0x00003575, 0x000036c3,
    0x000036c5, 0x000036bb, 0x000036bd, 0x00003831, 0x00003841, 0x00003811,
    0x00000031, 0x00003b45, 0x00003be1, 0x0000346f, 0x00003931, 0x000036d1,
    0x000036d3, 0x000036cb, 0x000036cd, 0x000035c1, 0x000035c3, 0x000035db,
    0x000035dd, 0x00003663, 0xf380480a, 0xf0018808, 0x0000ff1b, 0x40004000,
    0x400080a0, 0xd0000000, 0x40064008, 0x01000000, 0x4005801c, 0xb007c0d3,
    0xe000ed00, 0x501008b0, 0x08424933, 0x0883400a, 0x4008400b, 0x18c01880,
    0x184008c1, 0x4008492f, 0x18400981, 0x4348492e, 0x47700e80, 0x08514a2d,
    0x00434051, 0x4008400b, 0x43180840, 0x40130083, 0x08804010, 0x4a284303,
    0x40100118, 0x091b4013, 0xba004318, 0xa3254770, 0xd10c0c01, 0xd1040a81,
    0xd1050901, 0x301a5c18, 0x5c584770, 0x47703010, 0x30165c58, 0x0a884770,
    0x0908d104, 0x5c58d104, 0x4770300a, 0x47705c18, 0x30065c18, 0xa3274770,
    0xd00f0401, 0xd0050188, 0xd0070181, 0x31100f09, 0x47705c58, 0x5c580e89,
    0x4770300a, 0x5c180e80, 0x47703004, 0xd0060181, 0xd0080188, 0x30100f00,
    0x30105c18, 0x0e804770, 0x301a5c18, 0x0e894770, 0x30145c58, 0x00004770,
    0x49249249, 0xc71c71c7, 0x04004004, 0xcccccccc, 0xf0f0f0f0, 0x04040506,
    0x03030303, 0x02020202, 0x02020202, 0x01010101, 0x01010101, 0x01010101,
    0x01010101, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
    0x00000000, 0x00000000, 0x00000000, 0x00010006, 0x00010002, 0x00010003,
    0x00010002, 0x00010004, 0x00010002, 0x00010003, 0x00010002, 0x00010005,
    0x00010002, 0x00010003, 0x00010002, 0x00010004, 0x00010002, 0x00010003,
    0x00010002, 0x20e10031, 0x1c492169, 0x1dcd1ba9, 0xbe0022fd, 0x68934a02,
    0x60933b40, 0x46c04770, 0x50100a7c, 0x7d934a02, 0x4a027513, 0x47706013,
    0x501009ec, 0x50110000, 0x60012300, 0x60426103, 0x60c3784b, 0x47706083,
    0x68834904, 0x741a2201, 0x781b681b, 0x43135acb, 0x00004718, 0x0000043c,
    0xb5706803, 0xd0021e19, 0x230f7899, 0x24004019, 0x4a122500, 0x189a00cb,
    0x60556014, 0x4e100004, 0x8b323428, 0x78258282, 0x2d002440, 0x1924d000,
    0x83341914, 0xd00e2900, 0x2d002154, 0x3120d000, 0x30290649, 0x78011852,
    0x181b4806, 0xd0032900, 0x2200601a, 0xbd70605a, 0xe7fb6019, 0x50100080,
    0x501009ec, 0x50100000, 0x1c45b530, 0x77e9b2c9, 0x702a3528, 0x000382c3,
    0x7824ac03, 0x701c3328, 0x00492301, 0x1889405a, 0x77d91cc3, 0xbe00bd30,
    0xb5f00013, 0x000c0006, 0xb0850015, 0x60013308, 0x78239303, 0x786318e4,
    0xd1fa2b05, 0x79217963, 0x430b021b, 0x2101270f, 0x910078a2, 0x00394017,
    0x09d26828, 0xffd0f7ff, 0x4a05cd08, 0x601c00bf, 0x9b0350bb, 0xd1e442ab,
    0xb0050030, 0x46c0bdf0, 0x50100a08, 0x7fdb1c43, 0x78023029, 0x00db4903,
    0x2a001858, 0x4a02d001, 0x47701898, 0x50100084, 0x50100080, 0x0006b570,
    0x00047f83, 0x2b003618, 0x8ac3d11f, 0x00037743, 0x78193329, 0x29001d43,
    0x1d83d100, 0x8aa37fdd, 0x1e50002a, 0x480a4182, 0x181b0192, 0x61a3189b,
    0x42992300, 0x0020d106, 0xffd0f7ff, 0x1945006d, 0xb2db882b, 0x23017723,
    0x003077a3, 0x46c0bd70, 0x50100000, 0xb5702200, 0x77da1dc3, 0x00043301,
    0x42907fd8, 0x2380d12f, 0x431900db, 0x33290023, 0x2b00781b, 0x2380d002,
    0x4319021b, 0x7fd31ca2, 0x001d2601, 0x41851e68, 0x77d34073, 0x036d0020,
    0xf7ff430d, 0x1d63ffa3, 0xb2ad7fda, 0x188040b2, 0x80052200, 0x77a21d21,
    0x3a017fca, 0x68a177ca, 0x688a3428, 0x608a3a01, 0x2a007822, 0x7fdad002,
    0x77de4056, 0x20a0bd70, 0x43010140, 0xe7cd77da, 0x0004b570, 0x2b0068a3,
    0x689bd015, 0xd0122b00, 0x7ff51d26, 0xd00e2d00, 0x7fdb1de3, 0xd10a2b00,
    0x33290023, 0x2b00781b, 0x0020d006, 0xfef0f7ff, 0x42ab7ff3, 0xbd70d1e6,
    0x8ae10020, 0xffa2f7ff, 0xb570e7e0, 0x0004000d, 0x00280011, 0xf7ff001a,
    0x2300fed7, 0x330160e3, 0x002060a5, 0xf7ff74ab, 0xbd70ffcf, 0x0003b510,
    0x49034a02, 0xf7ff4803, 0xbd10ffe8, 0x00003f59, 0x50100a24, 0x50100dc0,
    0x68836841, 0x428bb510, 0x2300d003, 0xf7ff680a, 0xbd10ffd8, 0xb5100003,
    0x7fdb3333, 0x2b00302c, 0xf7ffd101, 0xbd10ffed, 0xb5700003, 0x781b3329,
    0x000d0004, 0x2b000016, 0xf7ffd003, 0x2300ff37, 0x00337103, 0x00200029,
    0xf7ff4a01, 0xbd70ffba, 0x00003f59, 0x2200b510, 0x48034902, 0xffe4f7ff,
    0x46c0bd10, 0x501009c4, 0x50100f68, 0x2200b510, 0x48034902, 0xffd8f7ff,
    0x46c0bd10, 0x501009d8, 0x50100f94, 0x4b03b510, 0x49044a03, 0xf7ff4804,
    0xbd10ff98, 0x0000075d, 0x00003f59, 0x501009c4, 0x50100f68, 0x1dc3b510,
    0x68817fda, 0xd1052a00, 0x2b0068cb, 0x7c0bd10a, 0xd1072b00, 0x23002401,
    0x608374cc, 0xd002429a, 0x608b60cb, 0x684bbd10, 0xd0012b00, 0xe7f94798,
    0x2b0068c3, 0x6083d0f6, 0x749c60c2, 0xff4cf7ff, 0xbe00e7f0, 0x1dc6b570,
    0x00047ff3, 0x2b00000d, 0x1c43d11a, 0x2b007fdb, 0x0003d107, 0x781b3329,
    0x4153425a, 0x33014a0a, 0x00206693, 0xfebaf7ff, 0x68022380, 0x4313011b,
    0x77f56003, 0x2b006923, 0x0020d001, 0xbd704798, 0xd2fc428b, 0xe7fa77f1,
    0x50112000, 0x2800b570, 0x4b18d00e, 0x58c40080, 0x7fcb1d21, 0x77cb3301,
    0x2d0068a5, 0x2102d109, 0xf7ff0020, 0xbd70ffc7, 0x29004c11, 0x4c11d1f0,
    0x7c2be7ee, 0xd0022b00, 0x746b2301, 0x1da3e7f3, 0x332377da, 0x2b00781b,
    0x68abd002, 0xd0022b00, 0xf7ff0020, 0x7cebfe01, 0xd1e42b00, 0x002068eb,
    0x60eb3b01, 0xff82f7ff, 0x46c0e7dd, 0x50100a08, 0x50100f68, 0x50100f94,
    0xb5702300, 0x00046885, 0xf7ff742b, 0x7cebff73, 0xd11b2b00, 0x36290026,
    0x2b007833, 0x0020d003, 0xf7ff7f21, 0x2300fe97, 0x7c6a77a3, 0xd00e429a,
    0x1d22746b, 0x3b017fd3, 0x220177d3, 0x7fdb1da3, 0x78313401, 0x405a7fe0,
    0xffa0f7ff, 0x0020bd70, 0xfebef7ff, 0xbe00e7fa, 0x0004b5f8, 0xfe3ef7ff,
    0x68020025, 0x35284b19, 0xd01d421a, 0x2b00782b, 0x1d23d003, 0x2b017fdb,
    0x2301d104, 0x7fd11ca2, 0x77d3404b, 0x7fda1ce3, 0x40932301, 0x4a114910,
    0x4e124811, 0x660b6653, 0x423b6e77, 0x3801d102, 0xd1112800, 0x66536613,
    0xf7ff0020, 0x782bfe17, 0x1e592200, 0x1d21418b, 0x60023301, 0x230177cb,
    0x340884a2, 0xbdf877e3, 0xe7e5660b, 0x04000400, 0x50112000, 0x50113000,
    0x000186a0, 0x50110000, 0x4d08b570, 0xf7ff0028, 0x4c07ffb7, 0xf7ff0020,
    0x0028ffb3, 0xf7ff2101, 0x2101ff21, 0xf7ff0020, 0xbd70ff1d, 0x50100f68,
    0x50100f94, 0x2500b570, 0x000e6085, 0xf7ff0004, 0x42aeff9f, 0x1ca2d001,
    0x77a577d5, 0x7fd11de2, 0xd0052900, 0x692377d5, 0xd0012b00, 0x47980020,
    0x7d5b4b07, 0xd0092b00, 0x29006861, 0x68a3d006, 0xd1032b00, 0x680a0020,
    0xfe5ff7ff, 0x46c0bd70, 0x501009ec, 0x4b1eb510, 0x601c4c1e, 0x4b1e2480,
    0x601c05e4, 0x04e424e0, 0x4b1c601c, 0xd02c2800, 0x43202401, 0x61dc4c1a,
    0x426469dc, 0x621c4044, 0x62986259, 0x008921fa, 0x605a434a, 0x68114a15,
    0x42112202, 0x4914d10b, 0x68094814, 0x2103404a, 0x4913400a, 0x2204600a,
    0x42116b81, 0x220cd0fc, 0x4b1062da, 0x32ff32f5, 0x2280601a, 0x05d24b0e,
    0x2201601a, 0x701a4b0d, 0x61d8bd10, 0x46c0e7da, 0x40010008, 0x0001fffc,
    0x4005b000, 0x40058000, 0xb007c0d3, 0x4006c000, 0x40008030, 0x40008000,
    0x40009030, 0x4005a02c, 0x4005a000, 0x50100eb4, 0x0004b570, 0x20001845,
    0xd20142ac, 0xd0002800, 0x4b04bd70, 0x681b0020, 0x479868db, 0x015b2380,
    0xe7f118e4, 0x50100dbc, 0x061222e0, 0x22841881, 0x02d20003, 0x42912001,
    0x22ebd907, 0x189b0612, 0x20002280, 0x429a01d2, 0x47704140, 0x1d85b530,
    0xb2e20f0c, 0x33370013, 0xd8002c09, 0x70033b07, 0x01093001, 0xd1f342a8,
    0xbe00bd30, 0xb5102200, 0x48064b05, 0x7a1b725a, 0xd8002b7f, 0x4a054804,
    0xf7ff4905, 0xbd10fdf5, 0x50100ab8, 0x50100e58, 0x50100e24, 0x00000b5d,
    0x501008b0, 0x6a024b04, 0xb5106cdb, 0xd101429a, 0xffe0f7ff, 0x46c0bd10,
    0x50100ac8, 0x4804b510, 0x7fdb1dc3, 0xd1012b00, 0xfdc2f7ff, 0x46c0bd10,
    0x50100e58, 0x48040003, 0xd8032b03, 0x3b014a03, 0x5898009b, 0x46c04770,
    0x00003db7, 0x00003ee8, 0x02004b02, 0x681b6018, 0x46c04770, 0x4001800c,
    0x0004b570, 0x000d2002, 0xfff2f7ff, 0x230422c0, 0x43290621, 0x0e080552,
    0x66103b01, 0x2b000209, 0xbd70d1f9, 0x4a044b03, 0x00016018, 0x43996893,
    0x4770d1fb, 0x4000f000, 0x4000c000, 0x3029b5f7, 0x4c7a7803, 0xd00a2b00,
    0x60632301, 0x8510f3ef, 0x0020b672, 0x479868a3, 0x8810f385, 0x4b74bdf7,
    0x781b2007, 0xd1092b00, 0x7fde1d63, 0xb25b7fdb, 0xda252b00, 0x07eb68e5,
    0x2005d502, 0xe7e56060, 0xf7ff0028, 0x2800ff55, 0x2004d101, 0x23ebe7f6,
    0x061b2780, 0x01ff18eb, 0xd9f642bb, 0x301c0028, 0xff46f7ff, 0xd0f02800,
    0x18eb4b62, 0xd9ec42bb, 0x0028221c, 0xf0014960, 0x4b60fcf3, 0x601a68e2,
    0xd50e06f3, 0x7fd91da3, 0x1e53000a, 0x4b5c419a, 0x3329b2d2, 0x2902701a,
    0x2201d103, 0x33074b59, 0x07f377da, 0x0673d418, 0x230ad41d, 0xd00c421e,
    0x7fda1de3, 0x33080023, 0x4b537fd9, 0xd0032900, 0x20067819, 0xd1b94291,
    0x07b3701a, 0x230cd410, 0xd125421e, 0xe7b12000, 0x681b4b48, 0x4798689b,
    0xd0e02800, 0x2301e7aa, 0x431368e2, 0xe7dc4798, 0x05036920, 0x6961d1a1,
    0xd19e050b, 0x228025f0, 0x1943062d, 0x42930552, 0x1843d89f, 0x4293195b,
    0x4b3ad89b, 0x691b681b, 0x28004798, 0xe78dd0d7, 0x002868e5, 0xfee4f7ff,
    0xd0052800, 0x18e869e3, 0xfedef7ff, 0xd11e1e07, 0xd40a0733, 0x01922280,
    0xd2064295, 0x18eb69e3, 0xd3004293, 0x2701e77d, 0x21f0e011, 0x06092280,
    0x0552186b, 0xd9004293, 0x69e3e773, 0x185b18eb, 0xd9004293, 0xb2efe76d,
    0xd0002f00, 0x0733e761, 0x4b20d518, 0x469c69a1, 0x2f00681b, 0x69e2d023,
    0x42ab9501, 0x9301d900, 0x18a8331c, 0xd2004283, 0x9b010018, 0xd2024283,
    0x4b154660, 0x00286003, 0xfc5af001, 0xd5070773, 0x69a068e3, 0xd0102f00,
    0x69e20019, 0xfc50f001, 0xd58706b3, 0x681b4b0d, 0x4798685b, 0x0028e736,
    0x4798695b, 0xd0e92800, 0x4a08e730, 0x68120001, 0x69920018, 0x28004790,
    0xe727d0ea, 0x50100d8c, 0x50100eb4, 0xeb00001c, 0x00003ecc, 0x50100dbc,
    0x50100fc0, 0x50100a7c, 0x50100a1c, 0x6a46b5f8, 0x00330004, 0x781b3329,
    0x2b000030, 0xf7ffd023, 0x6963fbcd, 0x001f69e2, 0x69a00005, 0x37401e51,
    0x40192240, 0xd9004287, 0x712a1ac2, 0x68286a23, 0xf0011859, 0x792bfc0d,
    0x00206962, 0x616318d3, 0x681b6aa3, 0x4b064798, 0x681a0030, 0x601a4b05,
    0xfd2ef7ff, 0xf7ffbdf8, 0x0005fba9, 0x46c0e7eb, 0x50100f64, 0xd0000018,
    0x4c0cb570, 0x6ce26a03, 0x42930005, 0x6843d111, 0x60734e09, 0xd0052b00,
    0x6a602102, 0xfcb2f7ff, 0x72732300, 0x6ba269eb, 0x18d30020, 0xf7ff63a3,
    0xbd70ffb1, 0x50100ac8, 0x50100ab8, 0x0004b570, 0x4d0a2601, 0x4b0a7568,
    0x58d000b2, 0xd0022800, 0xf7ff2101, 0x3601fd7f, 0xd1f42e05, 0x41841e60,
    0x0028686b, 0x4798b2e1, 0x46c0bd70, 0x501009ec, 0x50100a08, 0x2000b510,
    0xffe0f7ff, 0x4a052300, 0x4a057513, 0x22016013, 0x42524b04, 0x651a659a,
    0x46c0bd10, 0x501009ec, 0x50110000, 0x50113000, 0x4b0e2220, 0x601ab510,
    0x68184b0d, 0x061b23d0, 0x62586158, 0xfa27f7ff, 0x4b0a2240, 0x009b18c3,
    0x430a6819, 0x601a2180, 0x438a681a, 0x4b06601a, 0x230518c0, 0x604300c0,
    0x46c0bd10, 0x4000f000, 0x50100f64, 0x10007001, 0x08002800, 0x000ab510,
    0xf0012100, 0xbd10fbc7, 0xb5704b11, 0x4c11781a, 0xd1072a00, 0x49114a10,
    0x60116322, 0x61224a10, 0x701a2201, 0x21284d0f, 0xf7ff0028, 0x2370ffe7,
    0x3b66736b, 0x2500752b, 0x00294b0b, 0x611d0020, 0xfd10f7ff, 0x00290020,
    0xf7ff302c, 0xbd70fd0b, 0x50100e20, 0x50100dc0, 0x50100a38, 0x00003dda,
    0x0000144d, 0x50100a7c, 0x50100d3c, 0x780b2260, 0x401ab510, 0x2a202400,
    0xb25bd114, 0x42a3784a, 0x2afeda12, 0x884bd10e, 0xd10b42a3, 0x42a388cb,
    0x4813d008, 0xfadef7ff, 0x701c6803, 0x71043401, 0xfbc4f7ff, 0xbd100020,
    0xd1fb2aff, 0x2b00884b, 0x88cad1f8, 0x2a00001c, 0x4b0ad1f4, 0x7fd11dda,
    0xd1012903, 0x77d13901, 0x781a3352, 0xd1012a03, 0x701a3a01, 0xff98f7ff,
    0xf7ff2401, 0xe7e1fb8f, 0x50100f68, 0x50100dc0, 0x000db5f7, 0x00102180,
    0x00140089, 0xff82f7ff, 0xd1202d00, 0x30c30020, 0x494f220b, 0xf00130ff,
    0x23fffaf7, 0x005b2255, 0x4b4c54e2, 0x54e21892, 0x791a4b4b, 0xd1042a00,
    0x6a924a4a, 0x2201601a, 0x0020711a, 0x30b9681b, 0x30ff9301, 0xa9012204,
    0xfadef001, 0x2d01e023, 0x4b41d111, 0x2a00791a, 0x4a40d103, 0x711d6a92,
    0x681b601a, 0x00202240, 0x9301493d, 0xfaccf001, 0x30270020, 0x2281e7e6,
    0x00521eab, 0xd20c4293, 0xd9002b80, 0x2b003b81, 0x3b08d105, 0x33078023,
    0x80a38063, 0x200080e3, 0x1f6bbdfe, 0x2b1f3bff, 0x2b00d839, 0x492ed1f7,
    0x312b220b, 0xf0010020, 0x2328faab, 0x002372e3, 0x00202264, 0x4d2a4e29,
    0x701a332d, 0x3a594929, 0x862585e6, 0x872586e6, 0xf0013020, 0x0023fa99,
    0x332b2121, 0x23027019, 0x33ef8763, 0x002763e3, 0x22640023, 0x3740334e,
    0x491f737a, 0x805d801e, 0x815d811e, 0x00383a59, 0xfa82f001, 0x21210023,
    0x335a2203, 0x801a72f9, 0x65e3233e, 0x3d25e7bf, 0x076b3dff, 0x08edd1bb,
    0x0022d110, 0x4813219f, 0xfa4ff001, 0x4d120020, 0x0029220c, 0xf0013062,
    0x0020fa67, 0x0029220c, 0xe78130c2, 0xd1a62d01, 0x0020223e, 0xe77b490b,
    0x00003df8, 0x000001ff, 0x50100db4, 0x40054000, 0x00003e6c, 0xffff8299,
    0x00003925, 0x00003dac, 0x00003db8, 0x00003ffa, 0x50100eb5, 0x00003ef4,
    0x4b85b5f0, 0x68120016, 0x9003b085, 0xd002429a, 0xb0052000, 0x4b81bdf0,
    0x429a6872, 0x22fed1f8, 0x4b7f0052, 0x429a58b2, 0x68b3d1f2, 0xd5ef049a,
    0x69f14a7c, 0xd1eb4291, 0x001d2201, 0x42134015, 0x2380d1e6, 0x005b6932,
    0xd1e1429a, 0x003868f7, 0xfc62f7ff, 0xd0042800, 0x30ff0038, 0xfc5cf7ff,
    0x69b30005, 0x2b004c70, 0x22f0d009, 0x18ba0612, 0x2d009201, 0x0011d106,
    0x42914a6c, 0x2000d907, 0xe7c66120, 0x00119a01, 0x42914a68, 0xb2ffd802,
    0xd1f42f00, 0x32294a66, 0x2a007812, 0x3201d1ef, 0x9202402a, 0x27086922,
    0xd0354293, 0x21500020, 0xfe6cf7ff, 0x9a020023, 0x485e334c, 0x2d00701a,
    0x20a8d101, 0x42690540, 0x23a04169, 0x42494d5a, 0x402900db, 0x606118c9,
    0x602008c9, 0xfe56f7ff, 0x001a9b01, 0x429a4b51, 0x4854d806, 0x49554b54,
    0x60e360a0, 0xfe4af7ff, 0x686269b3, 0xd9004293, 0x6123e786, 0x27002301,
    0x9a01425b, 0x4b4761e3, 0x429361a7, 0x3708417f, 0x334c0023, 0x9a02781b,
    0xd1ac4293, 0x69b26973, 0xd2a84293, 0x21280020, 0xf7ff3024, 0x0022fe2b,
    0x32489b03, 0x62636971, 0x68f36163, 0x4a407017, 0x46942001, 0x228062e2,
    0x64220052, 0x324a0022, 0x221f7010, 0x4090400a, 0x094a6825, 0x62210092,
    0x18aa6323, 0x36206815, 0x900163e6, 0xd0004205, 0x2580e74a, 0x05ad69e6,
    0xd20b42b3, 0x41bf42ab, 0x0038427f, 0x41bf42ae, 0x9702427f, 0x98020007,
    0xd0034287, 0xd20242ae, 0xd30042ab, 0x002561e3, 0x782d354c, 0xd11a2d00,
    0x05c9020e, 0x35010ec9, 0x0c71408d, 0x008968a6, 0x680e1871, 0xd10e422e,
    0x031b0b1b, 0x23806363, 0x63a3015b, 0x431d680b, 0x0021600d, 0x31482302,
    0x432b780d, 0x69a3700b, 0x33019801, 0x681361a3, 0x43180021, 0x4d0e4663,
    0x35286010, 0x222862e3, 0x480b3124, 0xf001782b, 0x2001f93f, 0xbf407028,
    0x7020344b, 0x46c0e6fd, 0x0a324655, 0x9e5d5157, 0x0ab16f30, 0xe48bff56,
    0x50100d3c, 0x0fffff01, 0x50100fc0, 0x50100ec4, 0x0001dce0, 0x15003c3c,
    0x00001e1e, 0x000003c3, 0x00001631, 0x000db570, 0xf8c8f7ff, 0x00290004,
    0xf7ff6800, 0x6820fd97, 0xbd707125, 0xb5102200, 0x210d4c07, 0x48071da3,
    0xf7ff77da, 0x220dffeb, 0xf0010021, 0x4804f905, 0xf94cf7ff, 0x46c0bd10,
    0x50100a7c, 0x50100dc0, 0x00000705, 0x1dc3b510, 0x2b007fdb, 0x4b05d109,
    0xd1064298, 0x33064b04, 0x2b007fdb, 0xf7ffd001, 0xbd10ffd9, 0x50100dc0,
    0x50100a7c, 0x4a0cb510, 0x7fd91d53, 0xd1072901, 0x005b2380, 0x84934809,
    0xf7ff3101, 0xbd10f9a7, 0xd1052902, 0x48052200, 0x302c77da, 0xf99ef7ff,
    0xffbcf7ff, 0x46c0e7f3, 0x50100a7c, 0x50100dc0, 0xb5702300, 0x1d654c11,
    0x622377eb, 0x33017b05, 0xd8002d7f, 0x429a3301, 0x1d62d007, 0x230277d3,
    0xf7ff7323, 0x2000ffcf, 0x6883e00f, 0xd008428b, 0x77c21d60, 0xd201428b,
    0x73222202, 0xd900428b, 0x2001000b, 0x2b006223, 0xbd70d0eb, 0x50100a7c,
    0x7c82b5f8, 0x02127c43, 0x7cc3431a, 0x041b000f, 0x7d03431a, 0x061b7dc1,
    0x7d824313, 0x43110209, 0xba494e20, 0xba1b0032, 0x2f01b289, 0x322cd000,
    0x02494c1d, 0x003a6262, 0xf7ff62e3, 0x2800ffb9, 0x4b1ad029, 0x2d3f6a1d,
    0x4a19d928, 0x68130020, 0x33014918, 0x233f6013, 0x4b17439d, 0x62a361a5,
    0x4a174b16, 0x23806223, 0x61e3009b, 0x61632300, 0xff7ef7fe, 0x68a3353f,
    0x195b09ad, 0x68e360a3, 0x60e5195d, 0xd1072f01, 0x00302300, 0x60f360b4,
    0xf7ff74a7, 0xbdf8f86d, 0xe7fc63b4, 0xff6af7ff, 0x46c0e7f9, 0x50100dc0,
    0x50100a4c, 0x50100a7c, 0x50100a20, 0x00003e17, 0x00003de4, 0x50100b1c,
    0x00001475, 0x0005b570, 0xf7fe480c, 0x68a9ffe7, 0x00047903, 0xd9004299,
    0x22010019, 0xf7ff0028, 0x2800ff67, 0x4a06d009, 0x6a134806, 0x68917123,
    0x1acbb2db, 0xf7ff6093, 0xbd70f86d, 0x50100dc0, 0x50100a7c, 0x00001475,
    0x4b082100, 0x1d5ab510, 0x688277d1, 0xd006428a, 0x22017b01, 0xd800297f,
    0x33051892, 0xf7ff77da, 0xbd10ff25, 0x50100a7c, 0x68024b1a, 0xb5106959,
    0x428a0004, 0x6840d111, 0xd10e2800, 0x6919699a, 0xd10a428a, 0x324c001a,
    0x2a007812, 0x69d8d000, 0x491122fa, 0xf7ff0092, 0xcc0af9cd, 0x8410f3ef,
    0x4a0eb672, 0x42916812, 0x2b00d111, 0x2201d00c, 0x731a4b0b, 0x73da3206,
    0x765a3219, 0x769a3a1e, 0x77da3305, 0xfef2f7ff, 0xf7ff4806, 0xf384fbab,
    0xbd108810, 0x50100d3c, 0x20042000, 0x50100a20, 0x50100a7c, 0x50100a4c,
    0xb5102100, 0xf7ff480f, 0x480ff979, 0xf7ff2100, 0x480ef975, 0x2b007a43,
    0x2280d003, 0x02924b0c, 0x2110601a, 0xfc36f7ff, 0x22004b0a, 0x33290019,
    0x700a3128, 0x4b08701a, 0x33290019, 0x700a3128, 0xbd10701a, 0x50100e58,
    0x50100e24, 0x50100ab8, 0x4001a01c, 0x50100fc0, 0x50100e84, 0x4b052280,
    0xb5100292, 0x2900601a, 0xf7ffd003, 0xf7fffc19, 0xbd10ffc7, 0x4001a01c,
    0x780b2260, 0xb5102000, 0x2a40401a, 0xb25bd113, 0x4283784a, 0x2a42da10,
    0x88ccd10d, 0xd10a2c10, 0x48090021, 0xfe5af7ff, 0x49080022, 0xff74f000,
    0xf80cf7ff, 0xbd102001, 0xd1fc2a41, 0xffa4f7ff, 0xffecf7fe, 0x46c0e7f6,
    0x50100f68, 0x50100ab8, 0x4e18b5f8, 0x001524c0, 0x056446b4, 0x4316001e,
    0xd103432e, 0xf7ff2003, 0xbdf8f9ff, 0x6a666a27, 0xd0152a00, 0x2f0d19bf,
    0x1e07d812, 0x7807d001, 0x66273001, 0x2e003a01, 0x6e26d0e8, 0xd0012b00,
    0xe7e33b01, 0xd0012900, 0x3101700e, 0xe7dd3d01, 0xd1f22e00, 0x27c04666,
    0x02bf6836, 0xd0d5423e, 0x46c0e7d8, 0x4001801c, 0x000cb510, 0x20030001,
    0xf9daf7ff, 0x23042280, 0x20000021, 0xf7ff0052, 0xbd10ffbf, 0xb51023f0,
    0x18c0061b, 0xffecf7ff, 0xbd102000, 0x2002b510, 0xf9bef7ff, 0x220623c0,
    0x661a055b, 0x23012200, 0x00100011, 0xffa8f7ff, 0xbe00bd10, 0x26c0b573,
    0x05762401, 0xf7ff2002, 0x2305f9ab, 0x466b6633, 0x00221ddd, 0x00290023,
    0xf7ff2000, 0x782bff95, 0xd0054223, 0x681a4b03, 0x029b23c0, 0xd0e9421a,
    0x46c0bd73, 0x4001801c, 0x0005b570, 0xf7ff000c, 0x0029ffcd, 0xf7ff0020,
    0x2200f993, 0x00112304, 0xf7ff0010, 0xf7ffff79, 0xbd70ffd1, 0xb51023f0,
    0x18c0061b, 0xf7ff2120, 0x2000ffe7, 0xb570bd10, 0x000c0005, 0xffb2f7ff,
    0x20020029, 0xf978f7ff, 0x23042280, 0x00202100, 0xf7ff0052, 0xf7ffff5d,
    0xbd70ffb5, 0xb51023f0, 0x18c0061b, 0xffe7f7ff, 0xbd102000, 0x4b822280,
    0x0452b5f0, 0x4a81601a, 0x68120006, 0xb085000d, 0xd4390792, 0x4a7e2003,
    0x4c7f497e, 0x4a7f6011, 0x4a7f6010, 0x67a2487f, 0x3aff3aff, 0x6c606002,
    0xd0fc4210, 0x00522280, 0x65a26422, 0x60114a7a, 0x29006851, 0x2080dafc,
    0x60180140, 0xf94ef7ff, 0x4b762201, 0x601a2121, 0x609a3263, 0x02d222aa,
    0x4a7360da, 0x68196011, 0xdafc2900, 0x60132308, 0x63e32300, 0x22012382,
    0x6563011b, 0x601a4b6d, 0x6c622302, 0xd0fc421a, 0x04402080, 0xf92ef7ff,
    0x4b69220c, 0x62da2180, 0x32f54b68, 0x601a32ff, 0x4b672201, 0x601a4867,
    0xf7ff0149, 0x4b66fadf, 0x43eb601e, 0xd100079b, 0x2e002500, 0xf7ffd001,
    0x4c62faaf, 0x00204b62, 0xf7ff6819, 0x4b61f8a7, 0x68191da0, 0xf8a2f7ff,
    0x4c5f2601, 0xd01f2d00, 0x22204f5e, 0x00380021, 0xfe3ef000, 0x70bb2320,
    0x26012300, 0x002b70fb, 0x93034033, 0xd0074235, 0x00380021, 0x31202217,
    0xf0003009, 0x2600fe2d, 0x713b2301, 0x72fb2300, 0x003c9b03, 0xd1082b00,
    0x4f4f0021, 0x00384a4f, 0xf7fe3109, 0x4b4efd91, 0x07ab607b, 0x2117d40f,
    0x4e4c4371, 0x4a4c3109, 0x18610030, 0xfd84f7fe, 0x4a4b4b4a, 0x4a4b601a,
    0x4b4b6053, 0x4b4b6073, 0xd1002d01, 0x4d4a3304, 0x60ec4a4a, 0x4f4a2400,
    0x4b4a612b, 0x602a0021, 0x220160ab, 0x94002340, 0xf7fe0038, 0x4e46fd55,
    0x00210022, 0x94002340, 0xf7fe0030, 0x2380fd4d, 0x005b0021, 0x832b0038,
    0xfd12f7fe, 0x00212380, 0x0030005b, 0xf7fe832b, 0x23c0fd0b, 0x832b005b,
    0x4b3a3401, 0x58d000a2, 0xd0022800, 0xf7fe2100, 0x3401fcff, 0xd1f42c05,
    0x20004b35, 0x4b35606b, 0x001c4a35, 0x33040019, 0x42936008, 0x2309d1fa,
    0x33036763, 0x3b0b67a3, 0xf7ff6423, 0x4b2ffa03, 0x64e34a2f, 0x601a4b2f,
    0x4a2f2320, 0x4a2f6013, 0xf7fe6013, 0x46c0fbe5, 0x4000e000, 0x4006c000,
    0x40060000, 0x00fab000, 0x40008000, 0x4000b030, 0x000001ff, 0x4000b03c,
    0x40024000, 0x40028000, 0x4002b004, 0x4000a03c, 0x40058000, 0x4005a02c,
    0x14003000, 0x50100000, 0x50100f64, 0x50100eb5, 0x40000040, 0x00000050,
    0x00003e19, 0x50100d1c, 0x50100e18, 0x00003ddc, 0x00000fb5, 0x50100e50,
    0x00003f38, 0x50100aa4, 0x00003dec, 0x50100e58, 0x00001729, 0x00003e64,
    0x501009ec, 0x00003e50, 0x50100f68, 0x00000b75, 0x50100f94, 0x50100a08,
    0x0000170d, 0x50110000, 0x50110084, 0x20010000, 0x000113f0, 0x50110090,
    0xe000e280, 0xe000e100, 0xb5104b02, 0x691968d8, 0xfe98f7ff, 0x40058000,
    0xb5f74b24, 0x4b24681a, 0x601a6884, 0x69e50002, 0x69633229, 0x1e6e7812,
    0x9201401e, 0xd0152a00, 0xd0032e00, 0xf7ff0020, 0xbdf7f90d, 0x195969a2,
    0xd9004291, 0x2d001ad5, 0x6aa3d0f4, 0x791b4a17, 0x5ad30028, 0x28004798,
    0xe7eed0ec, 0xfcd2f7fe, 0x69a26961, 0x00073140, 0x429169e3, 0x0015d312,
    0x400d1e59, 0xd100420a, 0x2e00001d, 0x69e1d103, 0xf7ff6a20, 0x6a23f993,
    0x6839793a, 0xf0001998, 0xe7d8fd0b, 0x0033001d, 0x42ab3340, 0x9d01d2ed,
    0x46c0e7eb, 0x50100f64, 0xd0000014, 0x0000043c, 0x0006b5f8, 0xfca6f7fe,
    0x2b1f7903, 0xe0a0d000, 0x4b556805, 0x429a682a, 0xe09ad000, 0x2b007b6b,
    0xe096d000, 0x337f7b29, 0x401a000a, 0xd0004219, 0x7babe08f, 0x2b0f3b01,
    0xe08ad900, 0x4b4c4c4b, 0x686b6023, 0x68ab6063, 0x7beb60a3, 0xd0022b03,
    0x766273e2, 0x270076a2, 0x2b237327, 0xd818d047, 0xd03b2b1a, 0x2b03d80d,
    0x2b12d051, 0x42bbd025, 0x2301d05a, 0x33047323, 0x331b73e3, 0x23007663,
    0x2b1be05c, 0x2b1ed05c, 0x0028d1f3, 0xfc98f7ff, 0x2b2ae00a, 0xd80bd029,
    0xd0312b25, 0x2b282101, 0x0028d1e7, 0xfc08f7ff, 0xf7fe0030, 0xbdf8fdd5,
    0xd0ea2b2f, 0xd0e82b35, 0x2124e7db, 0xf7ff482d, 0x2119fb7d, 0x482c0004,
    0x18400022, 0xfc75f000, 0x70632380, 0xf7ff0028, 0xe7e5fc51, 0x48252104,
    0xfb6cf7ff, 0x60032303, 0x2102e7f4, 0x210ce7d9, 0xf7ff4820, 0x220cfb63,
    0xf0004920, 0xe7e9fc7d, 0x481c2108, 0xfb5af7ff, 0x491d2208, 0x2112e7f5,
    0xf7ff4818, 0x0021fb53, 0x310d2212, 0xfc6cf000, 0x766773e7, 0xe7d576a7,
    0x7fd21de2, 0xd0ac2a00, 0x73222201, 0x73e21892, 0x76623238, 0xe7a476a3,
    0x7ceb2203, 0x2b024013, 0x3407d19f, 0x77e33b01, 0x4c08e79b, 0x00202103,
    0xfd1cf7fe, 0x21030020, 0xf7fe302c, 0xe79ffd17, 0x43425355, 0x50100a7c,
    0x53425355, 0x50100dc0, 0x00003f40, 0x00003e0b, 0x00003e03, 0x4b09b510,
    0x6a5a4c09, 0x78123229, 0xd1002a00, 0x4a084c07, 0x1c486811, 0x60106ad9,
    0x62da1c4a, 0x47a04a05, 0x46c0bd10, 0x50100a4c, 0x00001031, 0x000011b9,
    0x50100a20, 0x50100b1c, 0x4baab5f7, 0x9301681b, 0xd40003db, 0xf3bfe088,
    0x4fa78f5f, 0x00382100, 0xf7fe2401, 0x4ea5fdc3, 0x00302100, 0xfdbef7fe,
    0x1cb3211f, 0x4aa277dc, 0x77dc1cbb, 0x00157813, 0x42a14019, 0xe0a2d100,
    0xd1002902, 0x2900e0ca, 0x3160d157, 0xd154420b, 0x2b00b25b, 0x0038da4c,
    0xfb9cf7fe, 0x0007786b, 0x2b066806, 0x2b08d00d, 0x2b00d03e, 0x8033d145,
    0x88eb1924, 0xdd0042a3, 0x713b0023, 0xfc76f7fe, 0x8868e04a, 0x2b020a03,
    0x2b03d00d, 0x2b01d016, 0x4b8ad133, 0x68192412, 0xd0ea2900, 0x00300022,
    0xfbcaf000, 0xb2c0e7e5, 0xd1262800, 0x68d94b83, 0x788b78cc, 0x431c0224,
    0xe7efd0db, 0x2800b2c0, 0x4b7ed00f, 0x689b2402, 0x30014798, 0x781b1e43,
    0xd1032b00, 0x70343303, 0xe7ca7073, 0x34025333, 0x2404e7f3, 0xe7d94976,
    0x7d5b4b74, 0xe7c07033, 0x2b057853, 0x2b09d004, 0xf7fed038, 0xe00bfd3d,
    0x56d32302, 0x2b008851, 0x4b6cddf7, 0x75990038, 0x496d4a6c, 0xfbfcf7fe,
    0x4b6c2280, 0x651a0292, 0x06db9b01, 0x2600d50a, 0x4f692401, 0x2d006dbd,
    0x2e0ad004, 0xe082d000, 0x659d4b64, 0x04db9b01, 0xf7fed505, 0x2280ffbf,
    0x03124b60, 0x23f8651a, 0x009b9a01, 0xd008421a, 0x6d1b4b5d, 0xdb002b00,
    0x2280e07e, 0x06124b59, 0xbdf7651a, 0x28007890, 0x4b52d004, 0x795b68db,
    0xd1be4283, 0xff86f7fe, 0xfbdcf7fe, 0x8893e7c8, 0x7d514a4c, 0xd0b42900,
    0x420b21fe, 0x6912d1b1, 0x009bb2db, 0x28005898, 0x6843d0ab, 0xd1142b00,
    0x782b2260, 0xd1a44213, 0x0a1288aa, 0xb25bd1a1, 0xda9e2b00, 0x2c00786c,
    0x0038d19b, 0xfae6f7fe, 0x601c6803, 0x71032302, 0x0029e754, 0x28004798,
    0xe7e5d19e, 0x2a008892, 0x2a80d041, 0x4935d060, 0x29007d49, 0xe784d100,
    0x00a04938, 0x68065840, 0x42b278b6, 0x3401d034, 0xd1f62c05, 0x7869e779,
    0xd00a2901, 0xd0002903, 0x886be773, 0xd0002b00, 0x2102e76f, 0xfbdaf7fe,
    0x886be7ae, 0xd0002b00, 0x1dc2e767, 0x2a027fd2, 0xf7fed802, 0xe7a3fcb7,
    0x77c33002, 0x422ce7a0, 0x2101d00b, 0x4b216dfa, 0x659c4022, 0x1e530870,
    0x43b1419a, 0xfbe6f7fe, 0x006443a5, 0xe7663601, 0xff30f7fe, 0x0030e781,
    0x42132260, 0xe744d000, 0x2b00b25b, 0x786bdac7, 0xd0002b00, 0x886be73d,
    0xd0002b00, 0x88ece739, 0xd0002c02, 0x2501e735, 0x7fc33007, 0x429d0038,
    0xf7fe41ad, 0x6803fa7b, 0x601d426d, 0xe6e97104, 0xe7dd0038, 0x50110098,
    0x50100f68, 0x50100f94, 0x50100000, 0x501009ec, 0x00003f32, 0x0000045d,
    0x501009c4, 0x50113000, 0x50110000, 0x50100a08, 0xf7feb510, 0xbd10fbdd,
    0x4a1ab5f8, 0x601a4b1a, 0x8510f3ef, 0xf3bfb672, 0x4c188f5f, 0x37280027,
    0xb2de783b, 0xd1132b00, 0x8810f385, 0x8510f3ef, 0xf3bfb672, 0x4c128f5f,
    0x37280027, 0x2b00783b, 0x2228d013, 0x480f0021, 0xfa8af000, 0xe006703e,
    0x00212228, 0xf000480b, 0x2300fa83, 0xf385703b, 0x00208810, 0xfd4af7fe,
    0xf385e7d2, 0xbf208810, 0x46c0e7ce, 0x00003ecc, 0x50100dbc, 0x50100fc0,
    0x50100e84, 0x50100d8c, 0x9001b5f7, 0xfa16f7fe, 0x2b207903, 0xe09ed000,
    0x4b536806, 0x429a6832, 0xe098d000, 0x21284c51, 0x302c0020, 0xfedaf7fe,
    0x68134a4f, 0x60133b01, 0x62e36872, 0x7a3364e2, 0x4b4c9300, 0x601a9900,
    0x725a2200, 0x605a3201, 0x72196932, 0x63a263e2, 0x00224694, 0x32516971,
    0x7c306421, 0x227f7010, 0x40029800, 0x28081e50, 0xe070d900, 0x43422003,
    0x7a77483f, 0x42af5c85, 0x2500d161, 0x605d1880, 0x78407843, 0xb240000d,
    0xdb002800, 0x68f3001d, 0xd15642ab, 0x189a4b36, 0x78979b00, 0xd1092b02,
    0x69b24660, 0xfbf6f7fe, 0xfc80f7fe, 0xf7fe9801, 0xbdf7fb43, 0xd0472f00,
    0x33500023, 0x0023701f, 0x26012202, 0x701a3352, 0x725e4b28, 0xd0282d00,
    0x4a294b28, 0x62236463, 0x005b2380, 0x230061e3, 0x616362a2, 0x61a54a25,
    0x49250020, 0xf90cf7fe, 0x68a3353f, 0x195b09ad, 0x68e360a3, 0x195d003a,
    0x60e52308, 0x421f401a, 0x4b1ed003, 0x60dc6263, 0x481de7cc, 0x626074a6,
    0x60c26084, 0xf9f4f7fe, 0x481ae7c4, 0x00050021, 0x35284b19, 0x22286363,
    0x782b312c, 0xf9d0f000, 0xbf40702e, 0x2202e7b6, 0x9b00e004, 0xd0ab2b02,
    0x4b082203, 0x2102605a, 0xf7fe480d, 0x2102fa8f, 0xf7fe480a, 0xe7a5fa8b,
    0x431fd10b, 0x50100ac8, 0x50100eb0, 0x50100ab8, 0x00003eac, 0x501008c4,
    0x00003df0, 0x00000b15, 0x00003e17, 0x50100e58, 0x50100e24, 0x50100e84,
    0x00000b45, 0x4c09b570, 0x64a04b09, 0x00214809, 0x63630005, 0x22283528,
    0x782b312c, 0xf994f000, 0x70282001, 0x3453bf40, 0xbd707020, 0x50100ac8,
    0x00000e59, 0x50100e84, 0x220023c0, 0x609a055b, 0x49054a04, 0x001a601a,
    0x601132f4, 0x609a2201, 0x46c04770, 0x001f0300, 0x03000218, 0xf7ffb510,
    0x2000ffeb, 0xbe00bd10, 0x230122a0, 0x0552b510, 0x68526053, 0x20004a02,
    0xf7fe6013, 0xbd10fc0d, 0x14002000, 0x0004b5f8, 0x001f0015, 0x42b41846,
    0x22c0d205, 0x02924b0c, 0x4213681b, 0xbdf8d000, 0x421c1e6b, 0x1b33d108,
    0xd30542ab, 0x00390020, 0xfa5ef7ff, 0xe7ea1964, 0x21200020, 0xfa58f7ff,
    0x015b2380, 0xe7e218e4, 0x4001801c, 0x0005b5f8, 0x0004000f, 0x1b791886,
    0x42b41909, 0x22c0d205, 0x02924b05, 0x4213681b, 0xbdf8d000, 0x34010020,
    0xfa59f7ff, 0xe7ee34ff, 0x4001801c, 0xb5f02301, 0x425bb085, 0x803baf03,
    0x220023c0, 0x609a055b, 0x6c9a6a9a, 0x615a2206, 0x02d222e0, 0x2201601a,
    0x611a4c1f, 0x6826609a, 0x0032238c, 0x439a2584, 0x43152003, 0xfbb0f7fe,
    0x93012302, 0x60252380, 0x6065011b, 0x60e560a5, 0xd1fd3b01, 0x22042300,
    0x00180019, 0xf994f7ff, 0x2108230c, 0x2002439d, 0xf7fe430d, 0x9901fb99,
    0xd1162901, 0x6026220c, 0x43966066, 0x26080033, 0x60a6431e, 0x60e62002,
    0xfb8af7fe, 0x22022300, 0x00380019, 0xf978f7ff, 0x4b042200, 0xb005601a,
    0x2301bdf0, 0x46c0e7cd, 0x40020008, 0x4001800c, 0x4b072090, 0xb5100080,
    0xf7fe6018, 0x2200fb8b, 0x605a4b04, 0x615a60da, 0x625a61da, 0xbd1062da,
    0x4000e000, 0x40018000, 0xf7ffb510, 0xf7ffffe9, 0x4b04ff91, 0x2b00681b,
    0xf7fed001, 0x2000fd0d, 0x46c0bd10, 0x50100f64, 0x4a2bb5f8, 0x60134b2b,
    0x60134a2b, 0x4b2b2202, 0x4213681b, 0x2105d008, 0x60194b29, 0x061b23d0,
    0x641a631a, 0x641a2200, 0x005b23c8, 0xd1fd3b01, 0x240920d0, 0x25042200,
    0x06002101, 0x3b01002b, 0x6883d1fd, 0x085b3c01, 0x18d2400b, 0xd1f52c00,
    0xd9232a04, 0xf7ff26c0, 0xf7ffffaf, 0x0576ff57, 0x22c02700, 0x683360b7,
    0x43934d16, 0x4313b2e2, 0x23016033, 0x60b30029, 0xf7ff0038, 0x2201f93d,
    0x002821fc, 0xf0004252, 0x4b0ff833, 0x4298681b, 0x2380d008, 0x019b3440,
    0xd1e1429c, 0x00082100, 0xf9a4f7ff, 0xfee8f7ff, 0x46be3501, 0x46c04728,
    0x4000e000, 0x00200240, 0x4000f000, 0x4006c000, 0x4001800c, 0x20041f00,
    0x20041ffc, 0xb5104b05, 0x60d8220a, 0x48046119, 0xf7fe4904, 0xbf30fa1b,
    0x46c0e7fd, 0x40058000, 0x00001b99, 0x20042000, 0x1809b530, 0xe00c4d5d,
    0xba137804, 0x0624405c, 0x00642308, 0x406cd300, 0xd1fa3b01, 0x40620212,
    0x42883001, 0x1c10dbf0, 0xb530bd30, 0x5c434249, 0x0a1c3201, 0xd10541ad,
    0x3101b25d, 0x41aa5c44, 0x5d631b14, 0x35015553, 0x3101d1fb, 0xbd30d1ef,
    0x2a084684, 0xb470d33a, 0x3a01e01c, 0x54835c8b, 0x4660d1fb, 0x46c04770,
    0x2a084684, 0x1a43d32e, 0xd1f2079b, 0x1a09b470, 0x08431c05, 0x5c44d302,
    0x30017004, 0xd3020883, 0x80045a44, 0x18093002, 0x19521a2d, 0xd3033a10,
    0xc078c978, 0xd2fb3a10, 0xd3010752, 0xc018c918, 0xd3010052, 0xc008c908,
    0x0052d009, 0x880bd304, 0xd0048003, 0x30023102, 0x780bd001, 0xbc707003,
    0x47704660, 0x0092a309, 0x33011a9b, 0x46c04718, 0x7183798b, 0x7143794b,
    0x7103790b, 0x70c378cb, 0x7083788b, 0x7043784b, 0x7003780b, 0x47704660,
    0xb2c94684, 0x4319020b, 0x46c0e011, 0x2a084684, 0x0843d32a, 0x7001d301,
    0xb2c93001, 0x4319020b, 0xd3010883, 0x30028001, 0x1a1b4663, 0xba0b18d2,
    0x1c0b4319, 0xd3073a10, 0x1c0cb430, 0x46c01c0d, 0x3a10c03a, 0xbc30d2fc,
    0xd3000752, 0x0052c00a, 0xc002d300, 0x0052d006, 0x8001d302, 0x3002d002,
    0x7001d000, 0x47704660, 0x1a9ba305, 0x33011a9b, 0x71814718, 0x71017141,
    0x708170c1, 0x70017041, 0x47704660, 0x04c11db7, 0x4608b505, 0xbd0a461a,
    0x02400dc2, 0x24010a40, 0x432005e4, 0xb2d22aff, 0x4240d900, 0x2afe3a01,
    0x3a7ed201, 0x28004770, 0xd5004620, 0x3a7e4240, 0x32800092, 0x0fc44770,
    0xd50407e4, 0xd0002d00, 0x42403001, 0x3a01d403, 0xd0121800, 0x3281d5fb,
    0x3080d101, 0x3080d205, 0x2d00d203, 0x0040d00f, 0x2afe3a01, 0x3201da06,
    0x0a40dd07, 0x431005d2, 0x47704320, 0x05c020ff, 0x2000e7fa, 0x06054770,
    0x0a40d1ed, 0xe7eb0280, 0x140cb283, 0x14044363, 0x436cb28d, 0xb284191b,
    0x0425436c, 0x191b0c24, 0x14091400, 0x02c04348, 0x430d06d9, 0x18401159,
    0x00424770, 0xd0010e12, 0xd1012aff, 0x05c00dc0, 0x0e12004a, 0x2affd001,
    0x0dc9d101, 0x220105c9, 0xd4094041, 0xd5004041, 0x42884252, 0xdb00dc02,
    0x42522200, 0x47701e10, 0x18494301, 0x2800d0f8, 0xe7f6daf8, 0xb5102100,
    0xff86f7ff, 0x33820013, 0x440ad410, 0xdb073a17, 0xdd192a07, 0x43c917c1,
    0x07c02001, 0xbd104048, 0x2a204252, 0x2220db00, 0xbd104110, 0xbd102000,
    0xb5102100, 0xff6cf7ff, 0x0001440a, 0x3a17d4ee, 0x43c1dbee, 0xdce92a08,
    0xbd104090, 0xb5302200, 0xd5062900, 0x430507cd, 0x3a010848, 0x2200e010,
    0x0005b530, 0xd015430d, 0x160c17cd, 0xd10542ac, 0x0e4401c9, 0x01c04321,
    0xe7f63207, 0x00080005, 0x323d4252, 0x2100e004, 0x221db530, 0x25001a52,
    0xff55f7ff, 0x2100bd30, 0x2800b530, 0x221edaf5, 0x07c51a52, 0xe7f30840,
    0x46a42500, 0x2900e00d, 0xe005dc02, 0xda032a00, 0x427f1b89, 0xe0011912,
    0x1b121989, 0x43674664, 0xcb101bc0, 0xd2000864, 0x46063501, 0x460f412e,
    0x0864412f, 0xb5c04770, 0xffe2f7ff, 0xffe6f7ff, 0x1386d3fc, 0x10d2138f,
    0x43574356, 0x43674664, 0x133f1336, 0x19891bc0, 0xb5c0bdc0, 0xffd0f7ff,
    0xffd1f7ff, 0x2900d3fc, 0x1989dc02, 0xe0011b12, 0x19121b89, 0x10641076,
    0xe7edd1f5, 0x2118b530, 0xff69f7ff, 0x09244c5d, 0xdafd1b00, 0xd4fd1900,
    0x00650082, 0x21004853, 0xdb0242a2, 0x42401b52, 0x00d2e7fa, 0x2401a355,
    0xffc5f7ff, 0x22003109, 0x25002300, 0xf80cf000, 0xfeedf7ff, 0xfed0f7ff,
    0xf806f000, 0xb500e78f, 0xffd8f7ff, 0xbd004608, 0x07642401, 0xdc0342a0,
    0x42a04264, 0x4770dd00, 0x47700020, 0xf7ffb570, 0xe18cffc9, 0x2118b530,
    0xff31f7ff, 0x4a3c1401, 0x14c94351, 0x10493101, 0x0142b402, 0x43414839,
    0x48391a52, 0xa3482100, 0xf7ff43cc, 0x4408ff90, 0xe764bc04, 0xf7ffb530,
    0x0001fea3, 0x4933d415, 0xfedef7ff, 0xd3011051, 0x10403101, 0x4601b402,
    0x009b4b2e, 0x1ac918c0, 0xa33b2200, 0xf7ff43d4, 0x4611ff88, 0x0013bc04,
    0x22ffe749, 0xb530e7fb, 0xffe0f7ff, 0xdc0a2b46, 0x2b46425b, 0x4824dc06,
    0x31084358, 0x1a081109, 0xe7382205, 0x22ff43c0, 0xb530e735, 0xfe74f7ff,
    0xfe6ef7ff, 0xfe70f7ff, 0x01490140, 0x126418d4, 0xd40a3401, 0xda051ad4,
    0x41204264, 0xd30c2c1c, 0xe00a17c0, 0x2c1c4121, 0x2800d307, 0x4813da03,
    0x404817c9, 0x17c8e013, 0x2200e011, 0xda022800, 0x42494240, 0xa30d4a0d,
    0xf7ff2401, 0x4610ff46, 0x18844a0a, 0x1a84d202, 0x1aa0d400, 0x22003801,
    0x46c0e701, 0x136e9db4, 0x00001715, 0x162e42ff, 0x2c9e15ca, 0x0593c2b9,
    0x0162e430, 0x6487ed51, 0x3b58ce0c, 0x1f5b75f8, 0x0feadd4c, 0x07fd56ec,
    0x03ffaab8, 0x01fff554, 0x00fffeac, 0x007fffd4, 0x003ffffc, 0x001ffffc,
    0x00100000, 0x00080002, 0x464fa9ec, 0x464fa9ed, 0x20b15df4, 0x1015891c,
    0x0802ac44, 0x0802ac45, 0x04005564, 0x02000aac, 0x01000154, 0x0080002c,
    0x00400004, 0x00200004, 0x00100000, 0x00080000, 0x00080003, 0x40514ab9,
    0x17c4b570, 0x0e120042, 0x2affd051, 0x17cdd052, 0x0e1b004b, 0x2bffd051,
    0x4eb3d052, 0x40314030, 0x43303601, 0x40604331, 0x1b004069, 0x1a9d1b49,
    0xd40d1ad4, 0xda082c1e, 0x00133520, 0x40aa000a, 0xe00b4121, 0x00082200,
    0x0013e00a, 0xe0072200, 0xdaf72d1e, 0x00023420, 0x412840a2, 0xd0191840,
    0xd0030fc1, 0x425243c0, 0x3001d100, 0x42b019b6, 0x1892d204, 0x3b014140,
    0xd3fa42b0, 0xd3020840, 0x2a003001, 0x2bfed009, 0x07c9d20a, 0x05db4408,
    0xbd704418, 0xd0fc2a00, 0x0840e7e2, 0xe7f20040, 0x07c8da01, 0x0208bd70,
    0x05c030ff, 0x3a20bd70, 0xe7ac1912, 0x44220212, 0x3b20e7a9, 0xe7ac195b,
    0x442b021b, 0x46c0e7a9, 0x4602b580, 0x0fd2404a, 0x469607d2, 0x00490040,
    0xd03d0e02, 0xd03c2aff, 0xd03c0e0b, 0xd03b2bff, 0x3f8018d7, 0x02090200,
    0x0a490a40, 0x46941842, 0x09cb09c2, 0x4348435a, 0xd3020c92, 0xd4002800,
    0x02433201, 0x02520dc0, 0x44601880, 0xd10e0dc1, 0xd22b2ffe, 0xd301005b,
    0x3001d005, 0x05ff3701, 0x44704438, 0x3001bd80, 0x00400840, 0x3701e7f6,
    0xd2132ffe, 0xd3020840, 0x2b003001, 0x19ffd005, 0x05bf3701, 0x44704438,
    0x0840bd80, 0xe7f60040, 0x02123a10, 0x3b10e7c0, 0xe7c1021b, 0x3701da12,
    0x3002d10e, 0x28030dc0, 0xe005d10a, 0x3701da0a, 0x3001d106, 0xd0030dc0,
    0x05c02001, 0xbd804470, 0xbd804670, 0x05c020ff, 0xbd804470, 0x2401b570,
    0x05e44266, 0x0a52024a, 0x09d34322, 0x062d25d0, 0x666b662e, 0xb2f30dc6,
    0x0a400240, 0x0dc94320, 0x0a36404e, 0x6f2d07f6, 0x2900b2c9, 0x29ffd030,
    0x2b00d02c, 0x2bffd039, 0x1a5bd02a, 0x0a01337d, 0x0c094369, 0x001403c0,
    0x1b04434c, 0x436c12a4, 0x03491424, 0x0f0c1909, 0x3105d108, 0xd30f090c,
    0x028008c9, 0x1a404351, 0xe008d40a, 0x31093301, 0xd305094c, 0x02400909,
    0x1a404351, 0x3401d400, 0xd2092bfe, 0x186005d9, 0xbd701980, 0xd10c2bff,
    0x05c020ff, 0xbd704330, 0x1c59dafa, 0x0e61d105, 0x2001d303, 0x433005c0,
    0x0030bd70, 0x46c0bd70, 0x0041b410, 0x0209d23a, 0x22010a49, 0x188905d2,
    0xd03a0dc2, 0xd0362aff, 0x1052327d, 0x0049d300, 0x0d4ba41a, 0x09c85ce4,
    0x43604360, 0x43601300, 0x02241340, 0x34aa1a24, 0x43400020, 0x0a0b0bc0,
    0x13004358, 0x15404360, 0x43631a24, 0x00180bdb, 0x02494340, 0x11401a08,
    0x01db4344, 0x301013e0, 0x44031180, 0x461cd306, 0x43644164, 0x1b090409,
    0x3301d400, 0x18d005d2, 0x4770bc10, 0xd0040e09, 0x05c017c0, 0x0dc0e7f8,
    0x0fc0e7fb, 0xe7f307c0, 0xbbc9daf1, 0x979ea6b0, 0x82868b91, 0x80000000,
    0x007fffff, 0x2401b5f0, 0x406307e4, 0x46c0e001, 0x0d0cb5f0, 0x1e660fcf,
    0x1b890536, 0xd3030564, 0x424043c9, 0x3101d300, 0xd0030d64, 0x0af61c66,
    0x1be4d007, 0x007f2000, 0x07891c79, 0x3c801289, 0x0d1d0324, 0x1e6e0fdf,
    0x1b9b0536, 0xd303056d, 0x425243db, 0x3301d300, 0xd0030d6d, 0x0af61c6e,
    0x1bedd007, 0x007f2200, 0x079b1c7b, 0x3d80129b, 0x1b2f032d, 0xd4581b66,
    0x2e2046a4, 0x3720da46, 0x40bc0014, 0x40bd001d, 0x413340f2, 0x1880432a,
    0x0fcb4159, 0x43c9d005, 0x220043c0, 0x41504264, 0x46624151, 0xd1280d4d,
    0xd1070d0d, 0xd01f2800, 0x41401924, 0x3a014149, 0xd0f90d0d, 0xd3060064,
    0xd3003001, 0x2c003101, 0x0840d101, 0x3a010040, 0x1c94d40b, 0xd1040ae4,
    0x44110512, 0x441907db, 0x07d9bdf0, 0x43194b20, 0x07d9e000, 0xbdf02000,
    0xd1dd2900, 0xd1db2c00, 0x3201bdf0, 0x084007c6, 0x432807cd, 0x2e000849,
    0xe7d9d0e1, 0xda292e3c, 0x37403e20, 0x40bc0014, 0x2401d000, 0x431440f2,
    0x40bb001a, 0x17d3431c, 0x46ace7ac, 0xda082f20, 0x00043620, 0x000d40b4,
    0x40f840b5, 0x43284139, 0x2f3ce7a5, 0x3f20da0c, 0x00043640, 0xd00040b4,
    0x40f82401, 0x00084304, 0x430c40b1, 0xe7ea17c1, 0x00190010, 0xe7942400,
    0x7ff00000, 0x0d0cb5f0, 0x05361e66, 0x0ae61b89, 0x0d640564, 0x1c65d002,
    0xd0040aed, 0x21012000, 0x3c800509, 0x46a40324, 0x1e670d1c, 0x1bdb053f,
    0x05640ae7, 0xd0020d64, 0x0aed1c65, 0x2200d004, 0x051b2301, 0x03243c80,
    0x44644077, 0xb284b497, 0x4374b296, 0x437e0c07, 0x436f0c15, 0x4368b280,
    0xd3021836, 0x04002001, 0x0430183f, 0x19000c35, 0x4684417d, 0xb29ab288,
    0x0c0c4350, 0x0c1f4362, 0xb28e437c, 0x1992437e, 0x2601d302, 0x19a40436,
    0x0c170416, 0x41671836, 0xb281bc01, 0x4351b29a, 0x43620c04, 0x435c0c1b,
    0x4358b280, 0xd3021812, 0x04002001, 0x04101824, 0x18400c13, 0x182d4163,
    0x2000415e, 0xbc064147, 0xb293b288, 0x0c0c4358, 0x0c124363, 0xb2894354,
    0x185b4351, 0x2101d302, 0x18640409, 0x0c1a0419, 0x41621809, 0x4156186d,
    0x41472000, 0x02f9bc18, 0x43110d72, 0x0d6a02f0, 0x02ed4310, 0xd1030d0a,
    0x4140196d, 0x3b014149, 0x1b9b4e12, 0x42b30076, 0x006dd20e, 0x3001d307,
    0x41712600, 0x43354666, 0x0840d101, 0x051b0040, 0x07e418c9, 0xbdf04421,
    0x3301da0b, 0x3001d106, 0x3101d104, 0xd0010d4f, 0xe7f20849, 0x200007e1,
    0x3601bdf0, 0x20000531, 0x0000e7eb, 0x000003ff, 0x0d1cb5f0, 0x053f1e67,
    0x0ae71bdb, 0x0d640564, 0x1c66d002, 0xd0040af6, 0x23012200, 0x3c80051b,
    0x25d00324, 0x2600062d, 0x662e43f6, 0x666e091e, 0x19f60fce, 0x004946b4,
    0xd0020d4f, 0x0af61c7e, 0x2000d003, 0x3f402100, 0x1b3e033f, 0x44b400b6,
    0x057f3f01, 0x08491bc9, 0x36016f2e, 0x029c0876, 0x43250d95, 0x13ed4375,
    0x13ad4375, 0x106d3501, 0x1b7603f6, 0x02ccb40c, 0x432c0d45, 0xb2b3b2a2,
    0x0c27435a, 0x0c35437b, 0xb2a4436f, 0x191b436c, 0x2401d302, 0x193f0424,
    0x0c1d041c, 0x417d18a4, 0x416d1924, 0xb2919a00, 0x4361b2ac, 0x437c0c17,
    0x435f0c2b, 0x435ab292, 0xd30218a4, 0x04122201, 0x042218bf, 0x18520c23,
    0x9c01417b, 0x191b436c, 0x01d90e52, 0x0144430a, 0xb2811aa0, 0x4351b2b2,
    0x435a1403, 0x43730c36, 0x4377b287, 0x19d217d6, 0x417e2700, 0x199b0436,
    0x0c160417, 0x415e187f, 0x18ed1673, 0x260001f3, 0x41753380, 0xd1060fa9,
    0x0a690064, 0x0a5b05e8, 0xd2094318, 0x2204e02f, 0x33804494, 0x0aa94175,
    0x0a9b05a8, 0xd3264318, 0x41494140, 0x9a000424, 0x000d9b01, 0x1b644355,
    0x1ae44343, 0xb286b295, 0x0c174375, 0x0c03437e, 0xb292435f, 0x18b6435a,
    0x2201d302, 0x18bf0412, 0x0c330432, 0x417b1952, 0x419c4252, 0xd4022c00,
    0x30012200, 0x08404151, 0x431007ca, 0xb0020849, 0x07d74662, 0x4b591092,
    0x4b5918d2, 0xd203429a, 0x18890512, 0xbdf019c9, 0x2a002000, 0x0039dc01,
    0x3301bdf0, 0xe7f50519, 0x2100da07, 0x0fc9e007, 0x0d5207c9, 0x12c9d003,
    0x494ee001, 0x20000509, 0x46c04770, 0xd2f2004a, 0x3a010d52, 0x429a4b48,
    0xb5f0d2ea, 0x1b090514, 0xd3010852, 0x41491800, 0x18d2089b, 0x46940512,
    0x0c4aa441, 0x090b5ca2, 0x43534353, 0x4353131b, 0x0212135b, 0x00131ad2,
    0x0b5b435b, 0x4363084c, 0x435313db, 0x330115db, 0x1ad2105b, 0x1ad20c13,
    0x435b0013, 0x0d840289, 0xb28d4321, 0x4375b29e, 0x437e0c0f, 0x435f0c1b,
    0x435cb28c, 0xd3021936, 0x04242401, 0x0434193f, 0x19640c33, 0x019d417b,
    0x432c0ea4, 0xb2a53420, 0x14244355, 0x0c2d4354, 0x11a41964, 0x1b1203d2,
    0xb28eb295, 0x0c174375, 0x0c0c437e, 0xb2934367, 0x18f64363, 0x2301d302,
    0x18ff041b, 0x0c340433, 0x417c195b, 0x416418db, 0x230018db, 0xb29e4163,
    0xb29d4376, 0x437d0c1f, 0x046c437f, 0x19a40bed, 0x0206417d, 0x1b36088f,
    0x077d41af, 0x416e08f6, 0xb295b2b4, 0x1437436c, 0x0c12437d, 0xb2b64357,
    0x17ea4356, 0x260019ad, 0x04124172, 0x042e18bf, 0x19360c2a, 0x3208417a,
    0xd2191152, 0x059c0a9d, 0x191017d1, 0x44614169, 0x0000bdf0, 0x000003fd,
    0x000007fe, 0x000007ff, 0xd6dfebf8, 0xb8bec5cd, 0xa4a8adb2, 0x95999ca0,
    0x8a8d8f92, 0x81838588, 0x0a5d4152, 0x17d105dc, 0x414d1914, 0x4363002b,
    0x4376b2a6, 0x0c27b2a2, 0x437f437a, 0x0bd20451, 0x417a1989, 0x18d218d2,
    0x42490580, 0xd4024190, 0x34012300, 0x0860415d, 0x07ed0869, 0x44614328,
    0xb5d0bdf0, 0xb5d0e011, 0x004c4fb3, 0xd0010d64, 0xd10242bc, 0x0d092000,
    0x005c0509, 0xd0010d64, 0xd10242bc, 0x0d1b2200, 0x2601051b, 0xd40c404b,
    0xd500404b, 0x42994276, 0x4290d103, 0xd301d803, 0xdc002600, 0x1e304276,
    0x430bbdd0, 0x430318db, 0xd0f54313, 0xdaf62900, 0x4644e7f4, 0x4656464d,
    0xb4f0465f, 0xbcf04770, 0x46a946a0, 0x46bb46b2, 0x46624770, 0x4694ca18,
    0x2a00465a, 0xe004db20, 0xca184662, 0x29004694, 0x18c0da1a, 0x465b4161,
    0x465c413b, 0x465240b4, 0x432240fa, 0x464d4644, 0x416b4162, 0x46994690,
    0x40b3462b, 0x40fc413d, 0x4652431c, 0x41a2465b, 0x469241ab, 0x4770469b,
    0x41a11ac0, 0x413b464b, 0x40b4464c, 0x40fa4642, 0x46544322, 0x4162465d,
    0x4692416b, 0x462b469b, 0x413d40b3, 0x431c40fc, 0x464b4642, 0x41ab41a2,
    0x46994690, 0x20004770, 0x47702100, 0xb5002200, 0xf0003220, 0x0008f82a,
    0x2200bd00, 0x3220b500, 0xf830f000, 0xbd000008, 0xb5002100, 0xf804f000,
    0x2100e01e, 0xd4e615c3, 0x468cb510, 0x004017c3, 0xd00a0e02, 0xd00c2aff,
    0x3a7f1e51, 0x1a400609, 0x1ac04058, 0x07001101, 0x2000e01f, 0x00030001,
    0x43d8bd10, 0xbd1043d9, 0xb5002200, 0xf80cf000, 0x429a17ca, 0xbd00d100,
    0x210143d8, 0x404107c9, 0x2200bd00, 0xd4be150b, 0x4694b510, 0xf8b8f000,
    0x34011414, 0x2100da00, 0x446217cb, 0xd40c3a34, 0xda072a0c, 0x40910004,
    0x42524090, 0x40d43220, 0xbd104321, 0x43d943d8, 0x3220bd10, 0x460cd407,
    0x42524094, 0x41113220, 0x432040d0, 0x0008bd10, 0x322017c9, 0x4252d403,
    0x41103220, 0x0018bd10, 0xbd100019, 0x07db0fc3, 0x0e0a0041, 0x2affd007,
    0x0909d008, 0x18894a3d, 0x07404319, 0x00194770, 0x47702000, 0x18c9493a,
    0x004ae7fa, 0x4b390d52, 0xdd131ad2, 0xda1e2aff, 0x0fcb05d2, 0x431a07db,
    0x0f4000c3, 0x0a490309, 0x43104308, 0xd301005b, 0x3001d001, 0x08434770,
    0x4770d2fb, 0x0fc8d002, 0x477007c0, 0x1312030a, 0xd1f83201, 0x2a070f42,
    0x2201d1f5, 0x22ffe000, 0x02000fc8, 0x05c01880, 0x21004770, 0x2100000a,
    0x2100e004, 0x17c1000a, 0x2200e003, 0xe0052300, 0x17cb2200, 0x40594058,
    0x41991ac0, 0x4c1cb530, 0x29001aa2, 0x0001d103, 0x2000d010, 0x154c3a20,
    0xd204d112, 0x18003a01, 0x0d4c4149, 0x4c15d3fa, 0xd20442a2, 0x18890512,
    0x18c907db, 0x43d2bd30, 0x20000d52, 0xe7f52100, 0x3a01d403, 0x41491800,
    0x320bd5fb, 0x0ac00544, 0x4328054d, 0x00640ac9, 0x2400d003, 0x41614160,
    0xd3e0e7e1, 0xe7f80844, 0x000007ff, 0x38000000, 0x7ff00000, 0x00000380,
    0x00000432, 0x000007fe, 0x0fcc0d0a, 0x051b1e53, 0x05521ac9, 0x43c9d303,
    0xd3004240, 0x0d523101, 0x1c53d003, 0xd0070adb, 0x20001b12, 0x1c610064,
    0x12890789, 0x03123a80, 0x1ad24b62, 0x32024770, 0x2a0cd425, 0x2511da1c,
    0x000b1aad, 0x3208412b, 0x00063507, 0x409040ee, 0x43314091, 0x4363ccf0,
    0x2300151a, 0x4355415a, 0x43574356, 0x12f402bf, 0x19760576, 0x17ed4167,
    0x1b80197f, 0x477041b9, 0x2000220c, 0x004917c9, 0x05093101, 0x0209e7db,
    0x43190e03, 0x42530200, 0xd4083220, 0x4119000c, 0x40d84094, 0x22004320,
    0x41514150, 0x00084770, 0x3b2017c9, 0xd5f13220, 0x21002000, 0x47702200,
    0xf7ffb5f0, 0xf000fe56, 0x4684f81d, 0xf83ef000, 0x4660b403, 0xf858f000,
    0xf7ffbc0c, 0xe474fe50, 0xf7ffb5f0, 0xf000fe46, 0xf000f80d, 0xe006f82f,
    0xf7ffb5f0, 0xf000fe3e, 0xf000f805, 0xf7fff845, 0xbdf0fe3e, 0xf7ffb500,
    0xa431ff7f, 0xff97f7ff, 0x4d2d2400, 0x07d24e2d, 0x43f6d302, 0x4166426d,
    0xd2040052, 0x46a346a2, 0x46b146a8, 0x46a0e003, 0x46aa46a1, 0xa46f46b3,
    0x270146a4, 0xf7ff261f, 0x3701fe2b, 0x2f213e01, 0xbd00d1f9, 0xb2844659,
    0x436cb28d, 0x43751406, 0x435e140b, 0x435ab282, 0x17ea18ad, 0x43d2d700,
    0x18b60412, 0x0c2b042a, 0x41731912, 0x46494640, 0x179b009d, 0x432a0f92,
    0x41994190, 0xe6fc223e, 0xb2844649, 0x436cb28d, 0x43751406, 0x435e140b,
    0x435ab282, 0x17ea18ad, 0x43d2d700, 0x18b60412, 0x0c2b042a, 0x41731912,
    0x46594650, 0x179b009d, 0x432a0f92, 0x41594150, 0xe6de223e, 0x000003ff,
    0x9df04dbb, 0x36f656c5, 0x0000517d, 0x0014611a, 0x000a8885, 0x001921fb,
    0xf7ffb5f0, 0x4d40fdc6, 0x402c000c, 0x42acd001, 0x0d09d102, 0x20000509,
    0x402c001c, 0x42acd001, 0x0d1bd102, 0x2200051b, 0x02ed2600, 0xd5042b00,
    0x406b2602, 0xd4004069, 0x194f4276, 0x4299d504, 0x3601dd0c, 0xe0034069,
    0xda0742bb, 0x406b3e01, 0x00100007, 0x000f003a, 0x003b0019, 0x2a00b440,
    0x2b00d10f, 0x005cd00a, 0x34011564, 0x004cd109, 0x34011564, 0x3901d102,
    0xe0023b01, 0x21002000, 0xf7ffe02e, 0x223efbb1, 0xfe03f7ff, 0x468b4682,
    0x21002000, 0x22014680, 0x46910792, 0x46a4a41d, 0x261f2701, 0xfd81f7ff,
    0x3e013701, 0xd1f92f21, 0x4653464a, 0x24013a0c, 0x27000764, 0x001b0852,
    0x4193d405, 0x41791900, 0xd1f70864, 0x4153e004, 0x41b91b00, 0xd1f10864,
    0x104907ce, 0x43300840, 0x2e00bc40, 0x4c09d00a, 0xd5014d09, 0x43ed43e4,
    0xd10107f6, 0x41691900, 0x41691900, 0xf7ff223d, 0xf7fffe50, 0xbdf0fd4c,
    0x7ff00000, 0x885a308d, 0x3243f6a8, 0x61bb4f69, 0x1dac6705, 0x96406eb1,
    0x0fadbafc, 0xab0bdb72, 0x07f56ea6, 0xe59fbd39, 0x03feab76, 0xba97624b,
    0x01ffd55b, 0xdddb94d6, 0x00fffaaa, 0x56eeea5d, 0x007fff55, 0xaab7776e,
    0x003fffea, 0x5555bbbc, 0x001ffffd, 0xaaaaadde, 0x000fffff, 0xf555556f,
    0x0007ffff, 0xfeaaaaab, 0x0003ffff, 0xffd55555, 0x0001ffff, 0xfffaaaab,
    0x0000ffff, 0xffff5555, 0x00007fff, 0xffffeaab, 0x00003fff, 0xfffffd55,
    0x00001fff, 0xffffffab, 0x00000fff, 0xfffffff5, 0x000007ff, 0xffffffff,
    0x000003ff, 0x00000000, 0x00000200, 0x00000000, 0x00000100, 0x00000000,
    0x00000080, 0x00000000, 0x00000040, 0x00000000, 0x00000020, 0x00000000,
    0x00000010, 0x00000000, 0x00000008, 0x00000000, 0x00000004, 0x00000000,
    0x00000002, 0x00000000, 0x00000001, 0x80000000, 0x00000000, 0x40000000,
    0x00000000, 0xf7ffb5f0, 0xa454fe07, 0xfe1ff7ff, 0xda042900, 0x4d214c20,
    0x41691900, 0xb4043a01, 0xa6522701, 0x23012200, 0xce30079b, 0x1b0046b4,
    0xd40b41a9, 0x3620427e, 0x413d001d, 0x40b4001c, 0x40fe0016, 0x41624334,
    0xe001416b, 0x41691900, 0x37014666, 0xd1e82f21, 0xb29eb285, 0x14074375,
    0x0c19437e, 0xb284434f, 0x17f1434c, 0x24001936, 0x04094161, 0x0434187f,
    0x19640c31, 0x0fa44179, 0x43200088, 0x18801789, 0xbc044159, 0x323e4252,
    0xfd7ff7ff, 0x0000bdf0, 0xf473de6b, 0x2c5c85fd, 0x004fb5f0, 0x157fd250,
    0x3701d04e, 0xf7ffd04f, 0xb404fdb3, 0x0dc20249, 0x02404311, 0xa62b2701,
    0x220046b4, 0x427e2300, 0x000d3620, 0x000c413d, 0x000640b4, 0x433440fe,
    0x414d4144, 0xd1050fae, 0x00290020, 0xce304666, 0x41ab1b12, 0x44a42408,
    0x2f213701, 0x0089d1e7, 0x18121089, 0xbc80414b, 0xcc13a417, 0x43783701,
    0x437c4379, 0x12c9054f, 0x19c017cd, 0x02a74169, 0x17cd15a4, 0x416c19c9,
    0x188017dd, 0x416c4159, 0x17cd223e, 0xd00842ac, 0x070e0900, 0x09094330,
    0x43310726, 0x3a041124, 0xf7ffe7f3, 0xbdf0fd26, 0x20004902, 0x4902bdf0,
    0xbdf02000, 0xfff00000, 0x7ff00000, 0x0000b8aa, 0x0013de6b, 0x000fefa3,
    0x000b1721, 0xbf984bf3, 0x19f323ec, 0xcd4d10d6, 0x0e47fbe3, 0x8abcb97a,
    0x0789c1db, 0x022c54cc, 0x03e14618, 0xe7833005, 0x01f829b0, 0x87e01f1e,
    0x00fe0545, 0xac419e24, 0x007f80a9, 0x45621781, 0x003fe015, 0xa9ab10e6,
    0x001ff802, 0x55455888, 0x000ffe00, 0x0aa9aac4, 0x0007ff80, 0x01554556,
    0x0003ffe0, 0x002aa9ab, 0x0001fff8, 0x00055545, 0x0000fffe, 0x8000aaaa,
    0x00007fff, 0xe0001555, 0x00003fff, 0xf80002ab, 0x00001fff, 0xfe000055,
    0x00000fff, 0xff80000b, 0x000007ff, 0xffe00001, 0x000003ff, 0xfff80000,
    0x000001ff, 0xfffe0000, 0x000000ff, 0xffff8000, 0x0000007f, 0xffffe000,
    0x0000003f, 0xfffff800, 0x0000001f, 0xfffffe00, 0x0000000f, 0xffffff80,
    0x00000007, 0xffffffe0, 0x00000003, 0xfffffff8, 0x00000001, 0xfffffffe,
    0x00000000, 0x80000000, 0x00000000, 0x40000000, 0x00000000, 0x45444e49,
    0x20202058, 0x004d5448, 0x4f464e49, 0x3246555f, 0x00545854, 0x70736152,
    0x72726562, 0x69502079, 0x32505200, 0x6f6f4220, 0x01060074, 0x50100dc0,
    0x50100dec, 0x0000044d, 0x0000000a, 0xbe000104, 0x0000004f, 0x0000000c,
    0x0000000e, 0x00000001, 0x0003ffff, 0x00ffff03, 0x00000200, 0x00000000,
    0x02ffff03, 0x08000200, 0x37020900, 0x00010200, 0x0409fa80, 0x08020000,
    0x07005006, 0x40028105, 0x05070000, 0x00400202, 0x01040900, 0x00ff0200,
    0x05070000, 0x00400203, 0x84050700, 0x00004002, 0x01100112, 0x40000000,
    0x00032e8a, 0x02010100, 0xbe000103, 0x50100e18, 0x50100e50, 0x4d903ceb,
    0x4e495753, 0x00312e34, 0x00010802, 0x00020002, 0x0081f800, 0x00010001,
    0x00000001, 0x0003ffff, 0x00290000, 0x52000000, 0x522d4950, 0x20203250,
    0x41462020, 0x20363154, 0xfeeb2020, 0x01000000, 0x000c1000, 0x02000800,
    0x08048008, 0x00000880, 0x20000001, 0x04400004, 0xbe008000, 0x0000001c,
    0x00002355, 0x000024c9, 0x0000188d, 0x00000aa9, 0x000018c5, 0x000017fd,
    0x00003dc4, 0x00003dd1, 0x50100eb5, 0x20324655, 0x746f6f42, 0x64616f6c,
    0x76207265, 0x0a302e32, 0x65646f4d, 0x52203a6c, 0x62707361, 0x79727265,
    0x20695020, 0x0a325052, 0x72616f42, 0x44492d64, 0x5052203a, 0x50522d49,
    0x03040a32, 0xbe000409, 0x50100e58, 0x50100e24, 0x02020000, 0x00000020,
    0x20495052, 0x505201fc, 0x2008fb32, 0xfd3206f9, 0x3c010216, 0x6c6d7468,
    0x65683c3e, 0x3c3e6461, 0x6174656d, 0x74746820, 0x71652d70, 0x3d766975,
    0x66657222, 0x68736572, 0x6f632022, 0x6e65746e, 0x30223d74, 0x4c52553b,
    0x25fc273d, 0x2f2f3a73, 0x70736172, 0x72726562, 0x2e697079, 0x2f6d6f63,
    0x69766564, 0x522f6563, 0x763f3250, 0x69737265, 0x613d6e6f, 0x63626261,
    0x65646463, 0x27666665, 0x3c3e2f22, 0x626dfa2f, 0x3e79646f, 0x69646552,
    0x74636572, 0x20676e69, 0x3c206f74, 0x65727ffd, 0x3e60c666, 0x2f3c91f1,
    0x6271fd61, 0x2f3c6bfc, 0xbe00ebfb, 0xbe00be00
]);


/***/ }),

/***/ 7952:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.runMCU = void 0;
const rp2040js_1 = __nccwpck_require__(8904);
const bootrom_1 = __nccwpck_require__(4013);
const memory_1 = __nccwpck_require__(596);
const core = __importStar(__nccwpck_require__(2186));
function runMCU(uf2_filepath, fs_filepath = null) {
    // Create the MCU
    const mcu = new rp2040js_1.RP2040();
    mcu.logger = new rp2040js_1.ConsoleLogger(rp2040js_1.LogLevel.Error);
    // Load the bootrom
    mcu.loadBootrom(bootrom_1.bootrom);
    // Load the UF2 firmware
    (0, memory_1.loadUF2)(uf2_filepath, mcu);
    // Load the filesystem, if needed
    if (fs_filepath != null) {
        (0, memory_1.loadFlash)(fs_filepath, mcu);
    }
    let dataReceived = '';
    let currentLine = '';
    // Create a USB CDC
    const cdc = new rp2040js_1.USBCDC(mcu.usbCtrl);
    // Notify when USB CDC is connected
    cdc.onDeviceConnected = function () {
        // ----------------------------------
        // [Insert post-connection code here]
        // ----------------------------------
    };
    // Handle receiving serial data
    cdc.onSerialData = function (buffer) {
        for (const byte of buffer) {
            const char = String.fromCharCode(byte);
            if (char === '\r' || char === '\n') {
                if (currentLine === '[RP2040JS: END]') {
                    // TODO: Change this depending on the use case
                    const printout = dataReceived.split('\r\n')[1].trim();
                    core.setOutput('result', printout);
                    process.exit(0);
                }
                currentLine = '';
            }
            else {
                currentLine += char;
            }
            dataReceived += char;
        }
        // ----------------------------------
        // [Insert serial data code here]
        // ----------------------------------
    };
    // Move the program counter and execute
    mcu.core.PC = 0x10000000;
    mcu.execute();
}
exports.runMCU = runMCU;


/***/ }),

/***/ 3109:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const core = __importStar(__nccwpck_require__(2186));
const execution_1 = __nccwpck_require__(7952);
const fs = __importStar(__nccwpck_require__(7147));
function run() {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const uf2 = core.getInput('firmware');
            const fs_arg = core.getInput('filesystem');
            if (!fs.existsSync(uf2)) {
                core.setFailed('UF2 file provided does not exist.');
            }
            if (fs_arg !== '' && !fs.existsSync(fs_arg)) {
                core.setFailed('Filesystem image provided does not exist.');
            }
            const filesystem = fs_arg === '' ? null : fs_arg;
            (0, execution_1.runMCU)(uf2, filesystem);
        }
        catch (error) {
            if (error instanceof Error)
                core.setFailed(error.message);
        }
    });
}
run();


/***/ }),

/***/ 596:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.loadFlash = exports.loadUF2 = void 0;
const fs = __importStar(__nccwpck_require__(7147));
const uf2_1 = __nccwpck_require__(6795);
const FLASH_START_ADDRESS = 0x10000000;
const FLASH_START = 0x100000;
const UF2_BLOCKSIZE = 512;
function loadUF2(filepath, mcu) {
    const fileSize = fs.statSync(filepath).size;
    const fd = fs.openSync(filepath, 'r');
    const buffer = new Uint8Array(UF2_BLOCKSIZE);
    let bytesWritten = 0;
    while (bytesWritten < fileSize) {
        const bytesRead = fs.readSync(fd, buffer, { length: UF2_BLOCKSIZE });
        const { flashAddress, payload } = (0, uf2_1.decodeBlock)(buffer);
        const blockFlashAddress = flashAddress - FLASH_START_ADDRESS;
        mcu.flash.set(payload, blockFlashAddress);
        bytesWritten += bytesRead;
    }
    fs.closeSync(fd);
}
exports.loadUF2 = loadUF2;
function loadFlash(filepath, mcu) {
    const buffer = fs.readFileSync(filepath, { flag: 'r' });
    mcu.flash.set(buffer, FLASH_START);
}
exports.loadFlash = loadFlash;


/***/ }),

/***/ 7351:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.issue = exports.issueCommand = void 0;
const os = __importStar(__nccwpck_require__(2037));
const utils_1 = __nccwpck_require__(5278);
/**
 * Commands
 *
 * Command Format:
 *   ::name key=value,key=value::message
 *
 * Examples:
 *   ::warning::This is the message
 *   ::set-env name=MY_VAR::some value
 */
function issueCommand(command, properties, message) {
    const cmd = new Command(command, properties, message);
    process.stdout.write(cmd.toString() + os.EOL);
}
exports.issueCommand = issueCommand;
function issue(name, message = '') {
    issueCommand(name, {}, message);
}
exports.issue = issue;
const CMD_STRING = '::';
class Command {
    constructor(command, properties, message) {
        if (!command) {
            command = 'missing.command';
        }
        this.command = command;
        this.properties = properties;
        this.message = message;
    }
    toString() {
        let cmdStr = CMD_STRING + this.command;
        if (this.properties && Object.keys(this.properties).length > 0) {
            cmdStr += ' ';
            let first = true;
            for (const key in this.properties) {
                if (this.properties.hasOwnProperty(key)) {
                    const val = this.properties[key];
                    if (val) {
                        if (first) {
                            first = false;
                        }
                        else {
                            cmdStr += ',';
                        }
                        cmdStr += `${key}=${escapeProperty(val)}`;
                    }
                }
            }
        }
        cmdStr += `${CMD_STRING}${escapeData(this.message)}`;
        return cmdStr;
    }
}
function escapeData(s) {
    return utils_1.toCommandValue(s)
        .replace(/%/g, '%25')
        .replace(/\r/g, '%0D')
        .replace(/\n/g, '%0A');
}
function escapeProperty(s) {
    return utils_1.toCommandValue(s)
        .replace(/%/g, '%25')
        .replace(/\r/g, '%0D')
        .replace(/\n/g, '%0A')
        .replace(/:/g, '%3A')
        .replace(/,/g, '%2C');
}
//# sourceMappingURL=command.js.map

/***/ }),

/***/ 2186:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getIDToken = exports.getState = exports.saveState = exports.group = exports.endGroup = exports.startGroup = exports.info = exports.notice = exports.warning = exports.error = exports.debug = exports.isDebug = exports.setFailed = exports.setCommandEcho = exports.setOutput = exports.getBooleanInput = exports.getMultilineInput = exports.getInput = exports.addPath = exports.setSecret = exports.exportVariable = exports.ExitCode = void 0;
const command_1 = __nccwpck_require__(7351);
const file_command_1 = __nccwpck_require__(717);
const utils_1 = __nccwpck_require__(5278);
const os = __importStar(__nccwpck_require__(2037));
const path = __importStar(__nccwpck_require__(1017));
const oidc_utils_1 = __nccwpck_require__(8041);
/**
 * The code to exit an action
 */
var ExitCode;
(function (ExitCode) {
    /**
     * A code indicating that the action was successful
     */
    ExitCode[ExitCode["Success"] = 0] = "Success";
    /**
     * A code indicating that the action was a failure
     */
    ExitCode[ExitCode["Failure"] = 1] = "Failure";
})(ExitCode = exports.ExitCode || (exports.ExitCode = {}));
//-----------------------------------------------------------------------
// Variables
//-----------------------------------------------------------------------
/**
 * Sets env variable for this action and future actions in the job
 * @param name the name of the variable to set
 * @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function exportVariable(name, val) {
    const convertedVal = utils_1.toCommandValue(val);
    process.env[name] = convertedVal;
    const filePath = process.env['GITHUB_ENV'] || '';
    if (filePath) {
        return file_command_1.issueFileCommand('ENV', file_command_1.prepareKeyValueMessage(name, val));
    }
    command_1.issueCommand('set-env', { name }, convertedVal);
}
exports.exportVariable = exportVariable;
/**
 * Registers a secret which will get masked from logs
 * @param secret value of the secret
 */
function setSecret(secret) {
    command_1.issueCommand('add-mask', {}, secret);
}
exports.setSecret = setSecret;
/**
 * Prepends inputPath to the PATH (for this action and future actions)
 * @param inputPath
 */
function addPath(inputPath) {
    const filePath = process.env['GITHUB_PATH'] || '';
    if (filePath) {
        file_command_1.issueFileCommand('PATH', inputPath);
    }
    else {
        command_1.issueCommand('add-path', {}, inputPath);
    }
    process.env['PATH'] = `${inputPath}${path.delimiter}${process.env['PATH']}`;
}
exports.addPath = addPath;
/**
 * Gets the value of an input.
 * Unless trimWhitespace is set to false in InputOptions, the value is also trimmed.
 * Returns an empty string if the value is not defined.
 *
 * @param     name     name of the input to get
 * @param     options  optional. See InputOptions.
 * @returns   string
 */
function getInput(name, options) {
    const val = process.env[`INPUT_${name.replace(/ /g, '_').toUpperCase()}`] || '';
    if (options && options.required && !val) {
        throw new Error(`Input required and not supplied: ${name}`);
    }
    if (options && options.trimWhitespace === false) {
        return val;
    }
    return val.trim();
}
exports.getInput = getInput;
/**
 * Gets the values of an multiline input.  Each value is also trimmed.
 *
 * @param     name     name of the input to get
 * @param     options  optional. See InputOptions.
 * @returns   string[]
 *
 */
function getMultilineInput(name, options) {
    const inputs = getInput(name, options)
        .split('\n')
        .filter(x => x !== '');
    if (options && options.trimWhitespace === false) {
        return inputs;
    }
    return inputs.map(input => input.trim());
}
exports.getMultilineInput = getMultilineInput;
/**
 * Gets the input value of the boolean type in the YAML 1.2 "core schema" specification.
 * Support boolean input list: `true | True | TRUE | false | False | FALSE` .
 * The return value is also in boolean type.
 * ref: https://yaml.org/spec/1.2/spec.html#id2804923
 *
 * @param     name     name of the input to get
 * @param     options  optional. See InputOptions.
 * @returns   boolean
 */
function getBooleanInput(name, options) {
    const trueValue = ['true', 'True', 'TRUE'];
    const falseValue = ['false', 'False', 'FALSE'];
    const val = getInput(name, options);
    if (trueValue.includes(val))
        return true;
    if (falseValue.includes(val))
        return false;
    throw new TypeError(`Input does not meet YAML 1.2 "Core Schema" specification: ${name}\n` +
        `Support boolean input list: \`true | True | TRUE | false | False | FALSE\``);
}
exports.getBooleanInput = getBooleanInput;
/**
 * Sets the value of an output.
 *
 * @param     name     name of the output to set
 * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function setOutput(name, value) {
    const filePath = process.env['GITHUB_OUTPUT'] || '';
    if (filePath) {
        return file_command_1.issueFileCommand('OUTPUT', file_command_1.prepareKeyValueMessage(name, value));
    }
    process.stdout.write(os.EOL);
    command_1.issueCommand('set-output', { name }, utils_1.toCommandValue(value));
}
exports.setOutput = setOutput;
/**
 * Enables or disables the echoing of commands into stdout for the rest of the step.
 * Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.
 *
 */
function setCommandEcho(enabled) {
    command_1.issue('echo', enabled ? 'on' : 'off');
}
exports.setCommandEcho = setCommandEcho;
//-----------------------------------------------------------------------
// Results
//-----------------------------------------------------------------------
/**
 * Sets the action status to failed.
 * When the action exits it will be with an exit code of 1
 * @param message add error issue message
 */
function setFailed(message) {
    process.exitCode = ExitCode.Failure;
    error(message);
}
exports.setFailed = setFailed;
//-----------------------------------------------------------------------
// Logging Commands
//-----------------------------------------------------------------------
/**
 * Gets whether Actions Step Debug is on or not
 */
function isDebug() {
    return process.env['RUNNER_DEBUG'] === '1';
}
exports.isDebug = isDebug;
/**
 * Writes debug message to user log
 * @param message debug message
 */
function debug(message) {
    command_1.issueCommand('debug', {}, message);
}
exports.debug = debug;
/**
 * Adds an error issue
 * @param message error issue message. Errors will be converted to string via toString()
 * @param properties optional properties to add to the annotation.
 */
function error(message, properties = {}) {
    command_1.issueCommand('error', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
}
exports.error = error;
/**
 * Adds a warning issue
 * @param message warning issue message. Errors will be converted to string via toString()
 * @param properties optional properties to add to the annotation.
 */
function warning(message, properties = {}) {
    command_1.issueCommand('warning', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
}
exports.warning = warning;
/**
 * Adds a notice issue
 * @param message notice issue message. Errors will be converted to string via toString()
 * @param properties optional properties to add to the annotation.
 */
function notice(message, properties = {}) {
    command_1.issueCommand('notice', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
}
exports.notice = notice;
/**
 * Writes info to log with console.log.
 * @param message info message
 */
function info(message) {
    process.stdout.write(message + os.EOL);
}
exports.info = info;
/**
 * Begin an output group.
 *
 * Output until the next `groupEnd` will be foldable in this group
 *
 * @param name The name of the output group
 */
function startGroup(name) {
    command_1.issue('group', name);
}
exports.startGroup = startGroup;
/**
 * End an output group.
 */
function endGroup() {
    command_1.issue('endgroup');
}
exports.endGroup = endGroup;
/**
 * Wrap an asynchronous function call in a group.
 *
 * Returns the same type as the function itself.
 *
 * @param name The name of the group
 * @param fn The function to wrap in the group
 */
function group(name, fn) {
    return __awaiter(this, void 0, void 0, function* () {
        startGroup(name);
        let result;
        try {
            result = yield fn();
        }
        finally {
            endGroup();
        }
        return result;
    });
}
exports.group = group;
//-----------------------------------------------------------------------
// Wrapper action state
//-----------------------------------------------------------------------
/**
 * Saves state for current action, the state can only be retrieved by this action's post job execution.
 *
 * @param     name     name of the state to store
 * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function saveState(name, value) {
    const filePath = process.env['GITHUB_STATE'] || '';
    if (filePath) {
        return file_command_1.issueFileCommand('STATE', file_command_1.prepareKeyValueMessage(name, value));
    }
    command_1.issueCommand('save-state', { name }, utils_1.toCommandValue(value));
}
exports.saveState = saveState;
/**
 * Gets the value of an state set by this action's main execution.
 *
 * @param     name     name of the state to get
 * @returns   string
 */
function getState(name) {
    return process.env[`STATE_${name}`] || '';
}
exports.getState = getState;
function getIDToken(aud) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield oidc_utils_1.OidcClient.getIDToken(aud);
    });
}
exports.getIDToken = getIDToken;
/**
 * Summary exports
 */
var summary_1 = __nccwpck_require__(1327);
Object.defineProperty(exports, "summary", ({ enumerable: true, get: function () { return summary_1.summary; } }));
/**
 * @deprecated use core.summary
 */
var summary_2 = __nccwpck_require__(1327);
Object.defineProperty(exports, "markdownSummary", ({ enumerable: true, get: function () { return summary_2.markdownSummary; } }));
/**
 * Path exports
 */
var path_utils_1 = __nccwpck_require__(2981);
Object.defineProperty(exports, "toPosixPath", ({ enumerable: true, get: function () { return path_utils_1.toPosixPath; } }));
Object.defineProperty(exports, "toWin32Path", ({ enumerable: true, get: function () { return path_utils_1.toWin32Path; } }));
Object.defineProperty(exports, "toPlatformPath", ({ enumerable: true, get: function () { return path_utils_1.toPlatformPath; } }));
//# sourceMappingURL=core.js.map

/***/ }),

/***/ 717:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

// For internal use, subject to change.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.prepareKeyValueMessage = exports.issueFileCommand = void 0;
// We use any as a valid input type
/* eslint-disable @typescript-eslint/no-explicit-any */
const fs = __importStar(__nccwpck_require__(7147));
const os = __importStar(__nccwpck_require__(2037));
const uuid_1 = __nccwpck_require__(5840);
const utils_1 = __nccwpck_require__(5278);
function issueFileCommand(command, message) {
    const filePath = process.env[`GITHUB_${command}`];
    if (!filePath) {
        throw new Error(`Unable to find environment variable for file command ${command}`);
    }
    if (!fs.existsSync(filePath)) {
        throw new Error(`Missing file at path: ${filePath}`);
    }
    fs.appendFileSync(filePath, `${utils_1.toCommandValue(message)}${os.EOL}`, {
        encoding: 'utf8'
    });
}
exports.issueFileCommand = issueFileCommand;
function prepareKeyValueMessage(key, value) {
    const delimiter = `ghadelimiter_${uuid_1.v4()}`;
    const convertedValue = utils_1.toCommandValue(value);
    // These should realistically never happen, but just in case someone finds a
    // way to exploit uuid generation let's not allow keys or values that contain
    // the delimiter.
    if (key.includes(delimiter)) {
        throw new Error(`Unexpected input: name should not contain the delimiter "${delimiter}"`);
    }
    if (convertedValue.includes(delimiter)) {
        throw new Error(`Unexpected input: value should not contain the delimiter "${delimiter}"`);
    }
    return `${key}<<${delimiter}${os.EOL}${convertedValue}${os.EOL}${delimiter}`;
}
exports.prepareKeyValueMessage = prepareKeyValueMessage;
//# sourceMappingURL=file-command.js.map

/***/ }),

/***/ 8041:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OidcClient = void 0;
const http_client_1 = __nccwpck_require__(6255);
const auth_1 = __nccwpck_require__(5526);
const core_1 = __nccwpck_require__(2186);
class OidcClient {
    static createHttpClient(allowRetry = true, maxRetry = 10) {
        const requestOptions = {
            allowRetries: allowRetry,
            maxRetries: maxRetry
        };
        return new http_client_1.HttpClient('actions/oidc-client', [new auth_1.BearerCredentialHandler(OidcClient.getRequestToken())], requestOptions);
    }
    static getRequestToken() {
        const token = process.env['ACTIONS_ID_TOKEN_REQUEST_TOKEN'];
        if (!token) {
            throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable');
        }
        return token;
    }
    static getIDTokenUrl() {
        const runtimeUrl = process.env['ACTIONS_ID_TOKEN_REQUEST_URL'];
        if (!runtimeUrl) {
            throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable');
        }
        return runtimeUrl;
    }
    static getCall(id_token_url) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const httpclient = OidcClient.createHttpClient();
            const res = yield httpclient
                .getJson(id_token_url)
                .catch(error => {
                throw new Error(`Failed to get ID Token. \n 
        Error Code : ${error.statusCode}\n 
        Error Message: ${error.result.message}`);
            });
            const id_token = (_a = res.result) === null || _a === void 0 ? void 0 : _a.value;
            if (!id_token) {
                throw new Error('Response json body do not have ID Token field');
            }
            return id_token;
        });
    }
    static getIDToken(audience) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // New ID Token is requested from action service
                let id_token_url = OidcClient.getIDTokenUrl();
                if (audience) {
                    const encodedAudience = encodeURIComponent(audience);
                    id_token_url = `${id_token_url}&audience=${encodedAudience}`;
                }
                core_1.debug(`ID token url is ${id_token_url}`);
                const id_token = yield OidcClient.getCall(id_token_url);
                core_1.setSecret(id_token);
                return id_token;
            }
            catch (error) {
                throw new Error(`Error message: ${error.message}`);
            }
        });
    }
}
exports.OidcClient = OidcClient;
//# sourceMappingURL=oidc-utils.js.map

/***/ }),

/***/ 2981:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toPlatformPath = exports.toWin32Path = exports.toPosixPath = void 0;
const path = __importStar(__nccwpck_require__(1017));
/**
 * toPosixPath converts the given path to the posix form. On Windows, \\ will be
 * replaced with /.
 *
 * @param pth. Path to transform.
 * @return string Posix path.
 */
function toPosixPath(pth) {
    return pth.replace(/[\\]/g, '/');
}
exports.toPosixPath = toPosixPath;
/**
 * toWin32Path converts the given path to the win32 form. On Linux, / will be
 * replaced with \\.
 *
 * @param pth. Path to transform.
 * @return string Win32 path.
 */
function toWin32Path(pth) {
    return pth.replace(/[/]/g, '\\');
}
exports.toWin32Path = toWin32Path;
/**
 * toPlatformPath converts the given path to a platform-specific path. It does
 * this by replacing instances of / and \ with the platform-specific path
 * separator.
 *
 * @param pth The path to platformize.
 * @return string The platform-specific path.
 */
function toPlatformPath(pth) {
    return pth.replace(/[/\\]/g, path.sep);
}
exports.toPlatformPath = toPlatformPath;
//# sourceMappingURL=path-utils.js.map

/***/ }),

/***/ 1327:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.summary = exports.markdownSummary = exports.SUMMARY_DOCS_URL = exports.SUMMARY_ENV_VAR = void 0;
const os_1 = __nccwpck_require__(2037);
const fs_1 = __nccwpck_require__(7147);
const { access, appendFile, writeFile } = fs_1.promises;
exports.SUMMARY_ENV_VAR = 'GITHUB_STEP_SUMMARY';
exports.SUMMARY_DOCS_URL = 'https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary';
class Summary {
    constructor() {
        this._buffer = '';
    }
    /**
     * Finds the summary file path from the environment, rejects if env var is not found or file does not exist
     * Also checks r/w permissions.
     *
     * @returns step summary file path
     */
    filePath() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._filePath) {
                return this._filePath;
            }
            const pathFromEnv = process.env[exports.SUMMARY_ENV_VAR];
            if (!pathFromEnv) {
                throw new Error(`Unable to find environment variable for $${exports.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`);
            }
            try {
                yield access(pathFromEnv, fs_1.constants.R_OK | fs_1.constants.W_OK);
            }
            catch (_a) {
                throw new Error(`Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`);
            }
            this._filePath = pathFromEnv;
            return this._filePath;
        });
    }
    /**
     * Wraps content in an HTML tag, adding any HTML attributes
     *
     * @param {string} tag HTML tag to wrap
     * @param {string | null} content content within the tag
     * @param {[attribute: string]: string} attrs key-value list of HTML attributes to add
     *
     * @returns {string} content wrapped in HTML element
     */
    wrap(tag, content, attrs = {}) {
        const htmlAttrs = Object.entries(attrs)
            .map(([key, value]) => ` ${key}="${value}"`)
            .join('');
        if (!content) {
            return `<${tag}${htmlAttrs}>`;
        }
        return `<${tag}${htmlAttrs}>${content}</${tag}>`;
    }
    /**
     * Writes text in the buffer to the summary buffer file and empties buffer. Will append by default.
     *
     * @param {SummaryWriteOptions} [options] (optional) options for write operation
     *
     * @returns {Promise<Summary>} summary instance
     */
    write(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const overwrite = !!(options === null || options === void 0 ? void 0 : options.overwrite);
            const filePath = yield this.filePath();
            const writeFunc = overwrite ? writeFile : appendFile;
            yield writeFunc(filePath, this._buffer, { encoding: 'utf8' });
            return this.emptyBuffer();
        });
    }
    /**
     * Clears the summary buffer and wipes the summary file
     *
     * @returns {Summary} summary instance
     */
    clear() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.emptyBuffer().write({ overwrite: true });
        });
    }
    /**
     * Returns the current summary buffer as a string
     *
     * @returns {string} string of summary buffer
     */
    stringify() {
        return this._buffer;
    }
    /**
     * If the summary buffer is empty
     *
     * @returns {boolen} true if the buffer is empty
     */
    isEmptyBuffer() {
        return this._buffer.length === 0;
    }
    /**
     * Resets the summary buffer without writing to summary file
     *
     * @returns {Summary} summary instance
     */
    emptyBuffer() {
        this._buffer = '';
        return this;
    }
    /**
     * Adds raw text to the summary buffer
     *
     * @param {string} text content to add
     * @param {boolean} [addEOL=false] (optional) append an EOL to the raw text (default: false)
     *
     * @returns {Summary} summary instance
     */
    addRaw(text, addEOL = false) {
        this._buffer += text;
        return addEOL ? this.addEOL() : this;
    }
    /**
     * Adds the operating system-specific end-of-line marker to the buffer
     *
     * @returns {Summary} summary instance
     */
    addEOL() {
        return this.addRaw(os_1.EOL);
    }
    /**
     * Adds an HTML codeblock to the summary buffer
     *
     * @param {string} code content to render within fenced code block
     * @param {string} lang (optional) language to syntax highlight code
     *
     * @returns {Summary} summary instance
     */
    addCodeBlock(code, lang) {
        const attrs = Object.assign({}, (lang && { lang }));
        const element = this.wrap('pre', this.wrap('code', code), attrs);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML list to the summary buffer
     *
     * @param {string[]} items list of items to render
     * @param {boolean} [ordered=false] (optional) if the rendered list should be ordered or not (default: false)
     *
     * @returns {Summary} summary instance
     */
    addList(items, ordered = false) {
        const tag = ordered ? 'ol' : 'ul';
        const listItems = items.map(item => this.wrap('li', item)).join('');
        const element = this.wrap(tag, listItems);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML table to the summary buffer
     *
     * @param {SummaryTableCell[]} rows table rows
     *
     * @returns {Summary} summary instance
     */
    addTable(rows) {
        const tableBody = rows
            .map(row => {
            const cells = row
                .map(cell => {
                if (typeof cell === 'string') {
                    return this.wrap('td', cell);
                }
                const { header, data, colspan, rowspan } = cell;
                const tag = header ? 'th' : 'td';
                const attrs = Object.assign(Object.assign({}, (colspan && { colspan })), (rowspan && { rowspan }));
                return this.wrap(tag, data, attrs);
            })
                .join('');
            return this.wrap('tr', cells);
        })
            .join('');
        const element = this.wrap('table', tableBody);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds a collapsable HTML details element to the summary buffer
     *
     * @param {string} label text for the closed state
     * @param {string} content collapsable content
     *
     * @returns {Summary} summary instance
     */
    addDetails(label, content) {
        const element = this.wrap('details', this.wrap('summary', label) + content);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML image tag to the summary buffer
     *
     * @param {string} src path to the image you to embed
     * @param {string} alt text description of the image
     * @param {SummaryImageOptions} options (optional) addition image attributes
     *
     * @returns {Summary} summary instance
     */
    addImage(src, alt, options) {
        const { width, height } = options || {};
        const attrs = Object.assign(Object.assign({}, (width && { width })), (height && { height }));
        const element = this.wrap('img', null, Object.assign({ src, alt }, attrs));
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML section heading element
     *
     * @param {string} text heading text
     * @param {number | string} [level=1] (optional) the heading level, default: 1
     *
     * @returns {Summary} summary instance
     */
    addHeading(text, level) {
        const tag = `h${level}`;
        const allowedTag = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(tag)
            ? tag
            : 'h1';
        const element = this.wrap(allowedTag, text);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML thematic break (<hr>) to the summary buffer
     *
     * @returns {Summary} summary instance
     */
    addSeparator() {
        const element = this.wrap('hr', null);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML line break (<br>) to the summary buffer
     *
     * @returns {Summary} summary instance
     */
    addBreak() {
        const element = this.wrap('br', null);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML blockquote to the summary buffer
     *
     * @param {string} text quote text
     * @param {string} cite (optional) citation url
     *
     * @returns {Summary} summary instance
     */
    addQuote(text, cite) {
        const attrs = Object.assign({}, (cite && { cite }));
        const element = this.wrap('blockquote', text, attrs);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML anchor tag to the summary buffer
     *
     * @param {string} text link text/content
     * @param {string} href hyperlink
     *
     * @returns {Summary} summary instance
     */
    addLink(text, href) {
        const element = this.wrap('a', text, { href });
        return this.addRaw(element).addEOL();
    }
}
const _summary = new Summary();
/**
 * @deprecated use `core.summary`
 */
exports.markdownSummary = _summary;
exports.summary = _summary;
//# sourceMappingURL=summary.js.map

/***/ }),

/***/ 5278:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// We use any as a valid input type
/* eslint-disable @typescript-eslint/no-explicit-any */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toCommandProperties = exports.toCommandValue = void 0;
/**
 * Sanitizes an input into a string so it can be passed into issueCommand safely
 * @param input input to sanitize into a string
 */
function toCommandValue(input) {
    if (input === null || input === undefined) {
        return '';
    }
    else if (typeof input === 'string' || input instanceof String) {
        return input;
    }
    return JSON.stringify(input);
}
exports.toCommandValue = toCommandValue;
/**
 *
 * @param annotationProperties
 * @returns The command properties to send with the actual annotation command
 * See IssueCommandProperties: https://github.com/actions/runner/blob/main/src/Runner.Worker/ActionCommandManager.cs#L646
 */
function toCommandProperties(annotationProperties) {
    if (!Object.keys(annotationProperties).length) {
        return {};
    }
    return {
        title: annotationProperties.title,
        file: annotationProperties.file,
        line: annotationProperties.startLine,
        endLine: annotationProperties.endLine,
        col: annotationProperties.startColumn,
        endColumn: annotationProperties.endColumn
    };
}
exports.toCommandProperties = toCommandProperties;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 5526:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PersonalAccessTokenCredentialHandler = exports.BearerCredentialHandler = exports.BasicCredentialHandler = void 0;
class BasicCredentialHandler {
    constructor(username, password) {
        this.username = username;
        this.password = password;
    }
    prepareRequest(options) {
        if (!options.headers) {
            throw Error('The request has no headers');
        }
        options.headers['Authorization'] = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString('base64')}`;
    }
    // This handler cannot handle 401
    canHandleAuthentication() {
        return false;
    }
    handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('not implemented');
        });
    }
}
exports.BasicCredentialHandler = BasicCredentialHandler;
class BearerCredentialHandler {
    constructor(token) {
        this.token = token;
    }
    // currently implements pre-authorization
    // TODO: support preAuth = false where it hooks on 401
    prepareRequest(options) {
        if (!options.headers) {
            throw Error('The request has no headers');
        }
        options.headers['Authorization'] = `Bearer ${this.token}`;
    }
    // This handler cannot handle 401
    canHandleAuthentication() {
        return false;
    }
    handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('not implemented');
        });
    }
}
exports.BearerCredentialHandler = BearerCredentialHandler;
class PersonalAccessTokenCredentialHandler {
    constructor(token) {
        this.token = token;
    }
    // currently implements pre-authorization
    // TODO: support preAuth = false where it hooks on 401
    prepareRequest(options) {
        if (!options.headers) {
            throw Error('The request has no headers');
        }
        options.headers['Authorization'] = `Basic ${Buffer.from(`PAT:${this.token}`).toString('base64')}`;
    }
    // This handler cannot handle 401
    canHandleAuthentication() {
        return false;
    }
    handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('not implemented');
        });
    }
}
exports.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;
//# sourceMappingURL=auth.js.map

/***/ }),

/***/ 6255:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/* eslint-disable @typescript-eslint/no-explicit-any */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HttpClient = exports.isHttps = exports.HttpClientResponse = exports.HttpClientError = exports.getProxyUrl = exports.MediaTypes = exports.Headers = exports.HttpCodes = void 0;
const http = __importStar(__nccwpck_require__(3685));
const https = __importStar(__nccwpck_require__(5687));
const pm = __importStar(__nccwpck_require__(9835));
const tunnel = __importStar(__nccwpck_require__(4294));
var HttpCodes;
(function (HttpCodes) {
    HttpCodes[HttpCodes["OK"] = 200] = "OK";
    HttpCodes[HttpCodes["MultipleChoices"] = 300] = "MultipleChoices";
    HttpCodes[HttpCodes["MovedPermanently"] = 301] = "MovedPermanently";
    HttpCodes[HttpCodes["ResourceMoved"] = 302] = "ResourceMoved";
    HttpCodes[HttpCodes["SeeOther"] = 303] = "SeeOther";
    HttpCodes[HttpCodes["NotModified"] = 304] = "NotModified";
    HttpCodes[HttpCodes["UseProxy"] = 305] = "UseProxy";
    HttpCodes[HttpCodes["SwitchProxy"] = 306] = "SwitchProxy";
    HttpCodes[HttpCodes["TemporaryRedirect"] = 307] = "TemporaryRedirect";
    HttpCodes[HttpCodes["PermanentRedirect"] = 308] = "PermanentRedirect";
    HttpCodes[HttpCodes["BadRequest"] = 400] = "BadRequest";
    HttpCodes[HttpCodes["Unauthorized"] = 401] = "Unauthorized";
    HttpCodes[HttpCodes["PaymentRequired"] = 402] = "PaymentRequired";
    HttpCodes[HttpCodes["Forbidden"] = 403] = "Forbidden";
    HttpCodes[HttpCodes["NotFound"] = 404] = "NotFound";
    HttpCodes[HttpCodes["MethodNotAllowed"] = 405] = "MethodNotAllowed";
    HttpCodes[HttpCodes["NotAcceptable"] = 406] = "NotAcceptable";
    HttpCodes[HttpCodes["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
    HttpCodes[HttpCodes["RequestTimeout"] = 408] = "RequestTimeout";
    HttpCodes[HttpCodes["Conflict"] = 409] = "Conflict";
    HttpCodes[HttpCodes["Gone"] = 410] = "Gone";
    HttpCodes[HttpCodes["TooManyRequests"] = 429] = "TooManyRequests";
    HttpCodes[HttpCodes["InternalServerError"] = 500] = "InternalServerError";
    HttpCodes[HttpCodes["NotImplemented"] = 501] = "NotImplemented";
    HttpCodes[HttpCodes["BadGateway"] = 502] = "BadGateway";
    HttpCodes[HttpCodes["ServiceUnavailable"] = 503] = "ServiceUnavailable";
    HttpCodes[HttpCodes["GatewayTimeout"] = 504] = "GatewayTimeout";
})(HttpCodes = exports.HttpCodes || (exports.HttpCodes = {}));
var Headers;
(function (Headers) {
    Headers["Accept"] = "accept";
    Headers["ContentType"] = "content-type";
})(Headers = exports.Headers || (exports.Headers = {}));
var MediaTypes;
(function (MediaTypes) {
    MediaTypes["ApplicationJson"] = "application/json";
})(MediaTypes = exports.MediaTypes || (exports.MediaTypes = {}));
/**
 * Returns the proxy URL, depending upon the supplied url and proxy environment variables.
 * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
 */
function getProxyUrl(serverUrl) {
    const proxyUrl = pm.getProxyUrl(new URL(serverUrl));
    return proxyUrl ? proxyUrl.href : '';
}
exports.getProxyUrl = getProxyUrl;
const HttpRedirectCodes = [
    HttpCodes.MovedPermanently,
    HttpCodes.ResourceMoved,
    HttpCodes.SeeOther,
    HttpCodes.TemporaryRedirect,
    HttpCodes.PermanentRedirect
];
const HttpResponseRetryCodes = [
    HttpCodes.BadGateway,
    HttpCodes.ServiceUnavailable,
    HttpCodes.GatewayTimeout
];
const RetryableHttpVerbs = ['OPTIONS', 'GET', 'DELETE', 'HEAD'];
const ExponentialBackoffCeiling = 10;
const ExponentialBackoffTimeSlice = 5;
class HttpClientError extends Error {
    constructor(message, statusCode) {
        super(message);
        this.name = 'HttpClientError';
        this.statusCode = statusCode;
        Object.setPrototypeOf(this, HttpClientError.prototype);
    }
}
exports.HttpClientError = HttpClientError;
class HttpClientResponse {
    constructor(message) {
        this.message = message;
    }
    readBody() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                let output = Buffer.alloc(0);
                this.message.on('data', (chunk) => {
                    output = Buffer.concat([output, chunk]);
                });
                this.message.on('end', () => {
                    resolve(output.toString());
                });
            }));
        });
    }
}
exports.HttpClientResponse = HttpClientResponse;
function isHttps(requestUrl) {
    const parsedUrl = new URL(requestUrl);
    return parsedUrl.protocol === 'https:';
}
exports.isHttps = isHttps;
class HttpClient {
    constructor(userAgent, handlers, requestOptions) {
        this._ignoreSslError = false;
        this._allowRedirects = true;
        this._allowRedirectDowngrade = false;
        this._maxRedirects = 50;
        this._allowRetries = false;
        this._maxRetries = 1;
        this._keepAlive = false;
        this._disposed = false;
        this.userAgent = userAgent;
        this.handlers = handlers || [];
        this.requestOptions = requestOptions;
        if (requestOptions) {
            if (requestOptions.ignoreSslError != null) {
                this._ignoreSslError = requestOptions.ignoreSslError;
            }
            this._socketTimeout = requestOptions.socketTimeout;
            if (requestOptions.allowRedirects != null) {
                this._allowRedirects = requestOptions.allowRedirects;
            }
            if (requestOptions.allowRedirectDowngrade != null) {
                this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;
            }
            if (requestOptions.maxRedirects != null) {
                this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);
            }
            if (requestOptions.keepAlive != null) {
                this._keepAlive = requestOptions.keepAlive;
            }
            if (requestOptions.allowRetries != null) {
                this._allowRetries = requestOptions.allowRetries;
            }
            if (requestOptions.maxRetries != null) {
                this._maxRetries = requestOptions.maxRetries;
            }
        }
    }
    options(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('OPTIONS', requestUrl, null, additionalHeaders || {});
        });
    }
    get(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('GET', requestUrl, null, additionalHeaders || {});
        });
    }
    del(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('DELETE', requestUrl, null, additionalHeaders || {});
        });
    }
    post(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('POST', requestUrl, data, additionalHeaders || {});
        });
    }
    patch(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('PATCH', requestUrl, data, additionalHeaders || {});
        });
    }
    put(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('PUT', requestUrl, data, additionalHeaders || {});
        });
    }
    head(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('HEAD', requestUrl, null, additionalHeaders || {});
        });
    }
    sendStream(verb, requestUrl, stream, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request(verb, requestUrl, stream, additionalHeaders);
        });
    }
    /**
     * Gets a typed object from an endpoint
     * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise
     */
    getJson(requestUrl, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
            const res = yield this.get(requestUrl, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
        });
    }
    postJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = JSON.stringify(obj, null, 2);
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
            const res = yield this.post(requestUrl, data, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
        });
    }
    putJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = JSON.stringify(obj, null, 2);
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
            const res = yield this.put(requestUrl, data, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
        });
    }
    patchJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = JSON.stringify(obj, null, 2);
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
            const res = yield this.patch(requestUrl, data, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
        });
    }
    /**
     * Makes a raw http request.
     * All other methods such as get, post, patch, and request ultimately call this.
     * Prefer get, del, post and patch
     */
    request(verb, requestUrl, data, headers) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._disposed) {
                throw new Error('Client has already been disposed.');
            }
            const parsedUrl = new URL(requestUrl);
            let info = this._prepareRequest(verb, parsedUrl, headers);
            // Only perform retries on reads since writes may not be idempotent.
            const maxTries = this._allowRetries && RetryableHttpVerbs.includes(verb)
                ? this._maxRetries + 1
                : 1;
            let numTries = 0;
            let response;
            do {
                response = yield this.requestRaw(info, data);
                // Check if it's an authentication challenge
                if (response &&
                    response.message &&
                    response.message.statusCode === HttpCodes.Unauthorized) {
                    let authenticationHandler;
                    for (const handler of this.handlers) {
                        if (handler.canHandleAuthentication(response)) {
                            authenticationHandler = handler;
                            break;
                        }
                    }
                    if (authenticationHandler) {
                        return authenticationHandler.handleAuthentication(this, info, data);
                    }
                    else {
                        // We have received an unauthorized response but have no handlers to handle it.
                        // Let the response return to the caller.
                        return response;
                    }
                }
                let redirectsRemaining = this._maxRedirects;
                while (response.message.statusCode &&
                    HttpRedirectCodes.includes(response.message.statusCode) &&
                    this._allowRedirects &&
                    redirectsRemaining > 0) {
                    const redirectUrl = response.message.headers['location'];
                    if (!redirectUrl) {
                        // if there's no location to redirect to, we won't
                        break;
                    }
                    const parsedRedirectUrl = new URL(redirectUrl);
                    if (parsedUrl.protocol === 'https:' &&
                        parsedUrl.protocol !== parsedRedirectUrl.protocol &&
                        !this._allowRedirectDowngrade) {
                        throw new Error('Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.');
                    }
                    // we need to finish reading the response before reassigning response
                    // which will leak the open socket.
                    yield response.readBody();
                    // strip authorization header if redirected to a different hostname
                    if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {
                        for (const header in headers) {
                            // header names are case insensitive
                            if (header.toLowerCase() === 'authorization') {
                                delete headers[header];
                            }
                        }
                    }
                    // let's make the request with the new redirectUrl
                    info = this._prepareRequest(verb, parsedRedirectUrl, headers);
                    response = yield this.requestRaw(info, data);
                    redirectsRemaining--;
                }
                if (!response.message.statusCode ||
                    !HttpResponseRetryCodes.includes(response.message.statusCode)) {
                    // If not a retry code, return immediately instead of retrying
                    return response;
                }
                numTries += 1;
                if (numTries < maxTries) {
                    yield response.readBody();
                    yield this._performExponentialBackoff(numTries);
                }
            } while (numTries < maxTries);
            return response;
        });
    }
    /**
     * Needs to be called if keepAlive is set to true in request options.
     */
    dispose() {
        if (this._agent) {
            this._agent.destroy();
        }
        this._disposed = true;
    }
    /**
     * Raw request.
     * @param info
     * @param data
     */
    requestRaw(info, data) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                function callbackForResult(err, res) {
                    if (err) {
                        reject(err);
                    }
                    else if (!res) {
                        // If `err` is not passed, then `res` must be passed.
                        reject(new Error('Unknown error'));
                    }
                    else {
                        resolve(res);
                    }
                }
                this.requestRawWithCallback(info, data, callbackForResult);
            });
        });
    }
    /**
     * Raw request with callback.
     * @param info
     * @param data
     * @param onResult
     */
    requestRawWithCallback(info, data, onResult) {
        if (typeof data === 'string') {
            if (!info.options.headers) {
                info.options.headers = {};
            }
            info.options.headers['Content-Length'] = Buffer.byteLength(data, 'utf8');
        }
        let callbackCalled = false;
        function handleResult(err, res) {
            if (!callbackCalled) {
                callbackCalled = true;
                onResult(err, res);
            }
        }
        const req = info.httpModule.request(info.options, (msg) => {
            const res = new HttpClientResponse(msg);
            handleResult(undefined, res);
        });
        let socket;
        req.on('socket', sock => {
            socket = sock;
        });
        // If we ever get disconnected, we want the socket to timeout eventually
        req.setTimeout(this._socketTimeout || 3 * 60000, () => {
            if (socket) {
                socket.end();
            }
            handleResult(new Error(`Request timeout: ${info.options.path}`));
        });
        req.on('error', function (err) {
            // err has statusCode property
            // res should have headers
            handleResult(err);
        });
        if (data && typeof data === 'string') {
            req.write(data, 'utf8');
        }
        if (data && typeof data !== 'string') {
            data.on('close', function () {
                req.end();
            });
            data.pipe(req);
        }
        else {
            req.end();
        }
    }
    /**
     * Gets an http agent. This function is useful when you need an http agent that handles
     * routing through a proxy server - depending upon the url and proxy environment variables.
     * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
     */
    getAgent(serverUrl) {
        const parsedUrl = new URL(serverUrl);
        return this._getAgent(parsedUrl);
    }
    _prepareRequest(method, requestUrl, headers) {
        const info = {};
        info.parsedUrl = requestUrl;
        const usingSsl = info.parsedUrl.protocol === 'https:';
        info.httpModule = usingSsl ? https : http;
        const defaultPort = usingSsl ? 443 : 80;
        info.options = {};
        info.options.host = info.parsedUrl.hostname;
        info.options.port = info.parsedUrl.port
            ? parseInt(info.parsedUrl.port)
            : defaultPort;
        info.options.path =
            (info.parsedUrl.pathname || '') + (info.parsedUrl.search || '');
        info.options.method = method;
        info.options.headers = this._mergeHeaders(headers);
        if (this.userAgent != null) {
            info.options.headers['user-agent'] = this.userAgent;
        }
        info.options.agent = this._getAgent(info.parsedUrl);
        // gives handlers an opportunity to participate
        if (this.handlers) {
            for (const handler of this.handlers) {
                handler.prepareRequest(info.options);
            }
        }
        return info;
    }
    _mergeHeaders(headers) {
        if (this.requestOptions && this.requestOptions.headers) {
            return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers || {}));
        }
        return lowercaseKeys(headers || {});
    }
    _getExistingOrDefaultHeader(additionalHeaders, header, _default) {
        let clientHeader;
        if (this.requestOptions && this.requestOptions.headers) {
            clientHeader = lowercaseKeys(this.requestOptions.headers)[header];
        }
        return additionalHeaders[header] || clientHeader || _default;
    }
    _getAgent(parsedUrl) {
        let agent;
        const proxyUrl = pm.getProxyUrl(parsedUrl);
        const useProxy = proxyUrl && proxyUrl.hostname;
        if (this._keepAlive && useProxy) {
            agent = this._proxyAgent;
        }
        if (this._keepAlive && !useProxy) {
            agent = this._agent;
        }
        // if agent is already assigned use that agent.
        if (agent) {
            return agent;
        }
        const usingSsl = parsedUrl.protocol === 'https:';
        let maxSockets = 100;
        if (this.requestOptions) {
            maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;
        }
        // This is `useProxy` again, but we need to check `proxyURl` directly for TypeScripts's flow analysis.
        if (proxyUrl && proxyUrl.hostname) {
            const agentOptions = {
                maxSockets,
                keepAlive: this._keepAlive,
                proxy: Object.assign(Object.assign({}, ((proxyUrl.username || proxyUrl.password) && {
                    proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`
                })), { host: proxyUrl.hostname, port: proxyUrl.port })
            };
            let tunnelAgent;
            const overHttps = proxyUrl.protocol === 'https:';
            if (usingSsl) {
                tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;
            }
            else {
                tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;
            }
            agent = tunnelAgent(agentOptions);
            this._proxyAgent = agent;
        }
        // if reusing agent across request and tunneling agent isn't assigned create a new agent
        if (this._keepAlive && !agent) {
            const options = { keepAlive: this._keepAlive, maxSockets };
            agent = usingSsl ? new https.Agent(options) : new http.Agent(options);
            this._agent = agent;
        }
        // if not using private agent and tunnel agent isn't setup then use global agent
        if (!agent) {
            agent = usingSsl ? https.globalAgent : http.globalAgent;
        }
        if (usingSsl && this._ignoreSslError) {
            // we don't want to set NODE_TLS_REJECT_UNAUTHORIZED=0 since that will affect request for entire process
            // http.RequestOptions doesn't expose a way to modify RequestOptions.agent.options
            // we have to cast it to any and change it directly
            agent.options = Object.assign(agent.options || {}, {
                rejectUnauthorized: false
            });
        }
        return agent;
    }
    _performExponentialBackoff(retryNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
            const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
            return new Promise(resolve => setTimeout(() => resolve(), ms));
        });
    }
    _processResponse(res, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                const statusCode = res.message.statusCode || 0;
                const response = {
                    statusCode,
                    result: null,
                    headers: {}
                };
                // not found leads to null obj returned
                if (statusCode === HttpCodes.NotFound) {
                    resolve(response);
                }
                // get the result from the body
                function dateTimeDeserializer(key, value) {
                    if (typeof value === 'string') {
                        const a = new Date(value);
                        if (!isNaN(a.valueOf())) {
                            return a;
                        }
                    }
                    return value;
                }
                let obj;
                let contents;
                try {
                    contents = yield res.readBody();
                    if (contents && contents.length > 0) {
                        if (options && options.deserializeDates) {
                            obj = JSON.parse(contents, dateTimeDeserializer);
                        }
                        else {
                            obj = JSON.parse(contents);
                        }
                        response.result = obj;
                    }
                    response.headers = res.message.headers;
                }
                catch (err) {
                    // Invalid resource (contents not json);  leaving result obj null
                }
                // note that 3xx redirects are handled by the http layer.
                if (statusCode > 299) {
                    let msg;
                    // if exception/error in body, attempt to get better error
                    if (obj && obj.message) {
                        msg = obj.message;
                    }
                    else if (contents && contents.length > 0) {
                        // it may be the case that the exception is in the body message as string
                        msg = contents;
                    }
                    else {
                        msg = `Failed request: (${statusCode})`;
                    }
                    const err = new HttpClientError(msg, statusCode);
                    err.result = response.result;
                    reject(err);
                }
                else {
                    resolve(response);
                }
            }));
        });
    }
}
exports.HttpClient = HttpClient;
const lowercaseKeys = (obj) => Object.keys(obj).reduce((c, k) => ((c[k.toLowerCase()] = obj[k]), c), {});
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 9835:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.checkBypass = exports.getProxyUrl = void 0;
function getProxyUrl(reqUrl) {
    const usingSsl = reqUrl.protocol === 'https:';
    if (checkBypass(reqUrl)) {
        return undefined;
    }
    const proxyVar = (() => {
        if (usingSsl) {
            return process.env['https_proxy'] || process.env['HTTPS_PROXY'];
        }
        else {
            return process.env['http_proxy'] || process.env['HTTP_PROXY'];
        }
    })();
    if (proxyVar) {
        return new URL(proxyVar);
    }
    else {
        return undefined;
    }
}
exports.getProxyUrl = getProxyUrl;
function checkBypass(reqUrl) {
    if (!reqUrl.hostname) {
        return false;
    }
    const noProxy = process.env['no_proxy'] || process.env['NO_PROXY'] || '';
    if (!noProxy) {
        return false;
    }
    // Determine the request port
    let reqPort;
    if (reqUrl.port) {
        reqPort = Number(reqUrl.port);
    }
    else if (reqUrl.protocol === 'http:') {
        reqPort = 80;
    }
    else if (reqUrl.protocol === 'https:') {
        reqPort = 443;
    }
    // Format the request hostname and hostname with port
    const upperReqHosts = [reqUrl.hostname.toUpperCase()];
    if (typeof reqPort === 'number') {
        upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);
    }
    // Compare request host against noproxy
    for (const upperNoProxyItem of noProxy
        .split(',')
        .map(x => x.trim().toUpperCase())
        .filter(x => x)) {
        if (upperReqHosts.some(x => x === upperNoProxyItem)) {
            return true;
        }
    }
    return false;
}
exports.checkBypass = checkBypass;
//# sourceMappingURL=proxy.js.map

/***/ }),

/***/ 4294:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = __nccwpck_require__(4219);


/***/ }),

/***/ 4219:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var net = __nccwpck_require__(1808);
var tls = __nccwpck_require__(4404);
var http = __nccwpck_require__(3685);
var https = __nccwpck_require__(5687);
var events = __nccwpck_require__(2361);
var assert = __nccwpck_require__(9491);
var util = __nccwpck_require__(3837);


exports.httpOverHttp = httpOverHttp;
exports.httpsOverHttp = httpsOverHttp;
exports.httpOverHttps = httpOverHttps;
exports.httpsOverHttps = httpsOverHttps;


function httpOverHttp(options) {
  var agent = new TunnelingAgent(options);
  agent.request = http.request;
  return agent;
}

function httpsOverHttp(options) {
  var agent = new TunnelingAgent(options);
  agent.request = http.request;
  agent.createSocket = createSecureSocket;
  agent.defaultPort = 443;
  return agent;
}

function httpOverHttps(options) {
  var agent = new TunnelingAgent(options);
  agent.request = https.request;
  return agent;
}

function httpsOverHttps(options) {
  var agent = new TunnelingAgent(options);
  agent.request = https.request;
  agent.createSocket = createSecureSocket;
  agent.defaultPort = 443;
  return agent;
}


function TunnelingAgent(options) {
  var self = this;
  self.options = options || {};
  self.proxyOptions = self.options.proxy || {};
  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;
  self.requests = [];
  self.sockets = [];

  self.on('free', function onFree(socket, host, port, localAddress) {
    var options = toOptions(host, port, localAddress);
    for (var i = 0, len = self.requests.length; i < len; ++i) {
      var pending = self.requests[i];
      if (pending.host === options.host && pending.port === options.port) {
        // Detect the request to connect same origin server,
        // reuse the connection.
        self.requests.splice(i, 1);
        pending.request.onSocket(socket);
        return;
      }
    }
    socket.destroy();
    self.removeSocket(socket);
  });
}
util.inherits(TunnelingAgent, events.EventEmitter);

TunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {
  var self = this;
  var options = mergeOptions({request: req}, self.options, toOptions(host, port, localAddress));

  if (self.sockets.length >= this.maxSockets) {
    // We are over limit so we'll add it to the queue.
    self.requests.push(options);
    return;
  }

  // If we are under maxSockets create a new one.
  self.createSocket(options, function(socket) {
    socket.on('free', onFree);
    socket.on('close', onCloseOrRemove);
    socket.on('agentRemove', onCloseOrRemove);
    req.onSocket(socket);

    function onFree() {
      self.emit('free', socket, options);
    }

    function onCloseOrRemove(err) {
      self.removeSocket(socket);
      socket.removeListener('free', onFree);
      socket.removeListener('close', onCloseOrRemove);
      socket.removeListener('agentRemove', onCloseOrRemove);
    }
  });
};

TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
  var self = this;
  var placeholder = {};
  self.sockets.push(placeholder);

  var connectOptions = mergeOptions({}, self.proxyOptions, {
    method: 'CONNECT',
    path: options.host + ':' + options.port,
    agent: false,
    headers: {
      host: options.host + ':' + options.port
    }
  });
  if (options.localAddress) {
    connectOptions.localAddress = options.localAddress;
  }
  if (connectOptions.proxyAuth) {
    connectOptions.headers = connectOptions.headers || {};
    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +
        new Buffer(connectOptions.proxyAuth).toString('base64');
  }

  debug('making CONNECT request');
  var connectReq = self.request(connectOptions);
  connectReq.useChunkedEncodingByDefault = false; // for v0.6
  connectReq.once('response', onResponse); // for v0.6
  connectReq.once('upgrade', onUpgrade);   // for v0.6
  connectReq.once('connect', onConnect);   // for v0.7 or later
  connectReq.once('error', onError);
  connectReq.end();

  function onResponse(res) {
    // Very hacky. This is necessary to avoid http-parser leaks.
    res.upgrade = true;
  }

  function onUpgrade(res, socket, head) {
    // Hacky.
    process.nextTick(function() {
      onConnect(res, socket, head);
    });
  }

  function onConnect(res, socket, head) {
    connectReq.removeAllListeners();
    socket.removeAllListeners();

    if (res.statusCode !== 200) {
      debug('tunneling socket could not be established, statusCode=%d',
        res.statusCode);
      socket.destroy();
      var error = new Error('tunneling socket could not be established, ' +
        'statusCode=' + res.statusCode);
      error.code = 'ECONNRESET';
      options.request.emit('error', error);
      self.removeSocket(placeholder);
      return;
    }
    if (head.length > 0) {
      debug('got illegal response body from proxy');
      socket.destroy();
      var error = new Error('got illegal response body from proxy');
      error.code = 'ECONNRESET';
      options.request.emit('error', error);
      self.removeSocket(placeholder);
      return;
    }
    debug('tunneling connection has established');
    self.sockets[self.sockets.indexOf(placeholder)] = socket;
    return cb(socket);
  }

  function onError(cause) {
    connectReq.removeAllListeners();

    debug('tunneling socket could not be established, cause=%s\n',
          cause.message, cause.stack);
    var error = new Error('tunneling socket could not be established, ' +
                          'cause=' + cause.message);
    error.code = 'ECONNRESET';
    options.request.emit('error', error);
    self.removeSocket(placeholder);
  }
};

TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
  var pos = this.sockets.indexOf(socket)
  if (pos === -1) {
    return;
  }
  this.sockets.splice(pos, 1);

  var pending = this.requests.shift();
  if (pending) {
    // If we have pending requests and a socket gets closed a new one
    // needs to be created to take over in the pool for the one that closed.
    this.createSocket(pending, function(socket) {
      pending.request.onSocket(socket);
    });
  }
};

function createSecureSocket(options, cb) {
  var self = this;
  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {
    var hostHeader = options.request.getHeader('host');
    var tlsOptions = mergeOptions({}, self.options, {
      socket: socket,
      servername: hostHeader ? hostHeader.replace(/:.*$/, '') : options.host
    });

    // 0 is dummy port for v0.6
    var secureSocket = tls.connect(0, tlsOptions);
    self.sockets[self.sockets.indexOf(socket)] = secureSocket;
    cb(secureSocket);
  });
}


function toOptions(host, port, localAddress) {
  if (typeof host === 'string') { // since v0.10
    return {
      host: host,
      port: port,
      localAddress: localAddress
    };
  }
  return host; // for v0.11 or later
}

function mergeOptions(target) {
  for (var i = 1, len = arguments.length; i < len; ++i) {
    var overrides = arguments[i];
    if (typeof overrides === 'object') {
      var keys = Object.keys(overrides);
      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
        var k = keys[j];
        if (overrides[k] !== undefined) {
          target[k] = overrides[k];
        }
      }
    }
  }
  return target;
}


var debug;
if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
  debug = function() {
    var args = Array.prototype.slice.call(arguments);
    if (typeof args[0] === 'string') {
      args[0] = 'TUNNEL: ' + args[0];
    } else {
      args.unshift('TUNNEL:');
    }
    console.error.apply(console, args);
  }
} else {
  debug = function() {};
}
exports.debug = debug; // for test


/***/ }),

/***/ 6795:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/*
 * UF2 (USB Flashing Format) JavaScript Library
 *
 * UF2 Format specification: https://github.com/microsoft/uf2
 *
 * Copyright (C) 2021, Uri Shaked.
 * Released under the terms of the MIT License.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encodeBlock = exports.decodeBlock = exports.isUF2Block = exports.UF2EncodeError = exports.UF2DecodeError = exports.familyID = exports.familyMap = exports.UF2Flags = exports.maxPayloadSize = exports.blockSize = exports.magicValues = exports.uf2Families = void 0;
const uf2families_1 = __nccwpck_require__(932);
Object.defineProperty(exports, "uf2Families", ({ enumerable: true, get: function () { return uf2families_1.uf2Families; } }));
exports.magicValues = [
    { offset: 0, value: 0x0a324655 },
    { offset: 4, value: 0x9e5d5157 },
    { offset: 508, value: 0x0ab16f30 },
];
exports.blockSize = 512;
exports.maxPayloadSize = 476;
exports.UF2Flags = {
    notMainFlash: 0x00000001,
    fileContainer: 0x00001000,
    familyIDPresent: 0x00002000,
    md5ChecksumPresent: 0x00004000,
    extensionTagsPresent: 0x00008000,
};
exports.familyMap = new Map(uf2families_1.uf2Families.map((f) => [f.id, f.description]));
function familyID(familyName) {
    for (const [id, name] of exports.familyMap.entries()) {
        if (name === familyName) {
            return id;
        }
    }
    return null;
}
exports.familyID = familyID;
class UF2DecodeError extends Error {
}
exports.UF2DecodeError = UF2DecodeError;
class UF2EncodeError extends Error {
}
exports.UF2EncodeError = UF2EncodeError;
function isUF2Block(data) {
    const dataView = new DataView(data.buffer);
    if (data.length !== exports.blockSize) {
        return false;
    }
    for (let { offset, value } of exports.magicValues) {
        if (dataView.getUint32(offset, true) !== value) {
            return false;
        }
    }
    return true;
}
exports.isUF2Block = isUF2Block;
function decodeBlock(data) {
    if (data.length !== exports.blockSize) {
        throw new UF2DecodeError(`Invalid UF2 block size. Block size must be exactly ${exports.blockSize} bytes.`);
    }
    const dataView = new DataView(data.buffer, data.byteOffset);
    for (let { offset, value } of exports.magicValues) {
        const actual = dataView.getUint32(offset, true);
        if (actual !== value) {
            throw new UF2DecodeError(`Invalid magic value at offset ${offset}: expected 0x${value.toString(16)}, ` +
                `but found 0x${actual.toString(16)}.`);
        }
    }
    const flags = dataView.getUint32(8, true);
    const flashAddress = dataView.getUint32(12, true);
    const payloadSize = dataView.getUint32(16, true);
    const blockNumber = dataView.getUint32(20, true);
    const totalBlocks = dataView.getUint32(24, true);
    const boardFamily = dataView.getUint32(28, true);
    if (payloadSize > exports.maxPayloadSize) {
        throw new UF2DecodeError(`Invalid payload size ${payloadSize}. Should be ${exports.maxPayloadSize} bytes or less.`);
    }
    return {
        flags,
        flashAddress,
        payload: data.slice(32, 32 + payloadSize),
        blockNumber,
        totalBlocks,
        boardFamily,
    };
}
exports.decodeBlock = decodeBlock;
function encodeBlock(blockData, target = new Uint8Array(exports.blockSize), targetOffset = 0) {
    if (target.length < targetOffset + exports.blockSize) {
        throw new UF2EncodeError(`Can't encode block: target array is too small`);
    }
    if (blockData.payload.length > exports.maxPayloadSize) {
        throw new UF2EncodeError(`Block payload too big; must be ${exports.maxPayloadSize} bytes or less.`);
    }
    target.fill(0, targetOffset, targetOffset + exports.blockSize);
    const dataView = new DataView(target.buffer, target.byteOffset + targetOffset);
    for (let { offset, value } of exports.magicValues) {
        dataView.setUint32(offset, value, true);
    }
    dataView.setUint32(8, blockData.flags, true);
    dataView.setUint32(12, blockData.flashAddress, true);
    dataView.setUint32(16, blockData.payload.length, true);
    dataView.setUint32(20, blockData.blockNumber, true);
    dataView.setUint32(24, blockData.totalBlocks, true);
    dataView.setUint32(28, blockData.boardFamily, true);
    target.set(blockData.payload, targetOffset + 32);
    return target;
}
exports.encodeBlock = encodeBlock;


/***/ }),

/***/ 932:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Source: https://github.com/microsoft/uf2/blob/master/utils/uf2families.json
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.uf2Families = void 0;
exports.uf2Families = [
    {
        id: 0x16573617,
        shortName: 'ATMEGA32',
        description: 'Microchip (Atmel) ATmega32',
    },
    {
        id: 0x1851780a,
        shortName: 'SAML21',
        description: 'Microchip (Atmel) SAML21',
    },
    {
        id: 0x1b57745f,
        shortName: 'NRF52',
        description: 'Nordic NRF52',
    },
    {
        id: 0x1c5f21b0,
        shortName: 'ESP32',
        description: 'ESP32',
    },
    {
        id: 0x1e1f432d,
        shortName: 'STM32L1',
        description: 'ST STM32L1xx',
    },
    {
        id: 0x202e3a91,
        shortName: 'STM32L0',
        description: 'ST STM32L0xx',
    },
    {
        id: 0x21460ff0,
        shortName: 'STM32WL',
        description: 'ST STM32WLxx',
    },
    {
        id: 0x2abc77ec,
        shortName: 'LPC55',
        description: 'NXP LPC55xx',
    },
    {
        id: 0x300f5633,
        shortName: 'STM32G0',
        description: 'ST STM32G0xx',
    },
    {
        id: 0x31d228c6,
        shortName: 'GD32F350',
        description: 'GD32F350',
    },
    {
        id: 0x04240bdf,
        shortName: 'STM32L5',
        description: 'ST STM32L5xx',
    },
    {
        id: 0x4c71240a,
        shortName: 'STM32G4',
        description: 'ST STM32G4xx',
    },
    {
        id: 0x4fb2d5bd,
        shortName: 'MIMXRT10XX',
        description: 'NXP i.MX RT10XX',
    },
    {
        id: 0x53b80f00,
        shortName: 'STM32F7',
        description: 'ST STM32F7xx',
    },
    {
        id: 0x55114460,
        shortName: 'SAMD51',
        description: 'Microchip (Atmel) SAMD51',
    },
    {
        id: 0x57755a57,
        shortName: 'STM32F4',
        description: 'ST STM32F4xx',
    },
    {
        id: 0x5a18069b,
        shortName: 'FX2',
        description: 'Cypress FX2',
    },
    {
        id: 0x5d1a0a2e,
        shortName: 'STM32F2',
        description: 'ST STM32F2xx',
    },
    {
        id: 0x5ee21072,
        shortName: 'STM32F1',
        description: 'ST STM32F103',
    },
    {
        id: 0x621e937a,
        shortName: 'NRF52833',
        description: 'Nordic NRF52833',
    },
    {
        id: 0x647824b6,
        shortName: 'STM32F0',
        description: 'ST STM32F0xx',
    },
    {
        id: 0x68ed2b88,
        shortName: 'SAMD21',
        description: 'Microchip (Atmel) SAMD21',
    },
    {
        id: 0x6b846188,
        shortName: 'STM32F3',
        description: 'ST STM32F3xx',
    },
    {
        id: 0x6d0922fa,
        shortName: 'STM32F407',
        description: 'ST STM32F407',
    },
    {
        id: 0x6db66082,
        shortName: 'STM32H7',
        description: 'ST STM32H7xx',
    },
    {
        id: 0x70d16653,
        shortName: 'STM32WB',
        description: 'ST STM32WBxx',
    },
    {
        id: 0x7eab61ed,
        shortName: 'ESP8266',
        description: 'ESP8266',
    },
    {
        id: 0x7f83e793,
        shortName: 'KL32L2',
        description: 'NXP KL32L2x',
    },
    {
        id: 0x8fb060fe,
        shortName: 'STM32F407VG',
        description: 'ST STM32F407VG',
    },
    {
        id: 0xada52840,
        shortName: 'NRF52840',
        description: 'Nordic NRF52840',
    },
    {
        id: 0xbfdd4eee,
        shortName: 'ESP32S2',
        description: 'ESP32-S2',
    },
    {
        id: 0xc47e5767,
        shortName: 'ESP32S3',
        description: 'ESP32-S3',
    },
    {
        id: 0xd42ba06c,
        shortName: 'ESP32C3',
        description: 'ESP32-C3',
    },
    {
        id: 0x2b88d29c,
        shortName: 'ESP32C2',
        description: 'ESP32-C2',
    },
    {
        id: 0x332726f6,
        shortName: 'ESP32H2',
        description: 'ESP32-H2',
    },
    {
        id: 0xe48bff56,
        shortName: 'RP2040',
        description: 'Raspberry Pi RP2040',
    },
    {
        id: 0x00ff6919,
        shortName: 'STM32L4',
        description: 'ST STM32L4xx',
    },
    {
        id: 0x9af03e33,
        shortName: 'GD32VF103',
        description: 'GigaDevice GD32VF103',
    },
    {
        id: 0x4f6ace52,
        shortName: 'CSK4',
        description: 'LISTENAI CSK300x/400x',
    },
    {
        id: 0x6e7348a8,
        shortName: 'CSK6',
        description: 'LISTENAI CSK60xx',
    },
    {
        id: 0x11de784a,
        shortName: 'M0SENSE',
        description: 'M0SENSE BL702',
    },
];


/***/ }),

/***/ 5840:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "v1", ({
  enumerable: true,
  get: function () {
    return _v.default;
  }
}));
Object.defineProperty(exports, "v3", ({
  enumerable: true,
  get: function () {
    return _v2.default;
  }
}));
Object.defineProperty(exports, "v4", ({
  enumerable: true,
  get: function () {
    return _v3.default;
  }
}));
Object.defineProperty(exports, "v5", ({
  enumerable: true,
  get: function () {
    return _v4.default;
  }
}));
Object.defineProperty(exports, "NIL", ({
  enumerable: true,
  get: function () {
    return _nil.default;
  }
}));
Object.defineProperty(exports, "version", ({
  enumerable: true,
  get: function () {
    return _version.default;
  }
}));
Object.defineProperty(exports, "validate", ({
  enumerable: true,
  get: function () {
    return _validate.default;
  }
}));
Object.defineProperty(exports, "stringify", ({
  enumerable: true,
  get: function () {
    return _stringify.default;
  }
}));
Object.defineProperty(exports, "parse", ({
  enumerable: true,
  get: function () {
    return _parse.default;
  }
}));

var _v = _interopRequireDefault(__nccwpck_require__(8628));

var _v2 = _interopRequireDefault(__nccwpck_require__(6409));

var _v3 = _interopRequireDefault(__nccwpck_require__(5122));

var _v4 = _interopRequireDefault(__nccwpck_require__(9120));

var _nil = _interopRequireDefault(__nccwpck_require__(5332));

var _version = _interopRequireDefault(__nccwpck_require__(1595));

var _validate = _interopRequireDefault(__nccwpck_require__(6900));

var _stringify = _interopRequireDefault(__nccwpck_require__(8950));

var _parse = _interopRequireDefault(__nccwpck_require__(2746));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),

/***/ 4569:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _crypto = _interopRequireDefault(__nccwpck_require__(6113));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function md5(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === 'string') {
    bytes = Buffer.from(bytes, 'utf8');
  }

  return _crypto.default.createHash('md5').update(bytes).digest();
}

var _default = md5;
exports["default"] = _default;

/***/ }),

/***/ 5332:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _default = '00000000-0000-0000-0000-000000000000';
exports["default"] = _default;

/***/ }),

/***/ 2746:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _validate = _interopRequireDefault(__nccwpck_require__(6900));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function parse(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }

  let v;
  const arr = new Uint8Array(16); // Parse ########-....-....-....-............

  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 0xff;
  arr[2] = v >>> 8 & 0xff;
  arr[3] = v & 0xff; // Parse ........-####-....-....-............

  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 0xff; // Parse ........-....-####-....-............

  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 0xff; // Parse ........-....-....-####-............

  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 0xff; // Parse ........-....-....-....-############
  // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
  arr[11] = v / 0x100000000 & 0xff;
  arr[12] = v >>> 24 & 0xff;
  arr[13] = v >>> 16 & 0xff;
  arr[14] = v >>> 8 & 0xff;
  arr[15] = v & 0xff;
  return arr;
}

var _default = parse;
exports["default"] = _default;

/***/ }),

/***/ 814:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
exports["default"] = _default;

/***/ }),

/***/ 807:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = rng;

var _crypto = _interopRequireDefault(__nccwpck_require__(6113));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate

let poolPtr = rnds8Pool.length;

function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    _crypto.default.randomFillSync(rnds8Pool);

    poolPtr = 0;
  }

  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}

/***/ }),

/***/ 5274:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _crypto = _interopRequireDefault(__nccwpck_require__(6113));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function sha1(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === 'string') {
    bytes = Buffer.from(bytes, 'utf8');
  }

  return _crypto.default.createHash('sha1').update(bytes).digest();
}

var _default = sha1;
exports["default"] = _default;

/***/ }),

/***/ 8950:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _validate = _interopRequireDefault(__nccwpck_require__(6900));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
const byteToHex = [];

for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}

function stringify(arr, offset = 0) {
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

var _default = stringify;
exports["default"] = _default;

/***/ }),

/***/ 8628:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _rng = _interopRequireDefault(__nccwpck_require__(807));

var _stringify = _interopRequireDefault(__nccwpck_require__(8950));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html
let _nodeId;

let _clockseq; // Previous uuid creation time


let _lastMSecs = 0;
let _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

function v1(options, buf, offset) {
  let i = buf && offset || 0;
  const b = buf || new Array(16);
  options = options || {};
  let node = options.node || _nodeId;
  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189

  if (node == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || _rng.default)();

    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }

    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock

  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval


  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  } // Per 4.2.1.2 Throw error if too many uuids are requested


  if (nsecs >= 10000) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

  msecs += 12219292800000; // `time_low`

  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff; // `time_mid`

  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff; // `time_high_and_version`

  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

  b[i++] = clockseq & 0xff; // `node`

  for (let n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf || (0, _stringify.default)(b);
}

var _default = v1;
exports["default"] = _default;

/***/ }),

/***/ 6409:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _v = _interopRequireDefault(__nccwpck_require__(5998));

var _md = _interopRequireDefault(__nccwpck_require__(4569));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v3 = (0, _v.default)('v3', 0x30, _md.default);
var _default = v3;
exports["default"] = _default;

/***/ }),

/***/ 5998:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
exports.URL = exports.DNS = void 0;

var _stringify = _interopRequireDefault(__nccwpck_require__(8950));

var _parse = _interopRequireDefault(__nccwpck_require__(2746));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function stringToBytes(str) {
  str = unescape(encodeURIComponent(str)); // UTF8 escape

  const bytes = [];

  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }

  return bytes;
}

const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
exports.DNS = DNS;
const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
exports.URL = URL;

function _default(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === 'string') {
      value = stringToBytes(value);
    }

    if (typeof namespace === 'string') {
      namespace = (0, _parse.default)(namespace);
    }

    if (namespace.length !== 16) {
      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
    } // Compute hash of namespace and value, Per 4.3
    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
    // hashfunc([...namespace, ... value])`


    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 0x0f | version;
    bytes[8] = bytes[8] & 0x3f | 0x80;

    if (buf) {
      offset = offset || 0;

      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }

      return buf;
    }

    return (0, _stringify.default)(bytes);
  } // Function#name is not settable on some platforms (#270)


  try {
    generateUUID.name = name; // eslint-disable-next-line no-empty
  } catch (err) {} // For CommonJS default export support


  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}

/***/ }),

/***/ 5122:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _rng = _interopRequireDefault(__nccwpck_require__(807));

var _stringify = _interopRequireDefault(__nccwpck_require__(8950));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function v4(options, buf, offset) {
  options = options || {};

  const rnds = options.random || (options.rng || _rng.default)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`


  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return (0, _stringify.default)(rnds);
}

var _default = v4;
exports["default"] = _default;

/***/ }),

/***/ 9120:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _v = _interopRequireDefault(__nccwpck_require__(5998));

var _sha = _interopRequireDefault(__nccwpck_require__(5274));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v5 = (0, _v.default)('v5', 0x50, _sha.default);
var _default = v5;
exports["default"] = _default;

/***/ }),

/***/ 6900:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _regex = _interopRequireDefault(__nccwpck_require__(814));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function validate(uuid) {
  return typeof uuid === 'string' && _regex.default.test(uuid);
}

var _default = validate;
exports["default"] = _default;

/***/ }),

/***/ 1595:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _validate = _interopRequireDefault(__nccwpck_require__(6900));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function version(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }

  return parseInt(uuid.substr(14, 1), 16);
}

var _default = version;
exports["default"] = _default;

/***/ }),

/***/ 9491:
/***/ ((module) => {

"use strict";
module.exports = require("assert");

/***/ }),

/***/ 6113:
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ 2361:
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ 7147:
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ 3685:
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ 5687:
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ 1808:
/***/ ((module) => {

"use strict";
module.exports = require("net");

/***/ }),

/***/ 2037:
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ 1017:
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ 4404:
/***/ ((module) => {

"use strict";
module.exports = require("tls");

/***/ }),

/***/ 3837:
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ 5938:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RealtimeClock = exports.ClockTimer = void 0;
const time_1 = __nccwpck_require__(3802);
class ClockTimer {
    constructor(micros, callback) {
        this.micros = micros;
        this.callback = callback;
        this.jsTimer = null;
        this.timeLeft = this.micros;
    }
    schedule(currentMicros) {
        this.jsTimer = setTimeout(this.callback, (this.micros - currentMicros) / 1000);
    }
    unschedule() {
        if (this.jsTimer) {
            clearTimeout(this.jsTimer);
            this.jsTimer = null;
        }
    }
    pause(currentMicros) {
        this.timeLeft = this.micros - currentMicros;
        this.unschedule();
    }
    resume(currentMicros) {
        this.micros = currentMicros + this.timeLeft;
        this.schedule(currentMicros);
    }
}
exports.ClockTimer = ClockTimer;
class RealtimeClock {
    constructor() {
        this.baseTime = 0;
        this.pauseTime = 0;
        this.paused = true;
        this.timers = new Set();
    }
    pause() {
        if (!this.paused) {
            for (const timer of this.timers) {
                timer.pause(this.micros);
            }
            this.pauseTime = this.micros;
            this.paused = true;
        }
    }
    resume() {
        if (this.paused) {
            this.baseTime = time_1.getCurrentMicroseconds() - this.pauseTime;
            this.paused = false;
            for (const timer of this.timers) {
                timer.resume(this.micros);
            }
        }
    }
    createTimer(deltaMicros, callback) {
        const timer = new ClockTimer(this.micros + deltaMicros, () => {
            this.timers.delete(timer);
            callback();
        });
        timer.schedule(this.micros);
        this.timers.add(timer);
        return timer;
    }
    deleteTimer(timer) {
        timer.unschedule();
        this.timers.delete(timer);
    }
    get micros() {
        return time_1.getCurrentMicroseconds() - this.baseTime;
    }
}
exports.RealtimeClock = RealtimeClock;


/***/ }),

/***/ 4407:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CortexM0Core = exports.SYSM_CONTROL = exports.SYSM_PRIMASK = exports.SYSM_PSP = exports.SYSM_MSP = void 0;
const irq_1 = __nccwpck_require__(679);
const rp2040_1 = __nccwpck_require__(1038);
/* eslint-disable @typescript-eslint/no-unused-vars */
const EXC_RESET = 1;
const EXC_NMI = 2;
const EXC_HARDFAULT = 3;
const EXC_SVCALL = 11;
const EXC_PENDSV = 14;
const EXC_SYSTICK = 15;
const SYSM_APSR = 0;
const SYSM_IAPSR = 1;
const SYSM_EAPSR = 2;
const SYSM_XPSR = 3;
const SYSM_IPSR = 5;
const SYSM_EPSR = 6;
const SYSM_IEPSR = 7;
exports.SYSM_MSP = 8;
exports.SYSM_PSP = 9;
exports.SYSM_PRIMASK = 16;
exports.SYSM_CONTROL = 20;
/* eslint-enable @typescript-eslint/no-unused-vars */
// Lowest possible exception priority
const LOWEST_PRIORITY = 4;
var ExecutionMode;
(function (ExecutionMode) {
    ExecutionMode[ExecutionMode["Mode_Thread"] = 0] = "Mode_Thread";
    ExecutionMode[ExecutionMode["Mode_Handler"] = 1] = "Mode_Handler";
})(ExecutionMode || (ExecutionMode = {}));
function signExtend8(value) {
    return (value << 24) >> 24;
}
function signExtend16(value) {
    return (value << 16) >> 16;
}
const spRegister = 13;
const pcRegister = 15;
var StackPointerBank;
(function (StackPointerBank) {
    StackPointerBank[StackPointerBank["SPmain"] = 0] = "SPmain";
    StackPointerBank[StackPointerBank["SPprocess"] = 1] = "SPprocess";
})(StackPointerBank || (StackPointerBank = {}));
const LOG_NAME = 'CortexM0Core';
class CortexM0Core {
    constructor(rp2040) {
        this.rp2040 = rp2040;
        this.registers = new Uint32Array(16);
        this.bankedSP = 0;
        this.cycles = 0;
        this.eventRegistered = false;
        this.waiting = false;
        // APSR fields
        this.N = false;
        this.C = false;
        this.Z = false;
        this.V = false;
        // How many bytes to rewind the last break instruction
        this.breakRewind = 0;
        // PRIMASK fields
        this.PM = false;
        // CONTROL fields
        this.SPSEL = StackPointerBank.SPmain;
        this.nPRIV = false;
        this.currentMode = ExecutionMode.Mode_Thread;
        this.IPSR = 0;
        this.interruptNMIMask = 0;
        this.pendingInterrupts = 0;
        this.enabledInterrupts = 0;
        this.interruptPriorities = [0xffffffff, 0x0, 0x0, 0x0];
        this.pendingNMI = false;
        this.pendingPendSV = false;
        this.pendingSVCall = false;
        this.pendingSystick = false;
        this.interruptsUpdated = false;
        this.VTOR = 0;
        this.SHPR2 = 0;
        this.SHPR3 = 0;
        this.SP = 0xfffffffc;
        this.bankedSP = 0xfffffffc;
    }
    get logger() {
        return this.rp2040.logger;
    }
    reset() {
        this.SP = this.rp2040.readUint32(this.VTOR);
        this.PC = this.rp2040.readUint32(this.VTOR + 4) & 0xfffffffe;
        this.cycles = 0;
    }
    get SP() {
        return this.registers[13];
    }
    set SP(value) {
        this.registers[13] = value & ~0x3;
    }
    get LR() {
        return this.registers[14];
    }
    set LR(value) {
        this.registers[14] = value;
    }
    get PC() {
        return this.registers[15];
    }
    set PC(value) {
        this.registers[15] = value;
    }
    get APSR() {
        return ((this.N ? 0x80000000 : 0) |
            (this.Z ? 0x40000000 : 0) |
            (this.C ? 0x20000000 : 0) |
            (this.V ? 0x10000000 : 0));
    }
    set APSR(value) {
        this.N = !!(value & 0x80000000);
        this.Z = !!(value & 0x40000000);
        this.C = !!(value & 0x20000000);
        this.V = !!(value & 0x10000000);
    }
    get xPSR() {
        return this.APSR | this.IPSR | (1 << 24);
    }
    set xPSR(value) {
        this.APSR = value;
        this.IPSR = value & 0x3f;
    }
    checkCondition(cond) {
        // Evaluate base condition.
        let result = false;
        switch (cond >> 1) {
            case 0b000:
                result = this.Z;
                break;
            case 0b001:
                result = this.C;
                break;
            case 0b010:
                result = this.N;
                break;
            case 0b011:
                result = this.V;
                break;
            case 0b100:
                result = this.C && !this.Z;
                break;
            case 0b101:
                result = this.N === this.V;
                break;
            case 0b110:
                result = this.N === this.V && !this.Z;
                break;
            case 0b111:
                result = true;
                break;
        }
        return cond & 0b1 && cond != 0b1111 ? !result : result;
    }
    readUint32(address) {
        return this.rp2040.readUint32(address);
    }
    readUint16(address) {
        return this.rp2040.readUint16(address);
    }
    readUint8(address) {
        return this.rp2040.readUint8(address);
    }
    writeUint32(address, value) {
        this.rp2040.writeUint32(address, value);
    }
    writeUint16(address, value) {
        this.rp2040.writeUint16(address, value);
    }
    writeUint8(address, value) {
        this.rp2040.writeUint8(address, value);
    }
    switchStack(stack) {
        if (this.SPSEL !== stack) {
            const temp = this.SP;
            this.SP = this.bankedSP;
            this.bankedSP = temp;
            this.SPSEL = stack;
        }
    }
    get SPprocess() {
        return this.SPSEL === StackPointerBank.SPprocess ? this.SP : this.bankedSP;
    }
    set SPprocess(value) {
        if (this.SPSEL === StackPointerBank.SPprocess) {
            this.SP = value;
        }
        else {
            this.bankedSP = value >>> 0;
        }
    }
    get SPmain() {
        return this.SPSEL === StackPointerBank.SPmain ? this.SP : this.bankedSP;
    }
    set SPmain(value) {
        if (this.SPSEL === StackPointerBank.SPmain) {
            this.SP = value;
        }
        else {
            this.bankedSP = value >>> 0;
        }
    }
    exceptionEntry(exceptionNumber) {
        // PushStack:
        let framePtr = 0;
        let framePtrAlign = 0;
        if (this.SPSEL && this.currentMode === ExecutionMode.Mode_Thread) {
            framePtrAlign = this.SPprocess & 0b100 ? 1 : 0;
            this.SPprocess = (this.SPprocess - 0x20) & ~0b100;
            framePtr = this.SPprocess;
        }
        else {
            framePtrAlign = this.SPmain & 0b100 ? 1 : 0;
            this.SPmain = (this.SPmain - 0x20) & ~0b100;
            framePtr = this.SPmain;
        }
        /* only the stack locations, not the store order, are architected */
        this.writeUint32(framePtr, this.registers[0]);
        this.writeUint32(framePtr + 0x4, this.registers[1]);
        this.writeUint32(framePtr + 0x8, this.registers[2]);
        this.writeUint32(framePtr + 0xc, this.registers[3]);
        this.writeUint32(framePtr + 0x10, this.registers[12]);
        this.writeUint32(framePtr + 0x14, this.LR);
        this.writeUint32(framePtr + 0x18, this.PC & ~1); // ReturnAddress(ExceptionType);
        this.writeUint32(framePtr + 0x1c, (this.xPSR & ~(1 << 9)) | (framePtrAlign << 9));
        if (this.currentMode == ExecutionMode.Mode_Handler) {
            this.LR = 0xfffffff1;
        }
        else {
            if (!this.SPSEL) {
                this.LR = 0xfffffff9;
            }
            else {
                this.LR = 0xfffffffd;
            }
        }
        // ExceptionTaken:
        this.currentMode = ExecutionMode.Mode_Handler; // Enter Handler Mode, now Privileged
        this.IPSR = exceptionNumber;
        this.switchStack(StackPointerBank.SPmain);
        this.eventRegistered = true;
        const vectorTable = this.VTOR;
        this.PC = this.readUint32(vectorTable + 4 * exceptionNumber);
    }
    exceptionReturn(excReturn) {
        let framePtr = this.SPmain;
        switch (excReturn & 0xf) {
            case 0b0001: // Return to Handler
                this.currentMode = ExecutionMode.Mode_Handler;
                this.switchStack(StackPointerBank.SPmain);
                break;
            case 0b1001: // Return to Thread using Main stack
                this.currentMode = ExecutionMode.Mode_Thread;
                this.switchStack(StackPointerBank.SPmain);
                break;
            case 0b1101: // Return to Thread using Process stack
                framePtr = this.SPprocess;
                this.currentMode = ExecutionMode.Mode_Thread;
                this.switchStack(StackPointerBank.SPprocess);
                break;
            // Assigning CurrentMode to Mode_Thread causes a drop in privilege
            // if CONTROL.nPRIV is set to 1
        }
        // PopStack:
        this.registers[0] = this.readUint32(framePtr); // Stack accesses are performed as Unprivileged accesses if
        this.registers[1] = this.readUint32(framePtr + 0x4); // CONTROL<0>=='1' && EXC_RETURN<3>=='1' Privileged otherwise
        this.registers[2] = this.readUint32(framePtr + 0x8);
        this.registers[3] = this.readUint32(framePtr + 0xc);
        this.registers[12] = this.readUint32(framePtr + 0x10);
        this.LR = this.readUint32(framePtr + 0x14);
        this.PC = this.readUint32(framePtr + 0x18);
        const psr = this.readUint32(framePtr + 0x1c);
        const framePtrAlign = psr & (1 << 9) ? 0b100 : 0;
        switch (excReturn & 0xf) {
            case 0b0001: // Returning to Handler mode
                this.SPmain = (this.SPmain + 0x20) | framePtrAlign;
                break;
            case 0b1001: // Returning to Thread mode using Main stack
                this.SPmain = (this.SPmain + 0x20) | framePtrAlign;
                break;
            case 0b1101: // Returning to Thread mode using Process stack
                this.SPprocess = (this.SPprocess + 0x20) | framePtrAlign;
                break;
        }
        this.APSR = psr & 0xf0000000;
        const forceThread = this.currentMode == ExecutionMode.Mode_Thread && this.nPRIV;
        this.IPSR = forceThread ? 0 : psr & 0x3f;
        this.interruptsUpdated = true;
        // Thumb bit should always be one! EPSR<24> = psr<24>; // Load valid EPSR bits from memory
        this.eventRegistered = true;
        // if CurrentMode == Mode_Thread && SCR.SLEEPONEXIT == '1' then
        // SleepOnExit(); // IMPLEMENTATION DEFINED
    }
    get pendSVPriority() {
        return (this.SHPR3 >> 22) & 0x3;
    }
    get svCallPriority() {
        return this.SHPR2 >>> 30;
    }
    get systickPriority() {
        return this.SHPR3 >>> 30;
    }
    exceptionPriority(n) {
        switch (n) {
            case EXC_RESET:
                return -3;
            case EXC_NMI:
                return -2;
            case EXC_HARDFAULT:
                return -1;
            case EXC_SVCALL:
                return this.svCallPriority;
            case EXC_PENDSV:
                return this.pendSVPriority;
            case EXC_SYSTICK:
                return this.systickPriority;
            default: {
                if (n < 16) {
                    return LOWEST_PRIORITY;
                }
                const intNum = n - 16;
                for (let priority = 0; priority < 4; priority++) {
                    if (this.interruptPriorities[priority] & (1 << intNum)) {
                        return priority;
                    }
                }
                return LOWEST_PRIORITY;
            }
        }
    }
    get vectPending() {
        if (this.pendingNMI) {
            return EXC_NMI;
        }
        const { svCallPriority, systickPriority, pendSVPriority, pendingInterrupts } = this;
        for (let priority = 0; priority < LOWEST_PRIORITY; priority++) {
            const levelInterrupts = pendingInterrupts & this.interruptPriorities[priority];
            if (this.pendingSVCall && priority === svCallPriority) {
                return EXC_SVCALL;
            }
            if (this.pendingPendSV && priority === pendSVPriority) {
                return EXC_PENDSV;
            }
            if (this.pendingSystick && priority === systickPriority) {
                return EXC_SYSTICK;
            }
            if (levelInterrupts) {
                for (let interruptNumber = 0; interruptNumber < 32; interruptNumber++) {
                    if (levelInterrupts & (1 << interruptNumber)) {
                        return 16 + interruptNumber;
                    }
                }
            }
        }
        return 0;
    }
    setInterrupt(irq, value) {
        const irqBit = 1 << irq;
        if (value && !(this.pendingInterrupts & irqBit)) {
            this.pendingInterrupts |= irqBit;
            this.interruptsUpdated = true;
            if (this.waiting && this.checkForInterrupts()) {
                this.waiting = false;
            }
        }
        else if (!value) {
            this.pendingInterrupts &= ~irqBit;
        }
    }
    checkForInterrupts() {
        /* If we're waiting for an interrupt (i.e. WFI/WFE), the ARM says:
           > If PRIMASK.PM is set to 1, an asynchronous exception that has a higher group priority than any
           > active exception results in a WFI instruction exit. If the group priority of the exception is less than or
           > equal to the execution group priority, the exception is ignored.
        */
        const currentPriority = this.waiting
            ? this.PM
                ? this.exceptionPriority(this.IPSR)
                : LOWEST_PRIORITY
            : Math.min(this.exceptionPriority(this.IPSR), this.PM ? 0 : LOWEST_PRIORITY);
        const interruptSet = this.pendingInterrupts & this.enabledInterrupts;
        const { svCallPriority, systickPriority, pendSVPriority } = this;
        if (this.pendingNMI) {
            this.pendingNMI = false;
            this.exceptionEntry(EXC_NMI);
            return true;
        }
        for (let priority = 0; priority < currentPriority; priority++) {
            const levelInterrupts = interruptSet & this.interruptPriorities[priority];
            if (this.pendingSVCall && priority === svCallPriority) {
                this.pendingSVCall = false;
                this.exceptionEntry(EXC_SVCALL);
                return true;
            }
            if (this.pendingPendSV && priority === pendSVPriority) {
                this.pendingPendSV = false;
                this.exceptionEntry(EXC_PENDSV);
                return true;
            }
            if (this.pendingSystick && priority === systickPriority) {
                this.pendingSystick = false;
                this.exceptionEntry(EXC_SYSTICK);
                return true;
            }
            if (levelInterrupts) {
                for (let interruptNumber = 0; interruptNumber < 32; interruptNumber++) {
                    if (levelInterrupts & (1 << interruptNumber)) {
                        if (interruptNumber > irq_1.MAX_HARDWARE_IRQ) {
                            this.pendingInterrupts &= ~(1 << interruptNumber);
                        }
                        this.exceptionEntry(16 + interruptNumber);
                        return true;
                    }
                }
            }
        }
        this.interruptsUpdated = false;
        return false;
    }
    readSpecialRegister(sysm) {
        switch (sysm) {
            case SYSM_APSR:
                return this.APSR;
            case SYSM_XPSR:
                return this.xPSR;
            case SYSM_IPSR:
                return this.IPSR;
            case exports.SYSM_PRIMASK:
                return this.PM ? 1 : 0;
            case exports.SYSM_MSP:
                return this.SPmain;
            case exports.SYSM_PSP:
                return this.SPprocess;
            case exports.SYSM_CONTROL:
                return (this.SPSEL === StackPointerBank.SPprocess ? 2 : 0) | (this.nPRIV ? 1 : 0);
            default:
                this.logger.warn(LOG_NAME, `MRS with unimplemented SYSm value: ${sysm}`);
                return 0;
        }
    }
    writeSpecialRegister(sysm, value) {
        switch (sysm) {
            case SYSM_APSR:
                this.APSR = value;
                break;
            case SYSM_XPSR:
                this.xPSR = value;
                break;
            case SYSM_IPSR:
                this.IPSR = value;
                break;
            case exports.SYSM_PRIMASK:
                this.PM = !!(value & 1);
                this.interruptsUpdated = true;
                break;
            case exports.SYSM_MSP:
                this.SPmain = value;
                break;
            case exports.SYSM_PSP:
                this.SPprocess = value;
                break;
            case exports.SYSM_CONTROL:
                this.nPRIV = !!(value & 1);
                if (this.currentMode === ExecutionMode.Mode_Thread) {
                    this.switchStack(value & 2 ? StackPointerBank.SPprocess : StackPointerBank.SPmain);
                }
                break;
            default:
                this.logger.warn(LOG_NAME, `MRS with unimplemented SYSm value: ${sysm}`);
                return 0;
        }
    }
    BXWritePC(address) {
        if (this.currentMode == ExecutionMode.Mode_Handler && address >>> 28 == 0b1111) {
            this.exceptionReturn(address & 0x0fffffff);
        }
        else {
            this.PC = address & ~1;
        }
    }
    substractUpdateFlags(minuend, subtrahend) {
        const result = minuend - subtrahend;
        this.N = !!(result & 0x80000000);
        this.Z = (result & 0xffffffff) === 0;
        this.C = minuend >= subtrahend;
        this.V =
            (!!(result & 0x80000000) && !(minuend & 0x80000000) && !!(subtrahend & 0x80000000)) ||
                (!(result & 0x80000000) && !!(minuend & 0x80000000) && !(subtrahend & 0x80000000));
        return result;
    }
    addUpdateFlags(addend1, addend2) {
        const unsignedSum = (addend1 + addend2) >>> 0;
        const signedSum = (addend1 | 0) + (addend2 | 0);
        const result = addend1 + addend2;
        this.N = !!(result & 0x80000000);
        this.Z = (result & 0xffffffff) === 0;
        this.C = result === unsignedSum ? false : true;
        this.V = (result | 0) === signedSum ? false : true;
        return result & 0xffffffff;
    }
    cyclesIO(addr, write = false) {
        addr = addr >>> 0;
        if (addr >= rp2040_1.SIO_START_ADDRESS && addr < rp2040_1.SIO_START_ADDRESS + 0x10000000) {
            return 0;
        }
        if (addr >= rp2040_1.APB_START_ADDRESS && addr < rp2040_1.APB_START_ADDRESS + 0x10000000) {
            return write ? 4 : 3;
        }
        return 1;
    }
    executeInstruction() {
        if (this.interruptsUpdated) {
            if (this.checkForInterrupts()) {
                this.waiting = false;
            }
        }
        // ARM Thumb instruction encoding - 16 bits / 2 bytes
        const opcodePC = this.PC & ~1; //ensure no LSB set PC are executed
        const opcode = this.readUint16(opcodePC);
        const wideInstruction = opcode >> 12 === 0b1111 || opcode >> 11 === 0b11101;
        const opcode2 = wideInstruction ? this.readUint16(opcodePC + 2) : 0;
        this.PC += 2;
        this.cycles++;
        // ADCS
        if (opcode >> 6 === 0b0100000101) {
            const Rm = (opcode >> 3) & 0x7;
            const Rdn = opcode & 0x7;
            this.registers[Rdn] = this.addUpdateFlags(this.registers[Rm], this.registers[Rdn] + (this.C ? 1 : 0));
        }
        // ADD (register = SP plus immediate)
        else if (opcode >> 11 === 0b10101) {
            const imm8 = opcode & 0xff;
            const Rd = (opcode >> 8) & 0x7;
            this.registers[Rd] = this.SP + (imm8 << 2);
        }
        // ADD (SP plus immediate)
        else if (opcode >> 7 === 0b101100000) {
            const imm32 = (opcode & 0x7f) << 2;
            this.SP += imm32;
        }
        // ADDS (Encoding T1)
        else if (opcode >> 9 === 0b0001110) {
            const imm3 = (opcode >> 6) & 0x7;
            const Rn = (opcode >> 3) & 0x7;
            const Rd = opcode & 0x7;
            this.registers[Rd] = this.addUpdateFlags(this.registers[Rn], imm3);
        }
        // ADDS (Encoding T2)
        else if (opcode >> 11 === 0b00110) {
            const imm8 = opcode & 0xff;
            const Rdn = (opcode >> 8) & 0x7;
            this.registers[Rdn] = this.addUpdateFlags(this.registers[Rdn], imm8);
        }
        // ADDS (register)
        else if (opcode >> 9 === 0b0001100) {
            const Rm = (opcode >> 6) & 0x7;
            const Rn = (opcode >> 3) & 0x7;
            const Rd = opcode & 0x7;
            this.registers[Rd] = this.addUpdateFlags(this.registers[Rn], this.registers[Rm]);
        }
        // ADD (register)
        else if (opcode >> 8 === 0b01000100) {
            const Rm = (opcode >> 3) & 0xf;
            const Rdn = ((opcode & 0x80) >> 4) | (opcode & 0x7);
            const leftValue = Rdn === pcRegister ? this.PC + 2 : this.registers[Rdn];
            const rightValue = this.registers[Rm];
            const result = leftValue + rightValue;
            if (Rdn !== spRegister && Rdn !== pcRegister) {
                this.registers[Rdn] = result;
            }
            else if (Rdn === pcRegister) {
                this.registers[Rdn] = result & ~0x1;
                this.cycles++;
            }
            else if (Rdn === spRegister) {
                this.registers[Rdn] = result & ~0x3;
            }
        }
        // ADR
        else if (opcode >> 11 === 0b10100) {
            const imm8 = opcode & 0xff;
            const Rd = (opcode >> 8) & 0x7;
            this.registers[Rd] = (opcodePC & 0xfffffffc) + 4 + (imm8 << 2);
        }
        // ANDS (Encoding T2)
        else if (opcode >> 6 === 0b0100000000) {
            const Rm = (opcode >> 3) & 0x7;
            const Rdn = opcode & 0x7;
            const result = this.registers[Rdn] & this.registers[Rm];
            this.registers[Rdn] = result;
            this.N = !!(result & 0x80000000);
            this.Z = (result & 0xffffffff) === 0;
        }
        // ASRS (immediate)
        else if (opcode >> 11 === 0b00010) {
            const imm5 = (opcode >> 6) & 0x1f;
            const Rm = (opcode >> 3) & 0x7;
            const Rd = opcode & 0x7;
            const input = this.registers[Rm];
            const result = imm5 ? input >> imm5 : (input & 0x80000000) >> 31;
            this.registers[Rd] = result;
            this.N = !!(result & 0x80000000);
            this.Z = (result & 0xffffffff) === 0;
            if (imm5) {
                this.C = input & (1 << (imm5 - 1)) ? true : false;
            }
        }
        // ASRS (register)
        else if (opcode >> 6 === 0b0100000100) {
            const Rm = (opcode >> 3) & 0x7;
            const Rdn = opcode & 0x7;
            const input = this.registers[Rdn];
            const shiftN = (this.registers[Rm] & 0xff) < 32 ? this.registers[Rm] & 0xff : 32;
            const result = shiftN < 32 ? input >> shiftN : (input & 0x80000000) >> 31;
            this.registers[Rdn] = result;
            this.N = !!(result & 0x80000000);
            this.Z = (result & 0xffffffff) === 0;
            if (shiftN) {
                this.C = input & (1 << (shiftN - 1)) ? true : false;
            }
        }
        // B (with cond)
        else if (opcode >> 12 === 0b1101 && ((opcode >> 9) & 0x7) !== 0b111) {
            let imm8 = (opcode & 0xff) << 1;
            const cond = (opcode >> 8) & 0xf;
            if (imm8 & (1 << 8)) {
                imm8 = (imm8 & 0x1ff) - 0x200;
            }
            if (this.checkCondition(cond)) {
                this.PC += imm8 + 2;
                this.cycles++;
            }
        }
        // B
        else if (opcode >> 11 === 0b11100) {
            let imm11 = (opcode & 0x7ff) << 1;
            if (imm11 & (1 << 11)) {
                imm11 = (imm11 & 0x7ff) - 0x800;
            }
            this.PC += imm11 + 2;
            this.cycles++;
        }
        // BICS
        else if (opcode >> 6 === 0b0100001110) {
            const Rm = (opcode >> 3) & 0x7;
            const Rdn = opcode & 0x7;
            const result = (this.registers[Rdn] &= ~this.registers[Rm]);
            this.N = !!(result & 0x80000000);
            this.Z = result === 0;
        }
        // BKPT
        else if (opcode >> 8 === 0b10111110) {
            const imm8 = opcode & 0xff;
            this.breakRewind = 2;
            this.rp2040.onBreak(imm8);
        }
        // BL
        else if (opcode >> 11 === 0b11110 && opcode2 >> 14 === 0b11 && ((opcode2 >> 12) & 0x1) == 1) {
            const imm11 = opcode2 & 0x7ff;
            const J2 = (opcode2 >> 11) & 0x1;
            const J1 = (opcode2 >> 13) & 0x1;
            const imm10 = opcode & 0x3ff;
            const S = (opcode >> 10) & 0x1;
            const I1 = 1 - (S ^ J1);
            const I2 = 1 - (S ^ J2);
            const imm32 = ((S ? 0b11111111 : 0) << 24) | ((I1 << 23) | (I2 << 22) | (imm10 << 12) | (imm11 << 1));
            this.LR = (this.PC + 2) | 0x1;
            this.PC += 2 + imm32;
            this.cycles += 2;
        }
        // BLX
        else if (opcode >> 7 === 0b010001111 && (opcode & 0x7) === 0) {
            const Rm = (opcode >> 3) & 0xf;
            this.LR = this.PC | 0x1;
            this.PC = this.registers[Rm] & ~1;
            this.cycles++;
        }
        // BX
        else if (opcode >> 7 === 0b010001110 && (opcode & 0x7) === 0) {
            const Rm = (opcode >> 3) & 0xf;
            this.BXWritePC(this.registers[Rm]);
            this.cycles++;
        }
        // CMN (register)
        else if (opcode >> 6 === 0b0100001011) {
            const Rm = (opcode >> 3) & 0x7;
            const Rn = opcode & 0x7;
            this.addUpdateFlags(this.registers[Rn], this.registers[Rm]);
        }
        // CMP immediate
        else if (opcode >> 11 === 0b00101) {
            const Rn = (opcode >> 8) & 0x7;
            const imm8 = opcode & 0xff;
            this.substractUpdateFlags(this.registers[Rn], imm8);
        }
        // CMP (register)
        else if (opcode >> 6 === 0b0100001010) {
            const Rm = (opcode >> 3) & 0x7;
            const Rn = opcode & 0x7;
            this.substractUpdateFlags(this.registers[Rn], this.registers[Rm]);
        }
        // CMP (register) encoding T2
        else if (opcode >> 8 === 0b01000101) {
            const Rm = (opcode >> 3) & 0xf;
            const Rn = ((opcode >> 4) & 0x8) | (opcode & 0x7);
            this.substractUpdateFlags(this.registers[Rn], this.registers[Rm]);
        }
        // CPSID i
        else if (opcode === 0xb672) {
            this.PM = true;
        }
        // CPSIE i
        else if (opcode === 0xb662) {
            this.PM = false;
            this.interruptsUpdated = true;
        }
        // DMB SY
        else if (opcode === 0xf3bf && (opcode2 & 0xfff0) === 0x8f50) {
            this.PC += 2;
            this.cycles += 2;
        }
        // DSB SY
        else if (opcode === 0xf3bf && (opcode2 & 0xfff0) === 0x8f40) {
            this.PC += 2;
            this.cycles += 2;
        }
        // EORS
        else if (opcode >> 6 === 0b0100000001) {
            const Rm = (opcode >> 3) & 0x7;
            const Rdn = opcode & 0x7;
            const result = this.registers[Rm] ^ this.registers[Rdn];
            this.registers[Rdn] = result;
            this.N = !!(result & 0x80000000);
            this.Z = result === 0;
        }
        // ISB SY
        else if (opcode === 0xf3bf && (opcode2 & 0xfff0) === 0x8f60) {
            this.PC += 2;
            this.cycles += 2;
        }
        // LDMIA
        else if (opcode >> 11 === 0b11001) {
            const Rn = (opcode >> 8) & 0x7;
            const registers = opcode & 0xff;
            let address = this.registers[Rn];
            for (let i = 0; i < 8; i++) {
                if (registers & (1 << i)) {
                    this.registers[i] = this.readUint32(address);
                    address += 4;
                    this.cycles++;
                }
            }
            // Write back
            if (!(registers & (1 << Rn))) {
                this.registers[Rn] = address;
            }
        }
        // LDR (immediate)
        else if (opcode >> 11 === 0b01101) {
            const imm5 = ((opcode >> 6) & 0x1f) << 2;
            const Rn = (opcode >> 3) & 0x7;
            const Rt = opcode & 0x7;
            const addr = this.registers[Rn] + imm5;
            this.cycles += this.cyclesIO(addr);
            this.registers[Rt] = this.readUint32(addr);
        }
        // LDR (sp + immediate)
        else if (opcode >> 11 === 0b10011) {
            const Rt = (opcode >> 8) & 0x7;
            const imm8 = opcode & 0xff;
            const addr = this.SP + (imm8 << 2);
            this.cycles += this.cyclesIO(addr);
            this.registers[Rt] = this.readUint32(addr);
        }
        // LDR (literal)
        else if (opcode >> 11 === 0b01001) {
            const imm8 = (opcode & 0xff) << 2;
            const Rt = (opcode >> 8) & 7;
            const nextPC = this.PC + 2;
            const addr = (nextPC & 0xfffffffc) + imm8;
            this.cycles += this.cyclesIO(addr);
            this.registers[Rt] = this.readUint32(addr);
        }
        // LDR (register)
        else if (opcode >> 9 === 0b0101100) {
            const Rm = (opcode >> 6) & 0x7;
            const Rn = (opcode >> 3) & 0x7;
            const Rt = opcode & 0x7;
            const addr = this.registers[Rm] + this.registers[Rn];
            this.cycles += this.cyclesIO(addr);
            this.registers[Rt] = this.readUint32(addr);
        }
        // LDRB (immediate)
        else if (opcode >> 11 === 0b01111) {
            const imm5 = (opcode >> 6) & 0x1f;
            const Rn = (opcode >> 3) & 0x7;
            const Rt = opcode & 0x7;
            const addr = this.registers[Rn] + imm5;
            this.cycles += this.cyclesIO(addr);
            this.registers[Rt] = this.readUint8(addr);
        }
        // LDRB (register)
        else if (opcode >> 9 === 0b0101110) {
            const Rm = (opcode >> 6) & 0x7;
            const Rn = (opcode >> 3) & 0x7;
            const Rt = opcode & 0x7;
            const addr = this.registers[Rm] + this.registers[Rn];
            this.cycles += this.cyclesIO(addr);
            this.registers[Rt] = this.readUint8(addr);
        }
        // LDRH (immediate)
        else if (opcode >> 11 === 0b10001) {
            const imm5 = (opcode >> 6) & 0x1f;
            const Rn = (opcode >> 3) & 0x7;
            const Rt = opcode & 0x7;
            const addr = this.registers[Rn] + (imm5 << 1);
            this.cycles += this.cyclesIO(addr);
            this.registers[Rt] = this.readUint16(addr);
        }
        // LDRH (register)
        else if (opcode >> 9 === 0b0101101) {
            const Rm = (opcode >> 6) & 0x7;
            const Rn = (opcode >> 3) & 0x7;
            const Rt = opcode & 0x7;
            const addr = this.registers[Rm] + this.registers[Rn];
            this.cycles += this.cyclesIO(addr);
            this.registers[Rt] = this.readUint16(addr);
        }
        // LDRSB
        else if (opcode >> 9 === 0b0101011) {
            const Rm = (opcode >> 6) & 0x7;
            const Rn = (opcode >> 3) & 0x7;
            const Rt = opcode & 0x7;
            const addr = this.registers[Rm] + this.registers[Rn];
            this.cycles += this.cyclesIO(addr);
            this.registers[Rt] = signExtend8(this.readUint8(addr));
        }
        // LDRSH
        else if (opcode >> 9 === 0b0101111) {
            const Rm = (opcode >> 6) & 0x7;
            const Rn = (opcode >> 3) & 0x7;
            const Rt = opcode & 0x7;
            const addr = this.registers[Rm] + this.registers[Rn];
            this.cycles += this.cyclesIO(addr);
            this.registers[Rt] = signExtend16(this.readUint16(addr));
        }
        // LSLS (immediate)
        else if (opcode >> 11 === 0b00000) {
            const imm5 = (opcode >> 6) & 0x1f;
            const Rm = (opcode >> 3) & 0x7;
            const Rd = opcode & 0x7;
            const input = this.registers[Rm];
            const result = input << imm5;
            this.registers[Rd] = result;
            this.N = !!(result & 0x80000000);
            this.Z = result === 0;
            this.C = imm5 ? !!(input & (1 << (32 - imm5))) : this.C;
        }
        // LSLS (register)
        else if (opcode >> 6 === 0b0100000010) {
            const Rm = (opcode >> 3) & 0x7;
            const Rdn = opcode & 0x7;
            const input = this.registers[Rdn];
            const shiftCount = this.registers[Rm] & 0xff;
            const result = shiftCount >= 32 ? 0 : input << shiftCount;
            this.registers[Rdn] = result;
            this.N = !!(result & 0x80000000);
            this.Z = result === 0;
            this.C = shiftCount ? !!(input & (1 << (32 - shiftCount))) : this.C;
        }
        // LSRS (immediate)
        else if (opcode >> 11 === 0b00001) {
            const imm5 = (opcode >> 6) & 0x1f;
            const Rm = (opcode >> 3) & 0x7;
            const Rd = opcode & 0x7;
            const input = this.registers[Rm];
            const result = imm5 ? input >>> imm5 : 0;
            this.registers[Rd] = result;
            this.N = !!(result & 0x80000000);
            this.Z = result === 0;
            this.C = !!((input >>> (imm5 ? imm5 - 1 : 31)) & 0x1);
        }
        // LSRS (register)
        else if (opcode >> 6 === 0b0100000011) {
            const Rm = (opcode >> 3) & 0x7;
            const Rdn = opcode & 0x7;
            const shiftAmount = this.registers[Rm] & 0xff;
            const input = this.registers[Rdn];
            const result = shiftAmount < 32 ? input >>> shiftAmount : 0;
            this.registers[Rdn] = result;
            this.N = !!(result & 0x80000000);
            this.Z = result === 0;
            this.C = shiftAmount <= 32 ? !!((input >>> (shiftAmount - 1)) & 0x1) : false;
        }
        // MOV
        else if (opcode >> 8 === 0b01000110) {
            const Rm = (opcode >> 3) & 0xf;
            const Rd = ((opcode >> 4) & 0x8) | (opcode & 0x7);
            let value = Rm === pcRegister ? this.PC + 2 : this.registers[Rm];
            if (Rd === pcRegister) {
                this.cycles++;
                value &= ~1;
            }
            else if (Rd === spRegister) {
                value &= ~3;
            }
            this.registers[Rd] = value;
        }
        // MOVS
        else if (opcode >> 11 === 0b00100) {
            const value = opcode & 0xff;
            const Rd = (opcode >> 8) & 7;
            this.registers[Rd] = value;
            this.N = !!(value & 0x80000000);
            this.Z = value === 0;
        }
        // MRS
        else if (opcode === 0b1111001111101111 && opcode2 >> 12 == 0b1000) {
            const SYSm = opcode2 & 0xff;
            const Rd = (opcode2 >> 8) & 0xf;
            this.registers[Rd] = this.readSpecialRegister(SYSm);
            this.PC += 2;
            this.cycles += 2;
        }
        // MSR
        else if (opcode >> 4 === 0b111100111000 && opcode2 >> 8 == 0b10001000) {
            const SYSm = opcode2 & 0xff;
            const Rn = opcode & 0xf;
            this.writeSpecialRegister(SYSm, this.registers[Rn]);
            this.PC += 2;
            this.cycles += 2;
        }
        // MULS
        else if (opcode >> 6 === 0b0100001101) {
            const Rn = (opcode >> 3) & 0x7;
            const Rdm = opcode & 0x7;
            const result = Math.imul(this.registers[Rn], this.registers[Rdm]);
            this.registers[Rdm] = result;
            this.N = !!(result & 0x80000000);
            this.Z = (result & 0xffffffff) === 0;
        }
        // MVNS
        else if (opcode >> 6 === 0b0100001111) {
            const Rm = (opcode >> 3) & 7;
            const Rd = opcode & 7;
            const result = ~this.registers[Rm];
            this.registers[Rd] = result;
            this.N = !!(result & 0x80000000);
            this.Z = result === 0;
        }
        // ORRS (Encoding T2)
        else if (opcode >> 6 === 0b0100001100) {
            const Rm = (opcode >> 3) & 0x7;
            const Rdn = opcode & 0x7;
            const result = this.registers[Rdn] | this.registers[Rm];
            this.registers[Rdn] = result;
            this.N = !!(result & 0x80000000);
            this.Z = (result & 0xffffffff) === 0;
        }
        // POP
        else if (opcode >> 9 === 0b1011110) {
            const P = (opcode >> 8) & 1;
            let address = this.SP;
            for (let i = 0; i <= 7; i++) {
                if (opcode & (1 << i)) {
                    this.registers[i] = this.readUint32(address);
                    address += 4;
                    this.cycles++;
                }
            }
            if (P) {
                this.SP = address + 4;
                this.BXWritePC(this.readUint32(address));
                this.cycles += 2;
            }
            else {
                this.SP = address;
            }
        }
        // PUSH
        else if (opcode >> 9 === 0b1011010) {
            let bitCount = 0;
            for (let i = 0; i <= 8; i++) {
                if (opcode & (1 << i)) {
                    bitCount++;
                }
            }
            let address = this.SP - 4 * bitCount;
            for (let i = 0; i <= 7; i++) {
                if (opcode & (1 << i)) {
                    this.writeUint32(address, this.registers[i]);
                    this.cycles++;
                    address += 4;
                }
            }
            if (opcode & (1 << 8)) {
                this.writeUint32(address, this.registers[14]);
            }
            this.SP -= 4 * bitCount;
        }
        // REV
        else if (opcode >> 6 === 0b1011101000) {
            const Rm = (opcode >> 3) & 0x7;
            const Rd = opcode & 0x7;
            const input = this.registers[Rm];
            this.registers[Rd] =
                ((input & 0xff) << 24) |
                    (((input >> 8) & 0xff) << 16) |
                    (((input >> 16) & 0xff) << 8) |
                    ((input >> 24) & 0xff);
        }
        // REV16
        else if (opcode >> 6 === 0b1011101001) {
            const Rm = (opcode >> 3) & 0x7;
            const Rd = opcode & 0x7;
            const input = this.registers[Rm];
            this.registers[Rd] =
                (((input >> 16) & 0xff) << 24) |
                    (((input >> 24) & 0xff) << 16) |
                    ((input & 0xff) << 8) |
                    ((input >> 8) & 0xff);
        }
        // REVSH
        else if (opcode >> 6 === 0b1011101011) {
            const Rm = (opcode >> 3) & 0x7;
            const Rd = opcode & 0x7;
            const input = this.registers[Rm];
            this.registers[Rd] = signExtend16(((input & 0xff) << 8) | ((input >> 8) & 0xff));
        }
        // ROR
        else if (opcode >> 6 === 0b0100000111) {
            const Rm = (opcode >> 3) & 0x7;
            const Rdn = opcode & 0x7;
            const input = this.registers[Rdn];
            const shift = (this.registers[Rm] & 0xff) % 32;
            const result = (input >>> shift) | (input << (32 - shift));
            this.registers[Rdn] = result;
            this.N = !!(result & 0x80000000);
            this.Z = result === 0;
            this.C = !!(result & 0x80000000);
        }
        // NEGS / RSBS
        else if (opcode >> 6 === 0b0100001001) {
            const Rn = (opcode >> 3) & 0x7;
            const Rd = opcode & 0x7;
            this.registers[Rd] = this.substractUpdateFlags(0, this.registers[Rn]);
        }
        // NOP
        else if (opcode === 0b1011111100000000) {
            // Do nothing!
        }
        // SBCS (Encoding T1)
        else if (opcode >> 6 === 0b0100000110) {
            const Rm = (opcode >> 3) & 0x7;
            const Rdn = opcode & 0x7;
            this.registers[Rdn] = this.substractUpdateFlags(this.registers[Rdn], this.registers[Rm] + (1 - (this.C ? 1 : 0)));
        }
        // SEV
        else if (opcode === 0b1011111101000000) {
            this.logger.info(LOG_NAME, 'SEV');
        }
        // STMIA
        else if (opcode >> 11 === 0b11000) {
            const Rn = (opcode >> 8) & 0x7;
            const registers = opcode & 0xff;
            let address = this.registers[Rn];
            for (let i = 0; i < 8; i++) {
                if (registers & (1 << i)) {
                    this.writeUint32(address, this.registers[i]);
                    address += 4;
                    this.cycles++;
                }
            }
            // Write back
            if (!(registers & (1 << Rn))) {
                this.registers[Rn] = address;
            }
        }
        // STR (immediate)
        else if (opcode >> 11 === 0b01100) {
            const imm5 = ((opcode >> 6) & 0x1f) << 2;
            const Rn = (opcode >> 3) & 0x7;
            const Rt = opcode & 0x7;
            const address = this.registers[Rn] + imm5;
            this.cycles += this.cyclesIO(address, true);
            this.writeUint32(address, this.registers[Rt]);
        }
        // STR (sp + immediate)
        else if (opcode >> 11 === 0b10010) {
            const Rt = (opcode >> 8) & 0x7;
            const imm8 = opcode & 0xff;
            const address = this.SP + (imm8 << 2);
            this.cycles += this.cyclesIO(address, true);
            this.writeUint32(address, this.registers[Rt]);
        }
        // STR (register)
        else if (opcode >> 9 === 0b0101000) {
            const Rm = (opcode >> 6) & 0x7;
            const Rn = (opcode >> 3) & 0x7;
            const Rt = opcode & 0x7;
            const address = this.registers[Rm] + this.registers[Rn];
            this.cycles += this.cyclesIO(address, true);
            this.writeUint32(address, this.registers[Rt]);
        }
        // STRB (immediate)
        else if (opcode >> 11 === 0b01110) {
            const imm5 = (opcode >> 6) & 0x1f;
            const Rn = (opcode >> 3) & 0x7;
            const Rt = opcode & 0x7;
            const address = this.registers[Rn] + imm5;
            this.cycles += this.cyclesIO(address, true);
            this.writeUint8(address, this.registers[Rt]);
        }
        // STRB (register)
        else if (opcode >> 9 === 0b0101010) {
            const Rm = (opcode >> 6) & 0x7;
            const Rn = (opcode >> 3) & 0x7;
            const Rt = opcode & 0x7;
            const address = this.registers[Rm] + this.registers[Rn];
            this.cycles += this.cyclesIO(address, true);
            this.writeUint8(address, this.registers[Rt]);
        }
        // STRH (immediate)
        else if (opcode >> 11 === 0b10000) {
            const imm5 = ((opcode >> 6) & 0x1f) << 1;
            const Rn = (opcode >> 3) & 0x7;
            const Rt = opcode & 0x7;
            const address = this.registers[Rn] + imm5;
            this.cycles += this.cyclesIO(address, true);
            this.writeUint16(address, this.registers[Rt]);
        }
        // STRH (register)
        else if (opcode >> 9 === 0b0101001) {
            const Rm = (opcode >> 6) & 0x7;
            const Rn = (opcode >> 3) & 0x7;
            const Rt = opcode & 0x7;
            const address = this.registers[Rm] + this.registers[Rn];
            this.cycles += this.cyclesIO(address, true);
            this.writeUint16(address, this.registers[Rt]);
        }
        // SUB (SP minus immediate)
        else if (opcode >> 7 === 0b101100001) {
            const imm32 = (opcode & 0x7f) << 2;
            this.SP -= imm32;
        }
        // SUBS (Encoding T1)
        else if (opcode >> 9 === 0b0001111) {
            const imm3 = (opcode >> 6) & 0x7;
            const Rn = (opcode >> 3) & 0x7;
            const Rd = opcode & 0x7;
            this.registers[Rd] = this.substractUpdateFlags(this.registers[Rn], imm3);
        }
        // SUBS (Encoding T2)
        else if (opcode >> 11 === 0b00111) {
            const imm8 = opcode & 0xff;
            const Rdn = (opcode >> 8) & 0x7;
            this.registers[Rdn] = this.substractUpdateFlags(this.registers[Rdn], imm8);
        }
        // SUBS (register)
        else if (opcode >> 9 === 0b0001101) {
            const Rm = (opcode >> 6) & 0x7;
            const Rn = (opcode >> 3) & 0x7;
            const Rd = opcode & 0x7;
            this.registers[Rd] = this.substractUpdateFlags(this.registers[Rn], this.registers[Rm]);
        }
        // SVC
        else if (opcode >> 8 === 0b11011111) {
            this.pendingSVCall = true;
            this.interruptsUpdated = true;
        }
        // SXTB
        else if (opcode >> 6 === 0b1011001001) {
            const Rm = (opcode >> 3) & 0x7;
            const Rd = opcode & 0x7;
            this.registers[Rd] = signExtend8(this.registers[Rm]);
        }
        // SXTH
        else if (opcode >> 6 === 0b1011001000) {
            const Rm = (opcode >> 3) & 0x7;
            const Rd = opcode & 0x7;
            this.registers[Rd] = signExtend16(this.registers[Rm]);
        }
        // TST
        else if (opcode >> 6 == 0b0100001000) {
            const Rm = (opcode >> 3) & 0x7;
            const Rn = opcode & 0x7;
            const result = this.registers[Rn] & this.registers[Rm];
            this.N = !!(result & 0x80000000);
            this.Z = result === 0;
        }
        // UDF
        else if (opcode >> 8 == 0b11011110) {
            const imm8 = opcode & 0xff;
            this.breakRewind = 2;
            this.rp2040.onBreak(imm8);
        }
        // UDF (Encoding T2)
        else if (opcode >> 4 === 0b111101111111 && opcode2 >> 12 === 0b1010) {
            const imm4 = opcode & 0xf;
            const imm12 = opcode2 & 0xfff;
            this.breakRewind = 4;
            this.rp2040.onBreak((imm4 << 12) | imm12);
            this.PC += 2;
        }
        // UXTB
        else if (opcode >> 6 == 0b1011001011) {
            const Rm = (opcode >> 3) & 0x7;
            const Rd = opcode & 0x7;
            this.registers[Rd] = this.registers[Rm] & 0xff;
        }
        // UXTH
        else if (opcode >> 6 == 0b1011001010) {
            const Rm = (opcode >> 3) & 0x7;
            const Rd = opcode & 0x7;
            this.registers[Rd] = this.registers[Rm] & 0xffff;
        }
        // WFE
        else if (opcode === 0b1011111100100000) {
            this.cycles++;
            if (this.eventRegistered) {
                this.eventRegistered = false;
            }
            else {
                this.waiting = true;
            }
        }
        // WFI
        else if (opcode === 0b1011111100110000) {
            this.cycles++;
            this.waiting = true;
        }
        // YIELD
        else if (opcode === 0b1011111100010000) {
            // do nothing for now. Wait for event!
            this.logger.info(LOG_NAME, 'Yield');
        }
        else {
            this.logger.warn(LOG_NAME, `Warning: Instruction at ${opcodePC.toString(16)} is not implemented yet!`);
            this.logger.warn(LOG_NAME, `Opcode: 0x${opcode.toString(16)} (0x${opcode2.toString(16)})`);
        }
    }
}
exports.CortexM0Core = CortexM0Core;


/***/ }),

/***/ 990:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GDBConnection = void 0;
const gdb_server_1 = __nccwpck_require__(3415);
const gdb_utils_1 = __nccwpck_require__(615);
class GDBConnection {
    constructor(server, onResponse) {
        this.server = server;
        this.onResponse = onResponse;
        this.rp2040 = this.server.rp2040;
        this.buf = '';
        server.addConnection(this);
        onResponse('+');
    }
    feedData(data) {
        const { onResponse } = this;
        if (data.charCodeAt(0) === 3) {
            this.server.info('BREAK');
            this.rp2040.stop();
            onResponse(gdb_utils_1.gdbMessage(gdb_server_1.STOP_REPLY_SIGINT));
            data = data.slice(1);
        }
        this.buf += data;
        for (;;) {
            const dolla = this.buf.indexOf('$');
            const hash = this.buf.indexOf('#', dolla + 1);
            if (dolla < 0 || hash < 0 || hash + 2 > this.buf.length) {
                return;
            }
            const cmd = this.buf.substring(dolla + 1, hash);
            const cksum = this.buf.substr(hash + 1, 2);
            this.buf = this.buf.substr(hash + 2);
            if (gdb_utils_1.gdbChecksum(cmd) !== cksum) {
                this.server.warn(`GDB checksum error in message: ${cmd}`);
                onResponse('-');
            }
            else {
                onResponse('+');
                this.server.debug(`>${cmd}`);
                const response = this.server.processGDBMessage(cmd);
                if (response) {
                    this.server.debug(`<${response}`);
                    onResponse(response);
                }
            }
        }
    }
    onBreakpoint() {
        try {
            this.onResponse(gdb_utils_1.gdbMessage(gdb_server_1.STOP_REPLY_TRAP));
        }
        catch (e) {
            this.server.removeConnection(this);
        }
    }
}
exports.GDBConnection = GDBConnection;


/***/ }),

/***/ 3415:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

/**
 * RP2040 GDB Server
 *
 * Copyright (C) 2021, Uri Shaked
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GDBServer = exports.STOP_REPLY_TRAP = exports.STOP_REPLY_SIGINT = void 0;
const cortex_m0_core_1 = __nccwpck_require__(4407);
const logging_1 = __nccwpck_require__(6057);
const gdb_utils_1 = __nccwpck_require__(615);
exports.STOP_REPLY_SIGINT = 'S02';
exports.STOP_REPLY_TRAP = 'S05';
/* string value: armv6m-none-unknown-eabi */
const lldbTriple = '61726d76366d2d6e6f6e652d756e6b6e6f776e2d65616269';
const registers = [
    `name:r0;bitsize:32;offset:0;encoding:int;format:hex;set:General Purpose Registers;generic:arg1;gcc:0;dwarf:0;`,
    `name:r1;bitsize:32;offset:4;encoding:int;format:hex;set:General Purpose Registers;generic:arg2;gcc:1;dwarf:1;`,
    `name:r2;bitsize:32;offset:8;encoding:int;format:hex;set:General Purpose Registers;generic:arg3;gcc:2;dwarf:2;`,
    `name:r3;bitsize:32;offset:12;encoding:int;format:hex;set:General Purpose Registers;generic:arg4;gcc:3;dwarf:3;`,
    `name:r4;bitsize:32;offset:16;encoding:int;format:hex;set:General Purpose Registers;gcc:4;dwarf:4;`,
    `name:r5;bitsize:32;offset:20;encoding:int;format:hex;set:General Purpose Registers;gcc:5;dwarf:5;`,
    `name:r6;bitsize:32;offset:24;encoding:int;format:hex;set:General Purpose Registers;gcc:6;dwarf:6;`,
    `name:r7;bitsize:32;offset:28;encoding:int;format:hex;set:General Purpose Registers;gcc:7;dwarf:7;`,
    `name:r8;bitsize:32;offset:32;encoding:int;format:hex;set:General Purpose Registers;gcc:8;dwarf:8;`,
    `name:r9;bitsize:32;offset:36;encoding:int;format:hex;set:General Purpose Registers;gcc:9;dwarf:9;`,
    `name:r10;bitsize:32;offset:40;encoding:int;format:hex;set:General Purpose Registers;gcc:10;dwarf:10;`,
    `name:r11;bitsize:32;offset:44;encoding:int;format:hex;set:General Purpose Registers;generic:fp;gcc:11;dwarf:11;`,
    `name:r12;bitsize:32;offset:48;encoding:int;format:hex;set:General Purpose Registers;gcc:12;dwarf:12;`,
    `name:sp;bitsize:32;offset:52;encoding:int;format:hex;set:General Purpose Registers;generic:sp;alt-name:r13;gcc:13;dwarf:13;`,
    `name:lr;bitsize:32;offset:56;encoding:int;format:hex;set:General Purpose Registers;generic:ra;alt-name:r14;gcc:14;dwarf:14;`,
    `name:pc;bitsize:32;offset:60;encoding:int;format:hex;set:General Purpose Registers;generic:pc;alt-name:r15;gcc:15;dwarf:15;`,
    `name:cpsr;bitsize:32;offset:64;encoding:int;format:hex;set:General Purpose Registers;generic:flags;alt-name:psr;gcc:16;dwarf:16;`,
];
const targetXML = `<?xml version="1.0"?>
<!DOCTYPE target SYSTEM "gdb-target.dtd">
<target version="1.0">
<architecture>arm</architecture>
<feature name="org.gnu.gdb.arm.m-profile">
<reg name="r0" bitsize="32" regnum="0" save-restore="yes" type="int" group="general"/>
<reg name="r1" bitsize="32" regnum="1" save-restore="yes" type="int" group="general"/>
<reg name="r2" bitsize="32" regnum="2" save-restore="yes" type="int" group="general"/>
<reg name="r3" bitsize="32" regnum="3" save-restore="yes" type="int" group="general"/>
<reg name="r4" bitsize="32" regnum="4" save-restore="yes" type="int" group="general"/>
<reg name="r5" bitsize="32" regnum="5" save-restore="yes" type="int" group="general"/>
<reg name="r6" bitsize="32" regnum="6" save-restore="yes" type="int" group="general"/>
<reg name="r7" bitsize="32" regnum="7" save-restore="yes" type="int" group="general"/>
<reg name="r8" bitsize="32" regnum="8" save-restore="yes" type="int" group="general"/>
<reg name="r9" bitsize="32" regnum="9" save-restore="yes" type="int" group="general"/>
<reg name="r10" bitsize="32" regnum="10" save-restore="yes" type="int" group="general"/>
<reg name="r11" bitsize="32" regnum="11" save-restore="yes" type="int" group="general"/>
<reg name="r12" bitsize="32" regnum="12" save-restore="yes" type="int" group="general"/>
<reg name="sp" bitsize="32" regnum="13" save-restore="yes" type="data_ptr" group="general"/>
<reg name="lr" bitsize="32" regnum="14" save-restore="yes" type="int" group="general"/>
<reg name="pc" bitsize="32" regnum="15" save-restore="yes" type="code_ptr" group="general"/>
<reg name="xPSR" bitsize="32" regnum="16" save-restore="yes" type="int" group="general"/>
</feature>
<feature name="org.gnu.gdb.arm.m-system">
<reg name="msp" bitsize="32" regnum="17" save-restore="yes" type="data_ptr" group="system"/>
<reg name="psp" bitsize="32" regnum="18" save-restore="yes" type="data_ptr" group="system"/>
<reg name="primask" bitsize="1" regnum="19" save-restore="yes" type="int8" group="system"/>
<reg name="basepri" bitsize="8" regnum="20" save-restore="yes" type="int8" group="system"/>
<reg name="faultmask" bitsize="1" regnum="21" save-restore="yes" type="int8" group="system"/>
<reg name="control" bitsize="2" regnum="22" save-restore="yes" type="int8" group="system"/>
</feature>
</target>`;
const LOG_NAME = 'GDBServer';
class GDBServer {
    constructor(rp2040) {
        this.rp2040 = rp2040;
        this.logger = new logging_1.ConsoleLogger(logging_1.LogLevel.Warn, true);
        this.connections = new Set();
    }
    processGDBMessage(cmd) {
        const { rp2040 } = this;
        const { core } = rp2040;
        if (cmd === 'Hg0') {
            return gdb_utils_1.gdbMessage('OK');
        }
        switch (cmd[0]) {
            case '?':
                return gdb_utils_1.gdbMessage(exports.STOP_REPLY_TRAP);
            case 'q':
                // Query things
                if (cmd.startsWith('qSupported:')) {
                    return gdb_utils_1.gdbMessage('PacketSize=4000;vContSupported+;qXfer:features:read+');
                }
                if (cmd === 'qAttached') {
                    return gdb_utils_1.gdbMessage('1');
                }
                if (cmd.startsWith('qXfer:features:read:target.xml')) {
                    return gdb_utils_1.gdbMessage('l' + targetXML);
                }
                if (cmd.startsWith('qRegisterInfo')) {
                    const index = parseInt(cmd.substring(13), 16);
                    const register = registers[index];
                    if (register) {
                        return gdb_utils_1.gdbMessage(register);
                    }
                    else {
                        return gdb_utils_1.gdbMessage(`E45`);
                    }
                }
                if (cmd === 'qHostInfo') {
                    return gdb_utils_1.gdbMessage(`triple:${lldbTriple};endian:little;ptrsize:4;`);
                }
                if (cmd === 'qProcessInfo') {
                    return gdb_utils_1.gdbMessage('pid:1;endian:little;ptrsize:4;');
                }
                return gdb_utils_1.gdbMessage('');
            case 'v':
                if (cmd === 'vCont?') {
                    return gdb_utils_1.gdbMessage('vCont;c;C;s;S');
                }
                if (cmd.startsWith('vCont;c')) {
                    if (!rp2040.executing) {
                        rp2040.execute();
                    }
                    return;
                }
                if (cmd.startsWith('vCont;s')) {
                    rp2040.step();
                    const registerStatus = [];
                    for (let i = 0; i < 17; i++) {
                        const value = i === 16 ? core.xPSR : core.registers[i];
                        registerStatus.push(`${gdb_utils_1.encodeHexByte(i)}:${gdb_utils_1.encodeHexUint32(value)}`);
                    }
                    return gdb_utils_1.gdbMessage(`T05${registerStatus.join(';')};reason:trace;`);
                }
                break;
            case 'c':
                if (!rp2040.executing) {
                    rp2040.execute();
                }
                return gdb_utils_1.gdbMessage('OK');
            case 'g': {
                // Read registers
                const buf = new Uint32Array(17);
                buf.set(core.registers);
                buf[16] = core.xPSR;
                return gdb_utils_1.gdbMessage(gdb_utils_1.encodeHexBuf(new Uint8Array(buf.buffer)));
            }
            case 'p': {
                // Read register
                const registerIndex = parseInt(cmd.substr(1), 16);
                if (registerIndex >= 0 && registerIndex <= 15) {
                    return gdb_utils_1.gdbMessage(gdb_utils_1.encodeHexUint32(core.registers[registerIndex]));
                }
                const specialRegister = (sysm) => gdb_utils_1.gdbMessage(gdb_utils_1.encodeHexUint32(core.readSpecialRegister(sysm)));
                switch (registerIndex) {
                    case 0x10:
                        return gdb_utils_1.gdbMessage(gdb_utils_1.encodeHexUint32(core.xPSR));
                    case 0x11:
                        return specialRegister(cortex_m0_core_1.SYSM_MSP);
                    case 0x12:
                        return specialRegister(cortex_m0_core_1.SYSM_PSP);
                    case 0x13:
                        return specialRegister(cortex_m0_core_1.SYSM_PRIMASK);
                    case 0x14:
                        this.logger.warn(LOG_NAME, 'TODO BASEPRI');
                        return gdb_utils_1.gdbMessage(gdb_utils_1.encodeHexUint32(0)); // TODO BASEPRI
                    case 0x15:
                        this.logger.warn(LOG_NAME, 'TODO faultmask');
                        return gdb_utils_1.gdbMessage(gdb_utils_1.encodeHexUint32(0)); // TODO faultmask
                    case 0x16:
                        return specialRegister(cortex_m0_core_1.SYSM_CONTROL);
                }
                break;
            }
            case 'P': {
                // Write register
                const params = cmd.substr(1).split('=');
                const registerIndex = parseInt(params[0], 16);
                const registerValue = params[1].trim();
                const registerBytes = registerIndex > 0x12 ? 1 : 4;
                const decodedValue = gdb_utils_1.decodeHexBuf(registerValue);
                if (registerIndex < 0 || registerIndex > 0x16 || decodedValue.length !== registerBytes) {
                    return gdb_utils_1.gdbMessage('E00');
                }
                const valueBuffer = new Uint8Array(4);
                valueBuffer.set(decodedValue.slice(0, 4));
                const value = new DataView(valueBuffer.buffer).getUint32(0, true);
                switch (registerIndex) {
                    case 0x10:
                        core.xPSR = value;
                        break;
                    case 0x11:
                        core.writeSpecialRegister(cortex_m0_core_1.SYSM_MSP, value);
                        break;
                    case 0x12:
                        core.writeSpecialRegister(cortex_m0_core_1.SYSM_PSP, value);
                        break;
                    case 0x13:
                        core.writeSpecialRegister(cortex_m0_core_1.SYSM_PRIMASK, value);
                        break;
                    case 0x14:
                        this.logger.warn(LOG_NAME, 'TODO BASEPRI');
                        break; // TODO BASEPRI
                    case 0x15:
                        this.logger.warn(LOG_NAME, 'TODO faultmask');
                        break; // TODO faultmask
                    case 0x16:
                        core.writeSpecialRegister(cortex_m0_core_1.SYSM_CONTROL, value);
                        break;
                    default:
                        core.registers[registerIndex] = value;
                        break;
                }
                return gdb_utils_1.gdbMessage('OK');
            }
            case 'm': {
                // Read memory
                const params = cmd.substr(1).split(',');
                const address = parseInt(params[0], 16);
                const length = parseInt(params[1], 16);
                let result = '';
                for (let i = 0; i < length; i++) {
                    result += gdb_utils_1.encodeHexByte(rp2040.readUint8(address + i));
                }
                return gdb_utils_1.gdbMessage(result);
            }
            case 'M': {
                // Write memory
                const params = cmd.substr(1).split(/[,:]/);
                const address = parseInt(params[0], 16);
                const length = parseInt(params[1], 16);
                const data = gdb_utils_1.decodeHexBuf(params[2].substr(0, length * 2));
                for (let i = 0; i < data.length; i++) {
                    this.debug(`Write ${data[i].toString(16)} to ${(address + i).toString(16)}`);
                    rp2040.writeUint8(address + i, data[i]);
                }
                return gdb_utils_1.gdbMessage('OK');
            }
        }
        return gdb_utils_1.gdbMessage('');
    }
    addConnection(connection) {
        this.connections.add(connection);
        this.rp2040.onBreak = () => {
            this.rp2040.stop();
            this.rp2040.core.PC -= this.rp2040.core.breakRewind;
            for (const connection of this.connections) {
                connection.onBreakpoint();
            }
        };
    }
    removeConnection(connection) {
        this.connections.delete(connection);
    }
    debug(msg) {
        this.logger.debug(LOG_NAME, msg);
    }
    info(msg) {
        this.logger.info(LOG_NAME, msg);
    }
    warn(msg) {
        this.logger.warn(LOG_NAME, msg);
    }
    error(msg) {
        this.logger.error(LOG_NAME, msg);
    }
}
exports.GDBServer = GDBServer;


/***/ }),

/***/ 615:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.gdbMessage = exports.gdbChecksum = exports.decodeHexUint32 = exports.decodeHexUint32Array = exports.decodeHexBuf = exports.encodeHexUint32 = exports.encodeHexUint32BE = exports.encodeHexBuf = exports.encodeHexByte = void 0;
function encodeHexByte(value) {
    return (value >> 4).toString(16) + (value & 0xf).toString(16);
}
exports.encodeHexByte = encodeHexByte;
function encodeHexBuf(buf) {
    return Array.from(buf).map(encodeHexByte).join('');
}
exports.encodeHexBuf = encodeHexBuf;
function encodeHexUint32BE(value) {
    return encodeHexBuf(new Uint8Array([(value >> 24) & 0xff, (value >> 16) & 0xff, (value >> 8) & 0xff, value & 0xff]));
}
exports.encodeHexUint32BE = encodeHexUint32BE;
function encodeHexUint32(value) {
    const buf = new Uint32Array([value]);
    return encodeHexBuf(new Uint8Array(buf.buffer));
}
exports.encodeHexUint32 = encodeHexUint32;
function decodeHexBuf(encoded) {
    const result = new Uint8Array(encoded.length / 2);
    for (let i = 0; i < result.length; i++) {
        result[i] = parseInt(encoded.substr(i * 2, 2), 16);
    }
    return result;
}
exports.decodeHexBuf = decodeHexBuf;
function decodeHexUint32Array(encoded) {
    return new Uint32Array(decodeHexBuf(encoded).buffer);
}
exports.decodeHexUint32Array = decodeHexUint32Array;
function decodeHexUint32(encoded) {
    return decodeHexUint32Array(encoded)[0];
}
exports.decodeHexUint32 = decodeHexUint32;
function gdbChecksum(text) {
    const value = text
        .split('')
        .map((c) => c.charCodeAt(0))
        .reduce((a, b) => a + b, 0) & 0xff;
    return encodeHexByte(value);
}
exports.gdbChecksum = gdbChecksum;
function gdbMessage(value) {
    return `$${value}#${gdbChecksum(value)}`;
}
exports.gdbMessage = gdbMessage;


/***/ }),

/***/ 1810:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GPIOPin = exports.FUNCTION_PIO1 = exports.FUNCTION_PIO0 = exports.FUNCTION_SIO = exports.FUNCTION_PWM = exports.GPIOPinState = void 0;
const pio_1 = __nccwpck_require__(514);
var GPIOPinState;
(function (GPIOPinState) {
    GPIOPinState[GPIOPinState["Low"] = 0] = "Low";
    GPIOPinState[GPIOPinState["High"] = 1] = "High";
    GPIOPinState[GPIOPinState["Input"] = 2] = "Input";
    GPIOPinState[GPIOPinState["InputPullUp"] = 3] = "InputPullUp";
    GPIOPinState[GPIOPinState["InputPullDown"] = 4] = "InputPullDown";
})(GPIOPinState = exports.GPIOPinState || (exports.GPIOPinState = {}));
exports.FUNCTION_PWM = 4;
exports.FUNCTION_SIO = 5;
exports.FUNCTION_PIO0 = 6;
exports.FUNCTION_PIO1 = 7;
function applyOverride(value, overrideType) {
    switch (overrideType) {
        case 0:
            return value;
        case 1:
            return !value;
        case 2:
            return false;
        case 3:
            return true;
    }
    console.error('applyOverride received invalid override type', overrideType);
    return value;
}
const IRQ_EDGE_HIGH = 1 << 3;
const IRQ_EDGE_LOW = 1 << 2;
const IRQ_LEVEL_HIGH = 1 << 1;
const IRQ_LEVEL_LOW = 1 << 0;
class GPIOPin {
    constructor(rp2040, index, name = index.toString()) {
        this.rp2040 = rp2040;
        this.index = index;
        this.name = name;
        this.rawInputValue = false;
        this.lastValue = this.value;
        this.ctrl = 0x1f;
        this.padValue = 0b0110110;
        this.irqEnableMask = 0;
        this.irqForceMask = 0;
        this.irqStatus = 0;
        this.listeners = new Set();
    }
    get rawInterrupt() {
        return !!((this.irqStatus & this.irqEnableMask) | this.irqForceMask);
    }
    get isSlewFast() {
        return !!(this.padValue & 1);
    }
    get schmittEnabled() {
        return !!(this.padValue & 2);
    }
    get pulldownEnabled() {
        return !!(this.padValue & 4);
    }
    get pullupEnabled() {
        return !!(this.padValue & 8);
    }
    get driveStrength() {
        return (this.padValue >> 4) & 0x3;
    }
    get inputEnable() {
        return !!(this.padValue & 0x40);
    }
    get outputDisable() {
        return !!(this.padValue & 0x80);
    }
    get functionSelect() {
        return this.ctrl & 0x1f;
    }
    get outputOverride() {
        return (this.ctrl >> 8) & 0x3;
    }
    get outputEnableOverride() {
        return (this.ctrl >> 12) & 0x3;
    }
    get inputOverride() {
        return (this.ctrl >> 16) & 0x3;
    }
    get irqOverride() {
        return (this.ctrl >> 28) & 0x3;
    }
    get rawOutputEnable() {
        const { index, rp2040, functionSelect } = this;
        const bitmask = 1 << index;
        switch (functionSelect) {
            case exports.FUNCTION_PWM:
                return !!(rp2040.pwm.gpioDirection & bitmask);
            case exports.FUNCTION_SIO:
                return !!(rp2040.sio.gpioOutputEnable & bitmask);
            case exports.FUNCTION_PIO0:
                return !!(rp2040.pio[0].pinDirections & bitmask);
            case exports.FUNCTION_PIO1:
                return !!(rp2040.pio[1].pinDirections & bitmask);
            default:
                return false;
        }
    }
    get rawOutputValue() {
        const { index, rp2040, functionSelect } = this;
        const bitmask = 1 << index;
        switch (functionSelect) {
            case exports.FUNCTION_PWM:
                return !!(rp2040.pwm.gpioValue & bitmask);
            case exports.FUNCTION_SIO:
                return !!(rp2040.sio.gpioValue & bitmask);
            case exports.FUNCTION_PIO0:
                return !!(rp2040.pio[0].pinValues & bitmask);
            case exports.FUNCTION_PIO1:
                return !!(rp2040.pio[1].pinValues & bitmask);
            default:
                return false;
        }
    }
    get inputValue() {
        return applyOverride(this.rawInputValue && this.inputEnable, this.inputOverride);
    }
    get irqValue() {
        return applyOverride(this.rawInterrupt, this.irqOverride);
    }
    get outputEnable() {
        return applyOverride(this.rawOutputEnable, this.outputEnableOverride);
    }
    get outputValue() {
        return applyOverride(this.rawOutputValue, this.outputOverride);
    }
    /**
     * Returns the STATUS register value for the pin, as outlined in section 2.19.6 of the datasheet
     */
    get status() {
        const irqToProc = this.irqValue ? 1 << 26 : 0;
        const irqFromPad = this.rawInterrupt ? 1 << 24 : 0;
        const inToPeri = this.inputValue ? 1 << 19 : 0;
        const inFromPad = this.rawInputValue ? 1 << 17 : 0;
        const oeToPad = this.outputEnable ? 1 << 13 : 0;
        const oeFromPeri = this.rawOutputEnable ? 1 << 12 : 0;
        const outToPad = this.outputValue ? 1 << 9 : 0;
        const outFromPeri = this.rawOutputValue ? 1 << 8 : 0;
        return (irqToProc | irqFromPad | inToPeri | inFromPad | oeToPad | oeFromPeri | outToPad | outFromPeri);
    }
    get value() {
        if (this.outputEnable) {
            return this.outputValue ? GPIOPinState.High : GPIOPinState.Low;
        }
        else {
            // TODO: check what happens when we enable both pullup/pulldown
            if (this.pulldownEnabled) {
                return GPIOPinState.InputPullDown;
            }
            if (this.pullupEnabled) {
                return GPIOPinState.InputPullUp;
            }
            return GPIOPinState.Input;
        }
    }
    setInputValue(value) {
        this.rawInputValue = value;
        const prevIrqValue = this.irqValue;
        if (value && this.inputEnable) {
            this.irqStatus |= IRQ_EDGE_HIGH | IRQ_LEVEL_HIGH;
            this.irqStatus &= ~IRQ_LEVEL_LOW;
        }
        else {
            this.irqStatus |= IRQ_EDGE_LOW | IRQ_LEVEL_LOW;
            this.irqStatus &= ~IRQ_LEVEL_HIGH;
        }
        if (this.irqValue !== prevIrqValue) {
            this.rp2040.updateIOInterrupt();
        }
        if (this.functionSelect === exports.FUNCTION_PWM) {
            this.rp2040.pwm.gpioOnInput(this.index);
        }
        for (const pio of this.rp2040.pio) {
            for (const machine of pio.machines) {
                if (machine.enabled &&
                    machine.waiting &&
                    machine.waitType === pio_1.WaitType.Pin &&
                    machine.waitIndex === this.index) {
                    machine.checkWait();
                }
            }
        }
    }
    checkForUpdates() {
        const { lastValue, value } = this;
        if (value !== lastValue) {
            this.lastValue = value;
            for (const listener of this.listeners) {
                listener(value, lastValue);
            }
        }
    }
    refreshInput() {
        this.setInputValue(this.rawInputValue);
    }
    updateIRQValue(value) {
        if (value & IRQ_EDGE_LOW && this.irqStatus & IRQ_EDGE_LOW) {
            this.irqStatus &= ~IRQ_EDGE_LOW;
            this.rp2040.updateIOInterrupt();
        }
        if (value & IRQ_EDGE_HIGH && this.irqStatus & IRQ_EDGE_HIGH) {
            this.irqStatus &= ~IRQ_EDGE_HIGH;
            this.rp2040.updateIOInterrupt();
        }
    }
    addListener(callback) {
        this.listeners.add(callback);
        return () => this.listeners.delete(callback);
    }
}
exports.GPIOPin = GPIOPin;


/***/ }),

/***/ 8904:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogLevel = exports.ConsoleLogger = exports.setDeviceConfigurationPacket = exports.setDeviceAddressPacket = exports.getDescriptorPacket = exports.createSetupPacket = exports.SetupType = exports.SetupRequest = exports.SetupRecipient = exports.DescriptorType = exports.DataDirection = exports.USBCDC = exports.RP2040 = exports.RPUSBController = exports.I2CMode = exports.I2CSpeed = exports.RPI2C = exports.BasePeripheral = exports.GPIOPinState = exports.GPIOPin = exports.GDBServer = exports.GDBConnection = void 0;
var gdb_connection_1 = __nccwpck_require__(990);
Object.defineProperty(exports, "GDBConnection", ({ enumerable: true, get: function () { return gdb_connection_1.GDBConnection; } }));
var gdb_server_1 = __nccwpck_require__(3415);
Object.defineProperty(exports, "GDBServer", ({ enumerable: true, get: function () { return gdb_server_1.GDBServer; } }));
var gpio_pin_1 = __nccwpck_require__(1810);
Object.defineProperty(exports, "GPIOPin", ({ enumerable: true, get: function () { return gpio_pin_1.GPIOPin; } }));
Object.defineProperty(exports, "GPIOPinState", ({ enumerable: true, get: function () { return gpio_pin_1.GPIOPinState; } }));
var peripheral_1 = __nccwpck_require__(4223);
Object.defineProperty(exports, "BasePeripheral", ({ enumerable: true, get: function () { return peripheral_1.BasePeripheral; } }));
var i2c_1 = __nccwpck_require__(8563);
Object.defineProperty(exports, "RPI2C", ({ enumerable: true, get: function () { return i2c_1.RPI2C; } }));
Object.defineProperty(exports, "I2CSpeed", ({ enumerable: true, get: function () { return i2c_1.I2CSpeed; } }));
Object.defineProperty(exports, "I2CMode", ({ enumerable: true, get: function () { return i2c_1.I2CMode; } }));
var usb_1 = __nccwpck_require__(5626);
Object.defineProperty(exports, "RPUSBController", ({ enumerable: true, get: function () { return usb_1.RPUSBController; } }));
var rp2040_1 = __nccwpck_require__(1038);
Object.defineProperty(exports, "RP2040", ({ enumerable: true, get: function () { return rp2040_1.RP2040; } }));
var cdc_1 = __nccwpck_require__(9631);
Object.defineProperty(exports, "USBCDC", ({ enumerable: true, get: function () { return cdc_1.USBCDC; } }));
var interfaces_1 = __nccwpck_require__(285);
Object.defineProperty(exports, "DataDirection", ({ enumerable: true, get: function () { return interfaces_1.DataDirection; } }));
Object.defineProperty(exports, "DescriptorType", ({ enumerable: true, get: function () { return interfaces_1.DescriptorType; } }));
Object.defineProperty(exports, "SetupRecipient", ({ enumerable: true, get: function () { return interfaces_1.SetupRecipient; } }));
Object.defineProperty(exports, "SetupRequest", ({ enumerable: true, get: function () { return interfaces_1.SetupRequest; } }));
Object.defineProperty(exports, "SetupType", ({ enumerable: true, get: function () { return interfaces_1.SetupType; } }));
var setup_1 = __nccwpck_require__(8603);
Object.defineProperty(exports, "createSetupPacket", ({ enumerable: true, get: function () { return setup_1.createSetupPacket; } }));
Object.defineProperty(exports, "getDescriptorPacket", ({ enumerable: true, get: function () { return setup_1.getDescriptorPacket; } }));
Object.defineProperty(exports, "setDeviceAddressPacket", ({ enumerable: true, get: function () { return setup_1.setDeviceAddressPacket; } }));
Object.defineProperty(exports, "setDeviceConfigurationPacket", ({ enumerable: true, get: function () { return setup_1.setDeviceConfigurationPacket; } }));
var logging_1 = __nccwpck_require__(6057);
Object.defineProperty(exports, "ConsoleLogger", ({ enumerable: true, get: function () { return logging_1.ConsoleLogger; } }));
Object.defineProperty(exports, "LogLevel", ({ enumerable: true, get: function () { return logging_1.LogLevel; } }));


/***/ }),

/***/ 5033:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Interpolator = exports.InterpolatorConfig = void 0;
const bit_1 = __nccwpck_require__(92);
class InterpolatorConfig {
    constructor(value) {
        this.shift = 0;
        this.maskLSB = 0;
        this.maskMSB = 0;
        this.signed = false;
        this.crossInput = false;
        this.crossResult = false;
        this.addRaw = false;
        this.forceMSB = 0;
        this.blend = false;
        this.clamp = false;
        this.overf0 = false;
        this.overf1 = false;
        this.overf = false;
        this.shift = (value >>> 0) & 0b11111;
        this.maskLSB = (value >>> 5) & 0b11111;
        this.maskMSB = (value >>> 10) & 0b11111;
        this.signed = Boolean((value >>> 15) & 1);
        this.crossInput = Boolean((value >>> 16) & 1);
        this.crossResult = Boolean((value >>> 17) & 1);
        this.addRaw = Boolean((value >>> 18) & 1);
        this.forceMSB = (value >>> 19) & 0b11;
        this.blend = Boolean((value >>> 21) & 1);
        this.clamp = Boolean((value >>> 22) & 1);
        this.overf0 = Boolean((value >>> 23) & 1);
        this.overf1 = Boolean((value >>> 24) & 1);
        this.overf = Boolean((value >>> 25) & 1);
    }
    toUint32() {
        return (((this.shift & 0b11111) << 0) |
            ((this.maskLSB & 0b11111) << 5) |
            ((this.maskMSB & 0b11111) << 10) |
            ((Number(this.signed) & 1) << 15) |
            ((Number(this.crossInput) & 1) << 16) |
            ((Number(this.crossResult) & 1) << 17) |
            ((Number(this.addRaw) & 1) << 18) |
            ((this.forceMSB & 0b11) << 19) |
            ((Number(this.blend) & 1) << 21) |
            ((Number(this.clamp) & 1) << 22) |
            ((Number(this.overf0) & 1) << 23) |
            ((Number(this.overf1) & 1) << 24) |
            ((Number(this.overf) & 1) << 25));
    }
}
exports.InterpolatorConfig = InterpolatorConfig;
class Interpolator {
    constructor(index) {
        this.index = index;
        this.accum0 = 0;
        this.accum1 = 0;
        this.base0 = 0;
        this.base1 = 0;
        this.base2 = 0;
        this.ctrl0 = 0;
        this.ctrl1 = 0;
        this.result0 = 0;
        this.result1 = 0;
        this.result2 = 0;
        this.smresult0 = 0;
        this.smresult1 = 0;
        this.update();
    }
    update() {
        const N = this.index;
        const ctrl0 = new InterpolatorConfig(this.ctrl0);
        const ctrl1 = new InterpolatorConfig(this.ctrl1);
        const do_clamp = ctrl0.clamp && N == 1;
        const do_blend = ctrl0.blend && N == 0;
        ctrl0.clamp = do_clamp;
        ctrl0.blend = do_blend;
        ctrl1.clamp = false;
        ctrl1.blend = false;
        ctrl1.overf0 = false;
        ctrl1.overf1 = false;
        ctrl1.overf = false;
        const input0 = bit_1.s32(ctrl0.crossInput ? this.accum1 : this.accum0);
        const input1 = bit_1.s32(ctrl1.crossInput ? this.accum0 : this.accum1);
        const msbmask0 = ctrl0.maskMSB == 31 ? 0xffffffff : (1 << (ctrl0.maskMSB + 1)) - 1;
        const msbmask1 = ctrl1.maskMSB == 31 ? 0xffffffff : (1 << (ctrl1.maskMSB + 1)) - 1;
        const mask0 = msbmask0 & ~((1 << ctrl0.maskLSB) - 1);
        const mask1 = msbmask1 & ~((1 << ctrl1.maskLSB) - 1);
        const uresult0 = (input0 >>> ctrl0.shift) & mask0;
        const uresult1 = (input1 >>> ctrl1.shift) & mask1;
        const overf0 = Boolean((input0 >>> ctrl0.shift) & ~msbmask0);
        const overf1 = Boolean((input1 >>> ctrl1.shift) & ~msbmask1);
        const overf = overf0 || overf1;
        const sextmask0 = uresult0 & (1 << ctrl0.maskMSB) ? -1 << ctrl0.maskMSB : 0;
        const sextmask1 = uresult1 & (1 << ctrl1.maskMSB) ? -1 << ctrl1.maskMSB : 0;
        const sresult0 = uresult0 | sextmask0;
        const sresult1 = uresult1 | sextmask1;
        const result0 = ctrl0.signed ? sresult0 : uresult0;
        const result1 = ctrl1.signed ? sresult1 : uresult1;
        const addresult0 = this.base0 + (ctrl0.addRaw ? input0 : result0);
        const addresult1 = this.base1 + (ctrl1.addRaw ? input1 : result1);
        const addresult2 = this.base2 + result0 + (do_blend ? 0 : result1);
        const uclamp0 = bit_1.u32(result0) < bit_1.u32(this.base0)
            ? this.base0
            : bit_1.u32(result0) > bit_1.u32(this.base1)
                ? this.base1
                : result0;
        const sclamp0 = bit_1.s32(result0) < bit_1.s32(this.base0)
            ? this.base0
            : bit_1.s32(result0) > bit_1.s32(this.base1)
                ? this.base1
                : result0;
        const clamp0 = ctrl0.signed ? sclamp0 : uclamp0;
        const alpha1 = result1 & 0xff;
        const ublend1 = bit_1.u32(this.base0) + (Math.floor((alpha1 * (bit_1.u32(this.base1) - bit_1.u32(this.base0))) / 256) | 0);
        const sblend1 = bit_1.s32(this.base0) + (Math.floor((alpha1 * (bit_1.s32(this.base1) - bit_1.s32(this.base0))) / 256) | 0);
        const blend1 = ctrl1.signed ? sblend1 : ublend1;
        this.smresult0 = bit_1.u32(result0);
        this.smresult1 = bit_1.u32(result1);
        this.result0 = bit_1.u32(do_blend ? alpha1 : (do_clamp ? clamp0 : addresult0) | (ctrl0.forceMSB << 28));
        this.result1 = bit_1.u32((do_blend ? blend1 : addresult1) | (ctrl0.forceMSB << 28));
        this.result2 = bit_1.u32(addresult2);
        ctrl0.overf0 = overf0;
        ctrl0.overf1 = overf1;
        ctrl0.overf = overf;
        this.ctrl0 = ctrl0.toUint32();
        this.ctrl1 = ctrl1.toUint32();
    }
    writeback() {
        const ctrl0 = new InterpolatorConfig(this.ctrl0);
        const ctrl1 = new InterpolatorConfig(this.ctrl1);
        this.accum0 = bit_1.u32(ctrl0.crossResult ? this.result1 : this.result0);
        this.accum1 = bit_1.u32(ctrl1.crossResult ? this.result0 : this.result1);
        this.update();
    }
    setBase01(value) {
        const N = this.index;
        const ctrl0 = new InterpolatorConfig(this.ctrl0);
        const ctrl1 = new InterpolatorConfig(this.ctrl1);
        const do_blend = ctrl0.blend && N == 0;
        const input0 = value & 0xffff;
        const input1 = (value >>> 16) & 0xffff;
        const sextmask0 = input0 & (1 << 15) ? -1 << 15 : 0;
        const sextmask1 = input1 & (1 << 15) ? -1 << 15 : 0;
        const base0 = (do_blend ? ctrl1.signed : ctrl0.signed) ? input0 | sextmask0 : input0;
        const base1 = ctrl1.signed ? input1 | sextmask1 : input1;
        this.base0 = bit_1.u32(base0);
        this.base1 = bit_1.u32(base1);
        this.update();
    }
}
exports.Interpolator = Interpolator;


/***/ }),

/***/ 679:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MAX_HARDWARE_IRQ = exports.IRQ = void 0;
var IRQ;
(function (IRQ) {
    IRQ[IRQ["TIMER_0"] = 0] = "TIMER_0";
    IRQ[IRQ["TIMER_1"] = 1] = "TIMER_1";
    IRQ[IRQ["TIMER_2"] = 2] = "TIMER_2";
    IRQ[IRQ["TIMER_3"] = 3] = "TIMER_3";
    IRQ[IRQ["PWM_WRAP"] = 4] = "PWM_WRAP";
    IRQ[IRQ["USBCTRL"] = 5] = "USBCTRL";
    IRQ[IRQ["XIP"] = 6] = "XIP";
    IRQ[IRQ["PIO0_IRQ0"] = 7] = "PIO0_IRQ0";
    IRQ[IRQ["PIO0_IRQ1"] = 8] = "PIO0_IRQ1";
    IRQ[IRQ["PIO1_IRQ0"] = 9] = "PIO1_IRQ0";
    IRQ[IRQ["PIO1_IRQ1"] = 10] = "PIO1_IRQ1";
    IRQ[IRQ["DMA_IRQ0"] = 11] = "DMA_IRQ0";
    IRQ[IRQ["DMA_IRQ1"] = 12] = "DMA_IRQ1";
    IRQ[IRQ["IO_BANK0"] = 13] = "IO_BANK0";
    IRQ[IRQ["IO_QSPI"] = 14] = "IO_QSPI";
    IRQ[IRQ["SIO_PROC0"] = 15] = "SIO_PROC0";
    IRQ[IRQ["SIO_PROC1"] = 16] = "SIO_PROC1";
    IRQ[IRQ["CLOCKS"] = 17] = "CLOCKS";
    IRQ[IRQ["SPI0"] = 18] = "SPI0";
    IRQ[IRQ["SPI1"] = 19] = "SPI1";
    IRQ[IRQ["UART0"] = 20] = "UART0";
    IRQ[IRQ["UART1"] = 21] = "UART1";
    IRQ[IRQ["ADC_FIFO"] = 22] = "ADC_FIFO";
    IRQ[IRQ["I2C0"] = 23] = "I2C0";
    IRQ[IRQ["I2C1"] = 24] = "I2C1";
    IRQ[IRQ["RTC"] = 25] = "RTC";
})(IRQ = exports.IRQ || (exports.IRQ = {}));
exports.MAX_HARDWARE_IRQ = IRQ.RTC;


/***/ }),

/***/ 5826:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RPADC = void 0;
const irq_1 = __nccwpck_require__(679);
const fifo_1 = __nccwpck_require__(4677);
const dma_1 = __nccwpck_require__(1253);
const peripheral_1 = __nccwpck_require__(4223);
const CS = 0x00; // ADC Control and Status
const RESULT = 0x04; // Result of most recent ADC conversion
const FCS = 0x08; // FIFO control and status
const FIFO_REG = 0x0c; // Conversion result FIFO
const DIV = 0x10; // Clock divider.0x14 INTR Raw Interrupts
const INTR = 0x14; // Raw Interrupts
const INTE = 0x18; // Interrupt Enable
const INTF = 0x1c; // Interrupt Force
const INTS = 0x20; // Interrupt status after masking & forcing
// CS bits
const CS_RROBIN_MASK = 0x1f;
const CS_RROBIN_SHIFT = 16;
const CS_AINSEL_MASK = 0x7;
const CS_AINSEL_SHIFT = 12;
const CS_ERR_STICKY = 1 << 10;
const CS_ERR = 1 << 9;
const CS_READY = 1 << 8;
const CS_START_MANY = 1 << 3;
const CS_START_ONE = 1 << 2;
const CS_TS_EN = 1 << 1;
const CS_EN = 1 << 0;
const CS_WRITE_MASK = (CS_RROBIN_MASK << CS_RROBIN_SHIFT) |
    (CS_AINSEL_MASK << CS_AINSEL_SHIFT) |
    CS_START_MANY |
    CS_START_ONE |
    CS_TS_EN |
    CS_EN;
// FCS bits
const FCS_THRES_MASK = 0xf;
const FCS_THRESH_SHIFT = 24;
const FCS_LEVEL_MASK = 0xf;
const FCS_LEVEL_SHIFT = 16;
const FCS_OVER = 1 << 11;
const FCS_UNDER = 1 << 10;
const FCS_FULL = 1 << 9;
const FCS_EMPTY = 1 << 8;
const FCS_DREQ_EN = 1 << 3;
const FCS_ERR = 1 << 2;
const FCS_SHIFT = 1 << 1;
const FCS_EN = 1 << 0;
const FCS_WRITE_MASK = (FCS_THRES_MASK << FCS_THRESH_SHIFT) | FCS_DREQ_EN | FCS_ERR | FCS_SHIFT | FCS_EN;
// FIFO_REG bits
const FIFO_ERR = 1 << 15;
// DIV bits
const DIV_INT_MASK = 0xffff;
const DIV_INT_SHIFT = 8;
const DIV_FRAC_MASK = 0xff;
const DIV_FRAC_SHIFT = 0;
// Interrupt bits
const FIFO_INT = 1 << 0;
class RPADC extends peripheral_1.BasePeripheral {
    constructor(rp2040, name) {
        super(rp2040, name);
        /* Number of ADC channels */
        this.numChannels = 5;
        /** ADC resolution (in bits) */
        this.resolution = 12;
        /** Time to read a single sample, in microseconds */
        this.sampleTime = 2;
        /**
         * ADC Channel values. Channels 0...3 are connected to GPIO 26...29, and channel 4 is connected to the built-in
         * temperature sensor: T=27-(ADC_voltage-0.706)/0.001721.
         *
         * Changing the values will change the ADC reading, unless you override onADCRead() with a custom implementation.
         */
        this.channelValues = [0, 0, 0, 0, 0];
        /**
         * Invoked whenever the emulated code performs an ADC read.
         *
         * The default implementation reads the result from the `channelValues` array, and then calls
         * completeADCRead() after `sampleTime` milliseconds.
         *
         * If you override the default implementation, make sure to call `completeADCRead()` after
         * `sampleTime` milliseconds (or else the ADC read will never complete).
         */
        this.onADCRead = (channel) => {
            // Default implementation
            this.rp2040.clock.createTimer(this.sampleTime, () => this.completeADCRead(this.channelValues[channel], false));
        };
        this.fifo = new fifo_1.FIFO(4);
        this.dreq = dma_1.DREQChannel.DREQ_ADC;
        // Registers
        this.cs = 0;
        this.fcs = 0;
        this.clockDiv = 0;
        this.intEnable = 0;
        this.intForce = 0;
        this.result = 0;
        // Status
        this.busy = false;
        this.err = false;
    }
    get temperatueEnable() {
        return this.cs & CS_TS_EN;
    }
    get enabled() {
        return this.cs & CS_EN;
    }
    get divider() {
        return (1 +
            ((this.clockDiv >> DIV_INT_SHIFT) & DIV_INT_MASK) +
            ((this.clockDiv >> DIV_FRAC_SHIFT) & DIV_FRAC_MASK) / 256);
    }
    get intRaw() {
        const thres = (this.fcs >> FCS_THRESH_SHIFT) & FCS_THRES_MASK;
        return this.fifo.itemCount >= thres ? FIFO_INT : 0;
    }
    get intStatus() {
        return (this.intRaw & this.intEnable) | this.intForce;
    }
    get activeChannel() {
        return (this.cs >> CS_AINSEL_SHIFT) & CS_AINSEL_MASK;
    }
    set activeChannel(channel) {
        this.cs &= ~(CS_AINSEL_MASK << CS_AINSEL_SHIFT);
        this.cs |= (channel & CS_AINSEL_SHIFT) << CS_AINSEL_SHIFT;
    }
    checkInterrupts() {
        this.rp2040.setInterrupt(irq_1.IRQ.ADC_FIFO, !!this.intStatus);
    }
    startADCRead() {
        this.busy = true;
        this.onADCRead(this.activeChannel);
    }
    updateDMA() {
        if (this.fcs & FCS_DREQ_EN) {
            const thres = (this.fcs >> FCS_THRESH_SHIFT) & FCS_THRES_MASK;
            if (this.fifo.itemCount >= thres) {
                this.rp2040.dma.setDREQ(this.dreq);
            }
            else {
                this.rp2040.dma.clearDREQ(this.dreq);
            }
        }
    }
    completeADCRead(value, error) {
        this.busy = false;
        this.result = value;
        if (error) {
            this.cs |= CS_ERR_STICKY | CS_ERR;
        }
        else {
            this.cs &= ~CS_ERR;
        }
        // FIFO
        if (this.fcs & FCS_EN) {
            if (this.fifo.full) {
                this.fcs |= FCS_OVER;
            }
            else {
                value &= 0xfff; // 12 bits
                if (this.fcs & FCS_SHIFT) {
                    value >>= 4;
                }
                if (error && this.fcs & FCS_ERR) {
                    value |= FIFO_ERR;
                }
                this.fifo.push(value);
                this.updateDMA();
                this.checkInterrupts();
            }
        }
        // Round-robin
        const round = (this.cs >> CS_RROBIN_SHIFT) & CS_RROBIN_MASK;
        if (round) {
            let channel = this.activeChannel + 1;
            while (!(round & (1 << channel))) {
                channel = (channel + 1) % this.numChannels;
            }
            this.activeChannel = channel;
        }
        // Multi-shot conversions
        if (this.cs & CS_START_MANY) {
            const clockMHZ = 48;
            const sampleTicks = clockMHZ * this.sampleTime;
            if (this.divider > sampleTicks) {
                // clock runs at 48MHz, subtract 2uS
                const micros = (this.divider - sampleTicks) / clockMHZ;
                this.rp2040.clock.createTimer(micros, () => {
                    if (this.cs & CS_START_MANY) {
                        this.startADCRead();
                    }
                });
            }
            else {
                this.startADCRead();
            }
        }
    }
    readUint32(offset) {
        switch (offset) {
            case CS:
                return this.cs | (this.err ? CS_ERR : 0) | (this.busy ? 0 : CS_READY);
            case RESULT:
                return this.result;
            case FCS:
                return (this.fcs |
                    ((this.fifo.itemCount & FCS_LEVEL_MASK) << FCS_LEVEL_SHIFT) |
                    (this.fifo.full ? FCS_FULL : 0) |
                    (this.fifo.empty ? FCS_EMPTY : 0));
            case FIFO_REG:
                if (this.fifo.empty) {
                    this.fcs |= FCS_UNDER;
                    return 0;
                }
                else {
                    const value = this.fifo.pull();
                    this.updateDMA();
                    return value;
                }
            case DIV:
                return this.clockDiv;
            case INTR:
                return this.intRaw;
            case INTE:
                return this.intEnable;
            case INTF:
                return this.intForce;
            case INTS:
                return this.intStatus;
        }
        return super.readUint32(offset);
    }
    writeUint32(offset, value) {
        switch (offset) {
            case CS:
                this.fcs &= ~(value & CS_ERR_STICKY); // Write-clear bits
                this.cs = (this.cs & ~CS_WRITE_MASK) | (value & CS_WRITE_MASK);
                if (value & CS_EN && !this.busy && (value & CS_START_ONE || value & CS_START_MANY)) {
                    this.startADCRead();
                }
                break;
            case FCS:
                this.fcs &= ~(value & (FCS_OVER | FCS_UNDER)); // Write-clear bits
                this.fcs = (this.fcs & ~FCS_WRITE_MASK) | (value & FCS_WRITE_MASK);
                this.checkInterrupts();
                break;
            case DIV:
                this.clockDiv = value;
                break;
            case INTE:
                this.intEnable = value & FIFO_INT;
                this.checkInterrupts();
                break;
            case INTF:
                this.intForce = value & FIFO_INT;
                this.checkInterrupts();
                break;
            default:
                super.writeUint32(offset, value);
        }
    }
}
exports.RPADC = RPADC;


/***/ }),

/***/ 2135:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RPClocks = void 0;
const peripheral_1 = __nccwpck_require__(4223);
const CLK_REF_CTRL = 0x30;
const CLK_REF_SELECTED = 0x38;
const CLK_SYS_CTRL = 0x3c;
const CLK_SYS_SELECTED = 0x44;
class RPClocks extends peripheral_1.BasePeripheral {
    constructor(rp2040, name) {
        super(rp2040, name);
        this.refCtrl = 0;
        this.sysCtrl = 0;
    }
    readUint32(offset) {
        switch (offset) {
            case CLK_REF_CTRL:
                return this.refCtrl;
            case CLK_REF_SELECTED:
                return 1 << (this.refCtrl & 0x03);
            case CLK_SYS_CTRL:
                return this.sysCtrl;
            case CLK_SYS_SELECTED:
                return 1 << (this.sysCtrl & 0x01);
        }
        return super.readUint32(offset);
    }
    writeUint32(offset, value) {
        switch (offset) {
            case CLK_REF_CTRL:
                this.refCtrl = value;
                break;
            case CLK_SYS_CTRL:
                this.sysCtrl = value;
                break;
            default:
                super.writeUint32(offset, value);
                break;
        }
    }
}
exports.RPClocks = RPClocks;


/***/ }),

/***/ 1253:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RPDMA = exports.RPDMAChannel = exports.DREQChannel = void 0;
const irq_1 = __nccwpck_require__(679);
const peripheral_1 = __nccwpck_require__(4223);
var DREQChannel;
(function (DREQChannel) {
    DREQChannel[DREQChannel["DREQ_PIO0_TX0"] = 0] = "DREQ_PIO0_TX0";
    DREQChannel[DREQChannel["DREQ_PIO0_TX1"] = 1] = "DREQ_PIO0_TX1";
    DREQChannel[DREQChannel["DREQ_PIO0_TX2"] = 2] = "DREQ_PIO0_TX2";
    DREQChannel[DREQChannel["DREQ_PIO0_TX3"] = 3] = "DREQ_PIO0_TX3";
    DREQChannel[DREQChannel["DREQ_PIO0_RX0"] = 4] = "DREQ_PIO0_RX0";
    DREQChannel[DREQChannel["DREQ_PIO0_RX1"] = 5] = "DREQ_PIO0_RX1";
    DREQChannel[DREQChannel["DREQ_PIO0_RX2"] = 6] = "DREQ_PIO0_RX2";
    DREQChannel[DREQChannel["DREQ_PIO0_RX3"] = 7] = "DREQ_PIO0_RX3";
    DREQChannel[DREQChannel["DREQ_PIO1_TX0"] = 8] = "DREQ_PIO1_TX0";
    DREQChannel[DREQChannel["DREQ_PIO1_TX1"] = 9] = "DREQ_PIO1_TX1";
    DREQChannel[DREQChannel["DREQ_PIO1_TX2"] = 10] = "DREQ_PIO1_TX2";
    DREQChannel[DREQChannel["DREQ_PIO1_TX3"] = 11] = "DREQ_PIO1_TX3";
    DREQChannel[DREQChannel["DREQ_PIO1_RX0"] = 12] = "DREQ_PIO1_RX0";
    DREQChannel[DREQChannel["DREQ_PIO1_RX1"] = 13] = "DREQ_PIO1_RX1";
    DREQChannel[DREQChannel["DREQ_PIO1_RX2"] = 14] = "DREQ_PIO1_RX2";
    DREQChannel[DREQChannel["DREQ_PIO1_RX3"] = 15] = "DREQ_PIO1_RX3";
    DREQChannel[DREQChannel["DREQ_SPI0_TX"] = 16] = "DREQ_SPI0_TX";
    DREQChannel[DREQChannel["DREQ_SPI0_RX"] = 17] = "DREQ_SPI0_RX";
    DREQChannel[DREQChannel["DREQ_SPI1_TX"] = 18] = "DREQ_SPI1_TX";
    DREQChannel[DREQChannel["DREQ_SPI1_RX"] = 19] = "DREQ_SPI1_RX";
    DREQChannel[DREQChannel["DREQ_UART0_TX"] = 20] = "DREQ_UART0_TX";
    DREQChannel[DREQChannel["DREQ_UART0_RX"] = 21] = "DREQ_UART0_RX";
    DREQChannel[DREQChannel["DREQ_UART1_TX"] = 22] = "DREQ_UART1_TX";
    DREQChannel[DREQChannel["DREQ_UART1_RX"] = 23] = "DREQ_UART1_RX";
    DREQChannel[DREQChannel["DREQ_PWM_WRAP0"] = 24] = "DREQ_PWM_WRAP0";
    DREQChannel[DREQChannel["DREQ_PWM_WRAP1"] = 25] = "DREQ_PWM_WRAP1";
    DREQChannel[DREQChannel["DREQ_PWM_WRAP2"] = 26] = "DREQ_PWM_WRAP2";
    DREQChannel[DREQChannel["DREQ_PWM_WRAP3"] = 27] = "DREQ_PWM_WRAP3";
    DREQChannel[DREQChannel["DREQ_PWM_WRAP4"] = 28] = "DREQ_PWM_WRAP4";
    DREQChannel[DREQChannel["DREQ_PWM_WRAP5"] = 29] = "DREQ_PWM_WRAP5";
    DREQChannel[DREQChannel["DREQ_PWM_WRAP6"] = 30] = "DREQ_PWM_WRAP6";
    DREQChannel[DREQChannel["DREQ_PWM_WRAP7"] = 31] = "DREQ_PWM_WRAP7";
    DREQChannel[DREQChannel["DREQ_I2C0_TX"] = 32] = "DREQ_I2C0_TX";
    DREQChannel[DREQChannel["DREQ_I2C0_RX"] = 33] = "DREQ_I2C0_RX";
    DREQChannel[DREQChannel["DREQ_I2C1_TX"] = 34] = "DREQ_I2C1_TX";
    DREQChannel[DREQChannel["DREQ_I2C1_RX"] = 35] = "DREQ_I2C1_RX";
    DREQChannel[DREQChannel["DREQ_ADC"] = 36] = "DREQ_ADC";
    DREQChannel[DREQChannel["DREQ_XIP_STREAM"] = 37] = "DREQ_XIP_STREAM";
    DREQChannel[DREQChannel["DREQ_XIP_SSITX"] = 38] = "DREQ_XIP_SSITX";
    DREQChannel[DREQChannel["DREQ_XIP_SSIRX"] = 39] = "DREQ_XIP_SSIRX";
    DREQChannel[DREQChannel["DREQ_MAX"] = 40] = "DREQ_MAX";
})(DREQChannel = exports.DREQChannel || (exports.DREQChannel = {}));
var TREQ;
(function (TREQ) {
    TREQ[TREQ["Timer0"] = 59] = "Timer0";
    TREQ[TREQ["Timer1"] = 60] = "Timer1";
    TREQ[TREQ["Timer2"] = 61] = "Timer2";
    TREQ[TREQ["Timer3"] = 62] = "Timer3";
    TREQ[TREQ["Permanent"] = 63] = "Permanent";
})(TREQ || (TREQ = {}));
// Per-channel registers
const CHn_READ_ADDR = 0x000; // DMA Channel n Read Address pointer
const CHn_WRITE_ADDR = 0x004; // DMA Channel n Write Address pointer
const CHn_TRANS_COUNT = 0x008; // DMA Channel n Transfer Count
const CHn_CTRL_TRIG = 0x00c; // DMA Channel n Control and Status
const CHn_AL1_CTRL = 0x010; // Alias for channel n CTRL register
const CHn_AL1_READ_ADDR = 0x014; // Alias for channel n READ_ADDR register
const CHn_AL1_WRITE_ADDR = 0x018; // Alias for channel n WRITE_ADDR register
const CHn_AL1_TRANS_COUNT_TRIG = 0x01c; // Alias for channel n TRANS_COUNT register
const CHn_AL2_CTRL = 0x020; // Alias for channel n CTRL register
const CHn_AL2_TRANS_COUNT = 0x024; // Alias for channel n TRANS_COUNT register
const CHn_AL2_READ_ADDR = 0x028; // Alias for channel n READ_ADDR register
const CHn_AL2_WRITE_ADDR_TRIG = 0x02c; // Alias for channel n WRITE_ADDR register
const CHn_AL3_CTRL = 0x030; // Alias for channel n CTRL register
const CHn_AL3_WRITE_ADDR = 0x034; // Alias for channel n WRITE_ADDR register
const CHn_AL3_TRANS_COUNT = 0x038; // Alias for channel n TRANS_COUNT register
const CHn_AL3_READ_ADDR_TRIG = 0x03c; // Alias for channel n READ_ADDR register
const CHn_DBG_CTDREQ = 0x800;
const CHn_DBG_TCR = 0x804;
const CHANNEL_REGISTERS_SIZE = 12 * 0x40;
const CHANNEL_REGISTERS_MASK = 0x83f;
// General DMA registers
const INTR = 0x400; // Interrupt Status (raw)
const INTE0 = 0x404; // Interrupt Enables for IRQ 0
const INTF0 = 0x408; // Force Interrupts
const INTS0 = 0x40c; // Interrupt Status for IRQ 0
const INTE1 = 0x414; // Interrupt Enables for IRQ 1
const INTF1 = 0x418; // Force Interrupts for IRQ 1
const INTS1 = 0x41c; // Interrupt Status (masked) for IRQ 1
const TIMER0 = 0x420; // Pacing (X/Y) Fractional Timer
const TIMER1 = 0x424; // Pacing (X/Y) Fractional Timer
const TIMER2 = 0x428; // Pacing (X/Y) Fractional Timer
const TIMER3 = 0x42c; // Pacing (X/Y) Fractional Timer
const MULTI_CHAN_TRIGGER = 0x430; // Trigger one or more channels simultaneously
const SNIFF_CTRL = 0x434; // Sniffer Control
const SNIFF_DATA = 0x438; // Data accumulator for sniff hardware
const FIFO_LEVELS = 0x440; // Debug RAF, WAF, TDF levels
const CHAN_ABORT = 0x444; // Abort an in-progress transfer sequence on one or more channels
const N_CHANNELS = 0x448;
// CHn_CTRL_TRIG bits
const AHB_ERROR = 1 << 31;
const READ_ERROR = 1 << 30;
const WRITE_ERROR = 1 << 29;
const BUSY = 1 << 24;
const SNIFF_EN = 1 << 23;
const BSWAP = 1 << 22;
const IRQ_QUIET = 1 << 21;
const TREQ_SEL_MASK = 0x3f;
const TREQ_SEL_SHIFT = 15;
const CHAIN_TO_MASK = 0xf;
const CHAIN_TO_SHIFT = 11;
const RING_SEL = 1 << 10;
const RING_SIZE_MASK = 0xf;
const RING_SIZE_SHIFT = 6;
const INCR_WRITE = 1 << 5;
const INCR_READ = 1 << 4;
const DATA_SIZE_MASK = 0x3;
const DATA_SIZE_SHIFT = 2;
const HIGH_PRIORITY = 1 << 1;
const EN = 1 << 0;
const CHn_CTRL_TRIG_WRITE_MASK = 0xffffff;
const CHn_CTRL_TRIG_WC_MASK = READ_ERROR | WRITE_ERROR;
class RPDMAChannel {
    constructor(dma, rp2040, index) {
        this.dma = dma;
        this.rp2040 = rp2040;
        this.index = index;
        this.ctrl = 0;
        this.readAddr = 0;
        this.writeAddr = 0;
        this.transCount = 0;
        this.dreqCounter = 0;
        this.transCountReload = 0;
        this.treqValue = 0;
        this.dataSize = 1;
        this.chainTo = 0;
        this.ringMask = 0;
        this.transferFn = () => 0;
        this.transferTimer = null;
        this.transfer8 = () => {
            const { rp2040 } = this;
            rp2040.writeUint8(this.writeAddr, rp2040.readUint8(this.readAddr));
        };
        this.transfer16 = () => {
            const { rp2040 } = this;
            rp2040.writeUint16(this.writeAddr, rp2040.readUint16(this.readAddr));
        };
        this.transferSwap16 = () => {
            const { rp2040 } = this;
            const input = rp2040.readUint16(this.readAddr);
            rp2040.writeUint16(this.writeAddr, ((input & 0xff) << 8) | (input >> 8));
        };
        this.transfer32 = () => {
            const { rp2040 } = this;
            rp2040.writeUint32(this.writeAddr, rp2040.readUint32(this.readAddr));
        };
        this.transferSwap32 = () => {
            const { rp2040 } = this;
            const input = rp2040.readUint32(this.readAddr);
            rp2040.writeUint32(this.writeAddr, ((input & 0x000000ff) << 24) |
                ((input & 0x0000ff00) << 8) |
                ((input & 0x00ff0000) >> 8) |
                ((input >> 24) & 0xff));
        };
        this.transfer = () => {
            var _a;
            const { ctrl, dataSize, ringMask } = this;
            this.transferTimer = null;
            this.transferFn();
            if (ctrl & INCR_READ) {
                if (ringMask && !(ctrl & RING_SEL)) {
                    this.readAddr = (this.readAddr & ~ringMask) | ((this.readAddr + dataSize) & ringMask);
                }
                else {
                    this.readAddr += dataSize;
                }
            }
            if (ctrl & INCR_WRITE) {
                if (ringMask && ctrl & RING_SEL) {
                    this.writeAddr = (this.writeAddr & ~ringMask) | ((this.writeAddr + dataSize) & ringMask);
                }
                else {
                    this.writeAddr += dataSize;
                }
            }
            this.transCount--;
            if (this.transCount > 0) {
                this.scheduleTransfer();
            }
            else {
                this.ctrl &= ~BUSY;
                if (!(this.ctrl & IRQ_QUIET)) {
                    this.dma.intRaw |= 1 << this.index;
                    this.dma.checkInterrupts();
                }
                if (this.chainTo !== this.index) {
                    (_a = this.dma.channels[this.chainTo]) === null || _a === void 0 ? void 0 : _a.start();
                }
            }
        };
        this.reset();
    }
    start() {
        if (!(this.ctrl & EN) || this.ctrl & BUSY) {
            return;
        }
        this.ctrl |= BUSY;
        this.transCount = this.transCountReload;
        if (this.transCount) {
            this.scheduleTransfer();
        }
    }
    get treq() {
        return this.treqValue;
    }
    get active() {
        return this.ctrl & EN && this.ctrl & BUSY;
    }
    scheduleTransfer() {
        if (this.transferTimer) {
            // Already scheduled; do nothing.
            return;
        }
        if (this.dma.dreq[this.treqValue] || this.treqValue === TREQ.Permanent) {
            this.transferTimer = this.rp2040.clock.createTimer(0, this.transfer);
        }
        else {
            const delay = this.dma.getTimer(this.treqValue);
            if (delay) {
                this.transferTimer = this.rp2040.clock.createTimer(delay, this.transfer);
            }
        }
    }
    abort() {
        this.ctrl &= ~BUSY;
        if (this.transferTimer) {
            this.rp2040.clock.deleteTimer(this.transferTimer);
            this.transferTimer = null;
        }
    }
    readUint32(offset) {
        switch (offset) {
            case CHn_READ_ADDR:
            case CHn_AL1_READ_ADDR:
            case CHn_AL2_READ_ADDR:
            case CHn_AL3_READ_ADDR_TRIG:
                return this.readAddr;
            case CHn_WRITE_ADDR:
            case CHn_AL1_WRITE_ADDR:
            case CHn_AL2_WRITE_ADDR_TRIG:
            case CHn_AL3_WRITE_ADDR:
                return this.writeAddr;
            case CHn_TRANS_COUNT:
            case CHn_AL1_TRANS_COUNT_TRIG:
            case CHn_AL2_TRANS_COUNT:
            case CHn_AL3_TRANS_COUNT:
                return this.transCount;
            case CHn_CTRL_TRIG:
            case CHn_AL1_CTRL:
            case CHn_AL2_CTRL:
            case CHn_AL3_CTRL:
                return this.ctrl;
            case CHn_DBG_CTDREQ:
                return this.dreqCounter;
            case CHn_DBG_TCR:
                return this.transCountReload;
        }
        return 0;
    }
    writeUint32(offset, value) {
        switch (offset) {
            case CHn_READ_ADDR:
            case CHn_AL1_READ_ADDR:
            case CHn_AL2_READ_ADDR:
            case CHn_AL3_READ_ADDR_TRIG:
                this.readAddr = value;
                break;
            case CHn_WRITE_ADDR:
            case CHn_AL1_WRITE_ADDR:
            case CHn_AL2_WRITE_ADDR_TRIG:
            case CHn_AL3_WRITE_ADDR:
                this.writeAddr = value;
                break;
            case CHn_TRANS_COUNT:
            case CHn_AL1_TRANS_COUNT_TRIG:
            case CHn_AL2_TRANS_COUNT:
            case CHn_AL3_TRANS_COUNT:
                this.transCountReload = value;
                break;
            case CHn_CTRL_TRIG:
            case CHn_AL1_CTRL:
            case CHn_AL2_CTRL:
            case CHn_AL3_CTRL: {
                this.ctrl = (this.ctrl & ~CHn_CTRL_TRIG_WRITE_MASK) | (value & CHn_CTRL_TRIG_WRITE_MASK);
                this.ctrl &= ~(value & CHn_CTRL_TRIG_WC_MASK); // Handle write-clear (WC) bits
                this.treqValue = (this.ctrl >> TREQ_SEL_SHIFT) & TREQ_SEL_MASK;
                this.chainTo = (this.ctrl >> CHAIN_TO_SHIFT) & CHAIN_TO_MASK;
                const ringSize = (this.ctrl >> RING_SIZE_SHIFT) & RING_SIZE_MASK;
                this.ringMask = ringSize ? (1 << ringSize) - 1 : 0;
                switch ((this.ctrl >> DATA_SIZE_SHIFT) & DATA_SIZE_MASK) {
                    case 1:
                        this.dataSize = 2;
                        this.transferFn = this.ctrl & BSWAP ? this.transferSwap16 : this.transfer16;
                        break;
                    case 2:
                        this.dataSize = 4;
                        this.transferFn = this.ctrl & BSWAP ? this.transferSwap32 : this.transfer32;
                        break;
                    case 0:
                    default:
                        this.transferFn = this.transfer8;
                        this.dataSize = 1;
                }
                if (this.ctrl & EN && this.ctrl & BUSY) {
                    this.scheduleTransfer();
                }
                if (!(this.ctrl & EN) && this.transferTimer) {
                    this.rp2040.clock.deleteTimer(this.transferTimer);
                    this.transferTimer = null;
                }
                break;
            }
            case CHn_DBG_CTDREQ:
                this.dreqCounter = 0;
                break;
        }
        if (offset === CHn_AL3_READ_ADDR_TRIG ||
            offset === CHn_AL2_WRITE_ADDR_TRIG ||
            offset === CHn_AL1_TRANS_COUNT_TRIG ||
            offset === CHn_CTRL_TRIG) {
            if (value) {
                this.start();
            }
            else if (this.ctrl & IRQ_QUIET) {
                // Null trigger interrupts
                this.dma.intRaw |= 1 << this.index;
                this.dma.checkInterrupts();
            }
        }
    }
    reset() {
        this.writeUint32(CHn_CTRL_TRIG, this.index << CHAIN_TO_SHIFT);
    }
}
exports.RPDMAChannel = RPDMAChannel;
class RPDMA extends peripheral_1.BasePeripheral {
    constructor() {
        super(...arguments);
        this.channels = [
            new RPDMAChannel(this, this.rp2040, 0),
            new RPDMAChannel(this, this.rp2040, 1),
            new RPDMAChannel(this, this.rp2040, 2),
            new RPDMAChannel(this, this.rp2040, 3),
            new RPDMAChannel(this, this.rp2040, 4),
            new RPDMAChannel(this, this.rp2040, 5),
            new RPDMAChannel(this, this.rp2040, 6),
            new RPDMAChannel(this, this.rp2040, 7),
            new RPDMAChannel(this, this.rp2040, 8),
            new RPDMAChannel(this, this.rp2040, 9),
            new RPDMAChannel(this, this.rp2040, 10),
            new RPDMAChannel(this, this.rp2040, 11),
        ];
        this.intRaw = 0;
        this.intEnable0 = 0;
        this.intForce0 = 0;
        this.intEnable1 = 0;
        this.intForce1 = 0;
        this.timer0 = 0;
        this.timer1 = 0;
        this.timer2 = 0;
        this.timer3 = 0;
        this.dreq = Array(DREQChannel.DREQ_MAX);
    }
    get intStatus0() {
        return (this.intRaw & this.intEnable0) | this.intForce0;
    }
    get intStatus1() {
        return (this.intRaw & this.intEnable1) | this.intForce1;
    }
    readUint32(offset) {
        if ((offset & 0x7ff) <= CHANNEL_REGISTERS_SIZE) {
            const channelIndex = (offset & 0x7ff) >> 6;
            return this.channels[channelIndex].readUint32(offset & CHANNEL_REGISTERS_MASK);
        }
        switch (offset) {
            case TIMER0:
                return this.timer0;
            case TIMER1:
                return this.timer1;
            case TIMER2:
                return this.timer2;
            case TIMER3:
                return this.timer3;
            case INTR:
                return this.intRaw;
            case INTE0:
                return this.intEnable0;
            case INTF0:
                return this.intForce0;
            case INTS0:
                return this.intStatus0;
            case INTE1:
                return this.intEnable1;
            case INTF1:
                return this.intForce1;
            case INTS1:
                return this.intStatus1;
            case N_CHANNELS:
                return this.channels.length;
        }
        return super.readUint32(offset);
    }
    writeUint32(offset, value) {
        if ((offset & 0x7ff) <= CHANNEL_REGISTERS_SIZE) {
            const channelIndex = (offset & 0x7ff) >> 6;
            this.channels[channelIndex].writeUint32(offset & CHANNEL_REGISTERS_MASK, value);
            return;
        }
        switch (offset) {
            case TIMER0:
                this.timer0 = value;
                return;
            case TIMER1:
                this.timer1 = value;
                return;
            case TIMER2:
                this.timer2 = value;
                return;
            case TIMER3:
                this.timer3 = value;
                return;
            case INTR:
            case INTS0:
            case INTS1:
                this.intRaw &= ~this.rawWriteValue;
                this.checkInterrupts();
                return;
            case INTE0:
                this.intEnable0 = value & 0xffff;
                this.checkInterrupts();
                return;
            case INTF0:
                this.intForce0 = value & 0xffff;
                this.checkInterrupts();
                return;
            case INTE1:
                this.intEnable1 = value & 0xffff;
                this.checkInterrupts();
                return;
            case INTF1:
                this.intForce1 = value & 0xffff;
                this.checkInterrupts();
                return;
            case MULTI_CHAN_TRIGGER:
                for (const chan of this.channels) {
                    if (value & (1 << chan.index)) {
                        chan.start();
                    }
                }
                return;
            case CHAN_ABORT:
                for (const chan of this.channels) {
                    if (value & (1 << chan.index)) {
                        chan.abort();
                    }
                }
                return;
            default:
                super.writeUint32(offset, value);
        }
    }
    setDREQ(dreqChannel) {
        const { dreq } = this;
        if (!dreq[dreqChannel]) {
            dreq[dreqChannel] = true;
            for (const channel of this.channels) {
                if (channel.treq === dreqChannel && channel.active) {
                    channel.scheduleTransfer();
                }
            }
        }
    }
    clearDREQ(dreqChannel) {
        this.dreq[dreqChannel] = false;
    }
    /**
     * Returns the number of microseconds for a cycle of the given DMA timer, or 0 if the timer is disabled.
     */
    getTimer(treq) {
        let dividend = 0, divisor = 1;
        switch (treq) {
            case TREQ.Permanent:
                dividend = 1;
                divisor = 1;
                break;
            case TREQ.Timer0:
                dividend = this.timer0 >>> 16;
                divisor = this.timer0 & 0xffff;
                break;
            case TREQ.Timer1:
                dividend = this.timer1 >>> 16;
                divisor = this.timer1 & 0xffff;
                break;
            case TREQ.Timer2:
                dividend = this.timer2 >>> 16;
                divisor = this.timer2 & 0xffff;
                break;
            case TREQ.Timer3:
                dividend = this.timer3 >>> 36;
                divisor = this.timer3 & 0xffff;
                break;
        }
        if (divisor === 0) {
            return 0;
        }
        return ((dividend / divisor) * 1e6) / this.rp2040.clkSys;
    }
    checkInterrupts() {
        this.rp2040.setInterrupt(irq_1.IRQ.DMA_IRQ0, !!this.intStatus0);
        this.rp2040.setInterrupt(irq_1.IRQ.DMA_IRQ1, !!this.intStatus1);
    }
}
exports.RPDMA = RPDMA;


/***/ }),

/***/ 8563:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RPI2C = exports.I2CSpeed = exports.I2CMode = void 0;
const fifo_1 = __nccwpck_require__(4677);
const peripheral_1 = __nccwpck_require__(4223);
const IC_CON = 0x00; // I2C Control Register
const IC_TAR = 0x04; // I2C Target Address Register
const IC_SAR = 0x08; // I2C Slave Address Register
const IC_DATA_CMD = 0x10; // I2C Rx/Tx Data Buffer and Command Register
const IC_SS_SCL_HCNT = 0x14; // Standard Speed I2C Clock SCL High Count Register
const IC_SS_SCL_LCNT = 0x18; // Standard Speed I2C Clock SCL Low Count Register
const IC_FS_SCL_HCNT = 0x1c; // Fast Mode or Fast Mode Plus I2C Clock SCL High Count Register
const IC_FS_SCL_LCNT = 0x20; // Fast Mode or Fast Mode Plus I2C Clock SCL Low Count Register
const IC_INTR_STAT = 0x2c; // I2C Interrupt Status Register
const IC_INTR_MASK = 0x30; // I2C Interrupt Mask Register
const IC_RAW_INTR_STAT = 0x34; // I2C Raw Interrupt Status Register
const IC_RX_TL = 0x38; // I2C Receive FIFO Threshold Register
const IC_TX_TL = 0x3c; // I2C Transmit FIFO Threshold Register
const IC_CLR_INTR = 0x40; // Clear Combined and Individual Interrupt Register
const IC_CLR_RX_UNDER = 0x44; // Clear RX_UNDER Interrupt Register
const IC_CLR_RX_OVER = 0x48; // Clear RX_OVER Interrupt Register
const IC_CLR_TX_OVER = 0x4c; // Clear TX_OVER Interrupt Register
const IC_CLR_RD_REQ = 0x50; // Clear RD_REQ Interrupt Register
const IC_CLR_TX_ABRT = 0x54; // Clear TX_ABRT Interrupt Register
const IC_CLR_RX_DONE = 0x58; // Clear RX_DONE Interrupt Register
const IC_CLR_ACTIVITY = 0x5c; // Clear ACTIVITY Interrupt Register
const IC_CLR_STOP_DET = 0x60; // Clear STOP_DET Interrupt Register
const IC_CLR_START_DET = 0x64; // Clear START_DET Interrupt Register
const IC_CLR_GEN_CALL = 0x68; // Clear GEN_CALL Interrupt Register
const IC_ENABLE = 0x6c; // I2C ENABLE Register
const IC_STATUS = 0x70; // I2C STATUS Register
const IC_TXFLR = 0x74; // I2C Transmit FIFO Level Register
const IC_RXFLR = 0x78; // I2C Receive FIFO Level Register
const IC_SDA_HOLD = 0x7c; // I2C SDA Hold Time Length Register
const IC_TX_ABRT_SOURCE = 0x80; // I2C Transmit Abort Source Register
const IC_SLV_DATA_NACK_ONLY = 0x84; // Generate Slave Data NACK Register
const IC_DMA_CR = 0x88; // DMA Control Register
const IC_DMA_TDLR = 0x8c; // DMA Transmit Data Level Register
const IC_DMA_RDLR = 0x90; // DMA Transmit Data Level Register
const IC_SDA_SETUP = 0x94; // I2C SDA Setup Register
const IC_ACK_GENERAL_CALL = 0x98; // I2C ACK General Call Register
const IC_ENABLE_STATUS = 0x9c; // I2C Enable Status Register
const IC_FS_SPKLEN = 0xa0; // I2C SS, FS or FM+ spike suppression limit
const IC_CLR_RESTART_DET = 0xa8; // Clear RESTART_DET Interrupt Register
const IC_COMP_PARAM_1 = 0xf4; // Component Parameter Register 1
const IC_COMP_VERSION = 0xf8; // I2C Component Version Register
const IC_COMP_TYPE = 0xfc; // I2C Component Type Register
// IC_CON bits:
const STOP_DET_IF_MASTER_ACTIVE = 1 << 10;
const RX_FIFO_FULL_HLD_CTRL = 1 << 9;
const TX_EMPTY_CTRL = 1 << 8;
const STOP_DET_IFADDRESSED = 1 << 7;
const IC_SLAVE_DISABLE = 1 << 6;
const IC_RESTART_EN = 1 << 5;
const IC_10BITADDR_MASTER = 1 << 4;
const IC_10BITADDR_SLAVE = 1 << 3;
const SPEED_SHIFT = 1;
const SPEED_MASK = 0x3;
const MASTER_MODE = 1 << 0;
// IC_TAR bits:
const SPECIAL = 1 << 11;
const GC_OR_START = 1 << 10;
// IC_STATUS bits:
const SLV_ACTIVITY = 1 << 6;
const MST_ACTIVITY = 1 << 5;
const RFF = 1 << 4;
const RFNE = 1 << 3;
const TFE = 1 << 2;
const TFNF = 1 << 1;
const ACTIVITY = 1 << 0;
// IC_ENABLE bits:
const TX_CMD_BLOCK = 1 << 2;
const ABORT = 1 << 1;
const ENABLE = 1 << 0;
// IC_TX_ABRT_SOURCE bits:
const TX_FLUSH_CNT_MASK = 0x1ff;
const TX_FLUSH_CNT_SHIFT = 23;
const ABRT_USER_ABRT = 1 << 16;
const ABRT_SLVRD_INT = 1 << 15;
const ABRT_SLV_ARBLOST = 1 << 14;
const ABRT_SLVFLUSH_TXFIFO = 1 << 13;
const ARB_LOST = 1 << 12;
const ABRT_MASTER_DIS = 1 << 11;
const ABRT_10B_RD_NORSTRT = 1 << 10;
const ABRT_SBYTE_NORSTRT = 1 << 9;
const ABRT_HS_NORSTRT = 1 << 8;
const ABRT_SBYTE_ACKDET = 1 << 7;
const ABRT_HS_ACKDET = 1 << 6;
const ABRT_GCALL_READ = 1 << 5;
const ABRT_GCALL_NOACK = 1 << 4;
const ABRT_TXDATA_NOACK = 1 << 3;
const ABRT_10ADDR2_NOACK = 1 << 2;
const ABRT_10ADDR1_NOACK = 1 << 1;
const ABRT_7B_ADDR_NOACK = 1 << 0;
/* Connection parameters */
var I2CMode;
(function (I2CMode) {
    I2CMode[I2CMode["Write"] = 0] = "Write";
    I2CMode[I2CMode["Read"] = 1] = "Read";
})(I2CMode = exports.I2CMode || (exports.I2CMode = {}));
var I2CSpeed;
(function (I2CSpeed) {
    I2CSpeed[I2CSpeed["Invalid"] = 0] = "Invalid";
    /* standard mode (100 kbit/s) */
    I2CSpeed[I2CSpeed["Standard"] = 1] = "Standard";
    /* fast mode (<=400 kbit/s) or fast mode plus (<=1000Kbit/s) */
    I2CSpeed[I2CSpeed["FastMode"] = 2] = "FastMode";
    /*  high speed mode (3.4 Mbit/s) */
    I2CSpeed[I2CSpeed["HighSpeedMode"] = 3] = "HighSpeedMode";
})(I2CSpeed = exports.I2CSpeed || (exports.I2CSpeed = {}));
var I2CState;
(function (I2CState) {
    I2CState[I2CState["Idle"] = 0] = "Idle";
    I2CState[I2CState["Start"] = 1] = "Start";
    I2CState[I2CState["Connect"] = 2] = "Connect";
    I2CState[I2CState["Connected"] = 3] = "Connected";
    I2CState[I2CState["Stop"] = 4] = "Stop";
})(I2CState || (I2CState = {}));
// Interrupts
const R_RESTART_DET = 1 << 12; // Slave mode only
const R_GEN_CALL = 1 << 11;
const R_START_DET = 1 << 10;
const R_STOP_DET = 1 << 9;
const R_ACTIVITY = 1 << 8;
const R_RX_DONE = 1 << 7;
const R_TX_ABRT = 1 << 6;
const R_RD_REQ = 1 << 5;
const R_TX_EMPTY = 1 << 4;
const R_TX_OVER = 1 << 3;
const R_RX_FULL = 1 << 2;
const R_RX_OVER = 1 << 1;
const R_RX_UNDER = 1 << 0;
// FIFO entry bits
const FIRST_DATA_BYTE = 1 << 10;
const RESTART = 1 << 10;
const STOP = 1 << 9;
const CMD = 1 << 8; // 0 for write, 1 for read
class RPI2C extends peripheral_1.BasePeripheral {
    constructor(rp2040, name, irq) {
        super(rp2040, name);
        this.irq = irq;
        this.state = I2CState.Idle;
        this.busy = false;
        this.stop = false;
        this.pendingRestart = false;
        this.firstByte = false;
        this.rxFIFO = new fifo_1.FIFO(16);
        this.txFIFO = new fifo_1.FIFO(16);
        // user provided callbacks
        this.onStart = () => this.completeStart();
        this.onConnect = () => this.completeConnect(false);
        this.onWriteByte = () => this.completeWrite(false);
        this.onReadByte = () => this.completeRead(0xff);
        this.onStop = () => this.completeStop();
        this.enable = 0;
        this.rxThreshold = 0;
        this.txThreshold = 0;
        this.control = IC_SLAVE_DISABLE | IC_RESTART_EN | (I2CSpeed.FastMode << SPEED_SHIFT) | MASTER_MODE;
        this.targetAddress = 0x55;
        this.slaveAddress = 0x55;
        this.abortSource = 0;
        this.intRaw = 0;
        this.intEnable = 0;
    }
    get intStatus() {
        return this.intRaw & this.intEnable;
    }
    get speed() {
        return ((this.control >> SPEED_SHIFT) & SPEED_MASK);
    }
    get masterBits() {
        return this.control & IC_10BITADDR_MASTER ? 10 : 7;
    }
    checkInterrupts() {
        this.rp2040.setInterrupt(this.irq, !!this.intStatus);
    }
    clearInterrupts(mask) {
        if (this.intRaw & mask) {
            this.intRaw &= ~mask;
            this.checkInterrupts();
            return 1;
        }
        else {
            return 0;
        }
    }
    setInterrupts(mask) {
        if (!(this.intRaw & mask)) {
            this.intRaw |= mask;
            this.checkInterrupts();
        }
    }
    abort(reason) {
        this.abortSource &= ~TX_FLUSH_CNT_MASK;
        this.abortSource |= reason | (this.txFIFO.itemCount << TX_FLUSH_CNT_SHIFT);
        this.txFIFO.reset();
        this.setInterrupts(R_TX_ABRT);
    }
    nextCommand() {
        const enabled = this.enable & ENABLE;
        const blocked = this.enable & TX_CMD_BLOCK;
        if (this.txFIFO.empty || this.busy || blocked || !enabled) {
            return;
        }
        this.busy = true;
        const restart = !!(this.txFIFO.peek() & RESTART) && !this.pendingRestart && !this.stop;
        if (this.state === I2CState.Idle || restart) {
            this.pendingRestart = restart;
            this.stop = false;
            this.state = I2CState.Start;
            this.onStart(restart);
            return;
        }
        this.pendingRestart = false;
        const cmd = this.txFIFO.pull();
        const readMode = !!(cmd & CMD);
        this.stop = !!(cmd & STOP);
        if (readMode) {
            this.onReadByte(!this.stop);
        }
        else {
            this.onWriteByte(cmd & 0xff);
        }
        if (this.txFIFO.itemCount <= this.txThreshold) {
            this.setInterrupts(R_TX_EMPTY);
        }
    }
    pushRX(value) {
        if (this.rxFIFO.full) {
            this.setInterrupts(R_RX_OVER);
            return;
        }
        this.rxFIFO.push(value);
        if (this.rxFIFO.itemCount > this.rxThreshold) {
            this.setInterrupts(R_RX_FULL);
        }
    }
    completeStart() {
        if (this.txFIFO.empty || this.state !== I2CState.Start || this.stop) {
            this.onStop();
            return;
        }
        const mode = this.txFIFO.peek() & CMD ? I2CMode.Read : I2CMode.Write;
        this.state = I2CState.Connect;
        this.setInterrupts(R_START_DET);
        const addressMask = this.masterBits === 10 ? 0x3ff : 0xff;
        this.onConnect(this.targetAddress & addressMask, mode);
    }
    completeConnect(ack, nackByte = 0) {
        if (!ack || this.stop) {
            if (!ack) {
                if (!this.targetAddress) {
                    this.abort(ABRT_GCALL_NOACK);
                }
                else if (this.control & IC_10BITADDR_MASTER) {
                    this.abort(nackByte === 0 ? ABRT_10ADDR1_NOACK : ABRT_10ADDR2_NOACK);
                }
                else {
                    this.abort(ABRT_7B_ADDR_NOACK);
                }
            }
            this.state = I2CState.Stop;
            this.onStop();
            return;
        }
        this.state = I2CState.Connected;
        this.busy = false;
        this.firstByte = true;
        this.nextCommand();
    }
    completeWrite(ack) {
        if (!ack || this.stop) {
            if (!ack) {
                this.abort(ABRT_TXDATA_NOACK);
            }
            this.state = I2CState.Stop;
            this.onStop();
            return;
        }
        this.busy = false;
        this.nextCommand();
    }
    completeRead(value) {
        this.pushRX(value | (this.firstByte ? FIRST_DATA_BYTE : 0));
        if (this.stop) {
            this.state = I2CState.Stop;
            this.onStop();
            return;
        }
        this.firstByte = false;
        this.busy = false;
        this.nextCommand();
    }
    completeStop() {
        this.state = I2CState.Idle;
        this.setInterrupts(R_STOP_DET);
        this.busy = false;
        this.pendingRestart = false;
        if (this.enable & ABORT) {
            this.enable &= ~ABORT;
        }
        else {
            this.nextCommand();
        }
    }
    arbitrationLost() {
        this.state = I2CState.Idle;
        this.busy = false;
        this.abort(ARB_LOST);
    }
    readUint32(offset) {
        switch (offset) {
            case IC_CON:
                return this.control;
            case IC_TAR:
                return this.targetAddress;
            case IC_SAR:
                return this.slaveAddress;
            case IC_DATA_CMD:
                if (this.rxFIFO.empty) {
                    this.setInterrupts(R_RX_UNDER);
                    return 0;
                }
                this.clearInterrupts(R_RX_FULL);
                return this.rxFIFO.pull();
            case IC_INTR_STAT:
                return this.intStatus;
            case IC_INTR_MASK:
                return this.intEnable;
            case IC_RAW_INTR_STAT:
                return this.intRaw;
            case IC_RX_TL:
                return this.rxThreshold;
            case IC_TX_TL:
                return this.txThreshold;
            case IC_CLR_INTR:
                this.abortSource &= ABRT_SBYTE_NORSTRT; // Clear IC_TX_ABRT_SOURCE, expect for bit 9
                return this.clearInterrupts(R_RX_UNDER |
                    R_RX_OVER |
                    R_TX_OVER |
                    R_RD_REQ |
                    R_TX_ABRT |
                    R_RX_DONE |
                    R_ACTIVITY |
                    R_STOP_DET |
                    R_START_DET |
                    R_GEN_CALL);
            case IC_CLR_RX_UNDER:
                return this.clearInterrupts(R_RX_UNDER);
            case IC_CLR_RX_OVER:
                return this.clearInterrupts(R_RX_OVER);
            case IC_CLR_TX_OVER:
                return this.clearInterrupts(R_TX_OVER);
            case IC_CLR_RD_REQ:
                return this.clearInterrupts(R_RD_REQ);
            case IC_CLR_TX_ABRT:
                this.abortSource &= ABRT_SBYTE_NORSTRT; // Clear IC_TX_ABRT_SOURCE, expect for bit 9
                return this.clearInterrupts(R_TX_ABRT);
            case IC_CLR_RX_DONE:
                return this.clearInterrupts(R_RX_DONE);
            case IC_CLR_ACTIVITY:
                return this.clearInterrupts(R_ACTIVITY);
            case IC_CLR_STOP_DET:
                return this.clearInterrupts(R_STOP_DET);
            case IC_CLR_START_DET:
                return this.clearInterrupts(R_START_DET);
            case IC_CLR_GEN_CALL:
                return this.clearInterrupts(R_GEN_CALL);
            case IC_ENABLE:
                return this.enable;
            case IC_STATUS:
                return ((this.state !== I2CState.Idle ? MST_ACTIVITY | ACTIVITY : 0) |
                    (this.rxFIFO.full ? RFF : 0) |
                    (!this.rxFIFO.empty ? RFNE : 0) |
                    (this.txFIFO.empty ? TFE : 0) |
                    (!this.txFIFO.full ? TFNF : 0));
            case IC_TXFLR:
                return this.txFIFO.itemCount;
            case IC_RXFLR:
                return this.rxFIFO.itemCount;
            case IC_TX_ABRT_SOURCE: {
                const value = this.abortSource;
                this.abortSource &= ABRT_SBYTE_NORSTRT; // Clear IC_TX_ABRT_SOURCE, expect for bit 9
                return value;
            }
            case IC_COMP_PARAM_1:
                // From the datasheet:
                // Note This register is not implemented and therefore reads as 0. If it was implemented it would be a constant read-only
                // register that contains encoded information about the component's parameter settings.
                return 0;
            case IC_COMP_VERSION:
                return 0x3230312a;
            case IC_COMP_TYPE:
                return 0x44570140;
        }
        return super.readUint32(offset);
    }
    writeUint32(offset, value) {
        switch (offset) {
            case IC_CON:
                if (((value >> SPEED_SHIFT) & SPEED_MASK) === I2CSpeed.Invalid) {
                    value = (value & ~(SPEED_MASK << SPEED_SHIFT)) | (I2CSpeed.HighSpeedMode << SPEED_SHIFT);
                }
                this.control = value;
                return;
            case IC_TAR:
                this.targetAddress = value & 0x3ff;
                return;
            case IC_SAR:
                this.slaveAddress = value & 0x3ff;
                return;
            case IC_DATA_CMD:
                if (this.txFIFO.full) {
                    this.setInterrupts(R_TX_OVER);
                }
                else {
                    this.txFIFO.push(value);
                    this.clearInterrupts(R_TX_EMPTY);
                    this.nextCommand();
                }
                return;
            case IC_RX_TL:
                this.rxThreshold = value & 0xff;
                if (this.rxThreshold > this.rxFIFO.size) {
                    this.rxThreshold = this.rxFIFO.size;
                }
                return;
            case IC_TX_TL:
                this.txThreshold = value & 0xff;
                if (this.txThreshold > this.txFIFO.size) {
                    this.txThreshold = this.txFIFO.size;
                }
                return;
            case IC_ENABLE:
                // ABORT bit can only be set by software, not cleared.
                value |= this.enable & ABORT;
                if (value & ABORT) {
                    if (this.state === I2CState.Idle) {
                        value &= ~ABORT;
                    }
                    else {
                        this.abort(ABRT_USER_ABRT);
                        this.stop = true;
                    }
                }
                if (!(value & ENABLE)) {
                    this.txFIFO.reset();
                    this.rxFIFO.reset();
                }
                this.enable = value;
                this.nextCommand(); // TX_CMD_BLOCK may have changed
                return;
            default:
                super.writeUint32(offset, value);
        }
    }
}
exports.RPI2C = RPI2C;


/***/ }),

/***/ 6787:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RPIO = void 0;
const peripheral_1 = __nccwpck_require__(4223);
const GPIO_CTRL_LAST = 0x0ec;
const INTR0 = 0xf0;
const PROC0_INTE0 = 0x100;
const PROC0_INTF0 = 0x110;
const PROC0_INTS0 = 0x120;
const PROC0_INTS3 = 0x12c;
class RPIO extends peripheral_1.BasePeripheral {
    constructor(rp2040, name) {
        super(rp2040, name);
    }
    getPinFromOffset(offset) {
        const gpioIndex = offset >>> 3;
        return {
            gpio: this.rp2040.gpio[gpioIndex],
            isCtrl: !!(offset & 0x4),
        };
    }
    readUint32(offset) {
        if (offset <= GPIO_CTRL_LAST) {
            const { gpio, isCtrl } = this.getPinFromOffset(offset);
            return isCtrl ? gpio.ctrl : gpio.status;
        }
        if (offset >= INTR0 && offset <= PROC0_INTS3) {
            const startIndex = (offset & 0xf) * 2;
            const register = offset & ~0xf;
            const { gpio } = this.rp2040;
            let result = 0;
            for (let index = 7; index >= 0; index--) {
                const pin = gpio[index + startIndex];
                if (!pin) {
                    continue;
                }
                result <<= 4;
                switch (register) {
                    case INTR0:
                        result |= pin.irqStatus;
                        break;
                    case PROC0_INTE0:
                        result |= pin.irqEnableMask;
                        break;
                    case PROC0_INTF0:
                        result |= pin.irqForceMask;
                        break;
                    case PROC0_INTS0:
                        result |= (pin.irqStatus & pin.irqEnableMask) | pin.irqForceMask;
                        break;
                }
            }
            return result;
        }
        return super.readUint32(offset);
    }
    writeUint32(offset, value) {
        if (offset <= GPIO_CTRL_LAST) {
            const { gpio, isCtrl } = this.getPinFromOffset(offset);
            if (isCtrl) {
                gpio.ctrl = value;
                gpio.checkForUpdates();
            }
            return;
        }
        if (offset >= INTR0 && offset <= PROC0_INTS3) {
            const startIndex = (offset & 0xf) * 2;
            const register = offset & ~0xf;
            const { gpio } = this.rp2040;
            for (let index = 0; index < 8; index++) {
                const pin = gpio[index + startIndex];
                if (!pin) {
                    continue;
                }
                const pinValue = (value >> (index * 4)) & 0xf;
                const pinRawWriteValue = (this.rawWriteValue >> (index * 4)) & 0xf;
                switch (register) {
                    case INTR0:
                        pin.updateIRQValue(pinRawWriteValue);
                        break;
                    case PROC0_INTE0:
                        pin.irqEnableMask = pinValue;
                        break;
                    case PROC0_INTF0:
                        pin.irqForceMask = pinValue;
                        break;
                }
            }
            return;
        }
        super.writeUint32(offset, value);
    }
}
exports.RPIO = RPIO;


/***/ }),

/***/ 1254:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RPPADS = void 0;
const peripheral_1 = __nccwpck_require__(4223);
const VOLTAGE_SELECT = 0;
const GPIO_FIRST = 0x4;
const GPIO_LAST = 0x78;
const QSPI_FIRST = 0x4;
const QSPI_LAST = 0x18;
class RPPADS extends peripheral_1.BasePeripheral {
    constructor(rp2040, name, bank) {
        super(rp2040, name);
        this.bank = bank;
        this.voltageSelect = 0;
        this.firstPadRegister = this.bank === 'qspi' ? QSPI_FIRST : GPIO_FIRST;
        this.lastPadRegister = this.bank === 'qspi' ? QSPI_LAST : GPIO_LAST;
    }
    getPinFromOffset(offset) {
        const gpioIndex = (offset - this.firstPadRegister) >>> 2;
        if (this.bank === 'qspi') {
            return this.rp2040.qspi[gpioIndex];
        }
        else {
            return this.rp2040.gpio[gpioIndex];
        }
    }
    readUint32(offset) {
        if (offset >= this.firstPadRegister && offset <= this.lastPadRegister) {
            const gpio = this.getPinFromOffset(offset);
            return gpio.padValue;
        }
        switch (offset) {
            case VOLTAGE_SELECT:
                return this.voltageSelect;
        }
        return super.readUint32(offset);
    }
    writeUint32(offset, value) {
        if (offset >= this.firstPadRegister && offset <= this.lastPadRegister) {
            const gpio = this.getPinFromOffset(offset);
            const oldInputEnable = gpio.inputEnable;
            gpio.padValue = value;
            gpio.checkForUpdates();
            if (oldInputEnable !== gpio.inputEnable) {
                gpio.refreshInput();
            }
            return;
        }
        switch (offset) {
            case VOLTAGE_SELECT:
                this.voltageSelect = value & 1;
                break;
            default:
                super.writeUint32(offset, value);
        }
    }
}
exports.RPPADS = RPPADS;


/***/ }),

/***/ 4223:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UnimplementedPeripheral = exports.BasePeripheral = exports.atomicUpdate = void 0;
const ATOMIC_NORMAL = 0;
const ATOMIC_XOR = 1;
const ATOMIC_SET = 2;
const ATOMIC_CLEAR = 3;
function atomicUpdate(currentValue, atomicType, newValue) {
    switch (atomicType) {
        case ATOMIC_XOR:
            return currentValue ^ newValue;
        case ATOMIC_SET:
            return currentValue | newValue;
        case ATOMIC_CLEAR:
            return currentValue & ~newValue;
        default:
            console.warn('Atomic update called with invalid writeType', atomicType);
            return newValue;
    }
}
exports.atomicUpdate = atomicUpdate;
class BasePeripheral {
    constructor(rp2040, name) {
        this.rp2040 = rp2040;
        this.name = name;
        this.rawWriteValue = 0;
    }
    readUint32(offset) {
        this.warn(`Unimplemented peripheral read from ${offset.toString(16)}`);
        if (offset > 0x1000) {
            this.warn('Unimplemented read from peripheral in the atomic operation region');
        }
        return 0xffffffff;
    }
    writeUint32(offset, value) {
        this.warn(`Unimplemented peripheral write to ${offset.toString(16)}: ${value}`);
    }
    writeUint32Atomic(offset, value, atomicType) {
        this.rawWriteValue = value;
        const newValue = atomicType != ATOMIC_NORMAL
            ? atomicUpdate(this.readUint32(offset), atomicType, value)
            : value;
        this.writeUint32(offset, newValue);
    }
    debug(msg) {
        this.rp2040.logger.debug(this.name, msg);
    }
    info(msg) {
        this.rp2040.logger.info(this.name, msg);
    }
    warn(msg) {
        this.rp2040.logger.warn(this.name, msg);
    }
    error(msg) {
        this.rp2040.logger.error(this.name, msg);
    }
}
exports.BasePeripheral = BasePeripheral;
class UnimplementedPeripheral extends BasePeripheral {
}
exports.UnimplementedPeripheral = UnimplementedPeripheral;


/***/ }),

/***/ 514:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RPPIO = exports.StateMachine = exports.WaitType = void 0;
const fifo_1 = __nccwpck_require__(4677);
const dma_1 = __nccwpck_require__(1253);
const peripheral_1 = __nccwpck_require__(4223);
// Generic registers
const CTRL = 0x000;
const FSTAT = 0x004;
const FDEBUG = 0x008;
const FLEVEL = 0x00c;
const IRQ = 0x030;
const IRQ_FORCE = 0x034;
const INPUT_SYNC_BYPASS = 0x038;
const DBG_PADOUT = 0x03c;
const DBG_PADOE = 0x040;
const DBG_CFGINFO = 0x044;
const INSTR_MEM0 = 0x48;
const INSTR_MEM31 = 0x0c4;
const INTR = 0x128; // Raw Interrupts
const IRQ0_INTE = 0x12c; // Interrupt Enable for irq0
const IRQ0_INTF = 0x130; // Interrupt Force for irq0
const IRQ0_INTS = 0x134; // Interrupt status after masking & forcing for irq0
const IRQ1_INTE = 0x138; // Interrupt Enable for irq1
const IRQ1_INTF = 0x13c; // Interrupt Force for irq1
const IRQ1_INTS = 0x140; // Interrupt status after masking & forcing for irq1
// State-machine specific registers
const TXF0 = 0x010;
const TXF1 = 0x014;
const TXF2 = 0x018;
const TXF3 = 0x01c;
const RXF0 = 0x020;
const RXF1 = 0x024;
const RXF2 = 0x028;
const RXF3 = 0x02c;
const SM0_CLKDIV = 0x0c8; // Clock divisor register for state machine 0
const SM0_EXECCTRL = 0x0cc; // Execution/behavioural settings for state machine 0
const SM0_SHIFTCTRL = 0x0d0; // Control behaviour of the input/output shift registers for state machine 0
const SM0_ADDR = 0x0d4; // Current instruction address of state machine 0
const SM0_INSTR = 0x0d8; // Write to execute an instruction immediately (including jumps) and then resume execution.
const SM0_PINCTRL = 0x0dc; //State machine pin control
const SM1_CLKDIV = 0x0e0;
const SM1_PINCTRL = 0x0f4;
const SM2_CLKDIV = 0x0f8;
const SM2_PINCTRL = 0x10c;
const SM3_CLKDIV = 0x110;
const SM3_PINCTRL = 0x124;
// FSTAT bits
const FSTAT_TXEMPTY = 1 << 24;
const FSTAT_TXFULL = 1 << 16;
const FSTAT_RXEMPTY = 1 << 8;
const FSTAT_RXFULL = 1 << 0;
// FDEBUG bits
const FDEBUG_TXSTALL = 1 << 24;
const FDEBUG_TXOVER = 1 << 16;
const FDEBUG_RXUNDER = 1 << 8;
const FDEBUG_RXSTALL = 1 << 0;
// SHIFTCTRL bits
const SHIFTCTRL_AUTOPUSH = 1 << 16;
const SHIFTCTRL_AUTOPULL = 1 << 17;
const SHIFTCTRL_IN_SHIFTDIR = 1 << 18; // 1 = shift input shift register to right (data enters from left). 0 = to left
const SHIFTCTRL_OUT_SHIFTDIR = 1 << 19; // 1 = shift out of output shift register to right. 0 = to left
// EXECCTRL bits
const EXECCTRL_STATUS_SEL = 1 << 4;
const EXECCTRL_SIDE_PINDIR = 1 << 29;
const EXECCTRL_SIDE_EN = 1 << 30;
const EXECCTRL_EXEC_STALLED = 1 << 31;
var WaitType;
(function (WaitType) {
    WaitType[WaitType["None"] = 0] = "None";
    WaitType[WaitType["Pin"] = 1] = "Pin";
    WaitType[WaitType["rxFIFO"] = 2] = "rxFIFO";
    WaitType[WaitType["txFIFO"] = 3] = "txFIFO";
    WaitType[WaitType["IRQ"] = 4] = "IRQ";
    WaitType[WaitType["Out"] = 5] = "Out";
})(WaitType = exports.WaitType || (exports.WaitType = {}));
function bitReverse(x) {
    x = ((x & 0x55555555) << 1) | ((x & 0xaaaaaaaa) >>> 1);
    x = ((x & 0x33333333) << 2) | ((x & 0xcccccccc) >>> 2);
    x = ((x & 0x0f0f0f0f) << 4) | ((x & 0xf0f0f0f0) >>> 4);
    x = ((x & 0x00ff00ff) << 8) | ((x & 0xff00ff00) >>> 8);
    x = ((x & 0x0000ffff) << 16) | ((x & 0xffff0000) >>> 16);
    return x >>> 0;
}
function irqIndex(irq, machineIndex) {
    const rel = !!(irq & 0x10);
    return rel ? (irq & 0x4) | (((irq & 0x3) + machineIndex) & 0x3) : irq & 0x7;
}
const dreqRx0 = [
    dma_1.DREQChannel.DREQ_PIO0_RX0,
    dma_1.DREQChannel.DREQ_PIO0_RX1,
    dma_1.DREQChannel.DREQ_PIO0_RX2,
    dma_1.DREQChannel.DREQ_PIO0_RX3,
];
const dreqTx0 = [
    dma_1.DREQChannel.DREQ_PIO0_TX0,
    dma_1.DREQChannel.DREQ_PIO0_TX1,
    dma_1.DREQChannel.DREQ_PIO0_TX2,
    dma_1.DREQChannel.DREQ_PIO0_TX3,
];
const dreqRx1 = [
    dma_1.DREQChannel.DREQ_PIO1_RX0,
    dma_1.DREQChannel.DREQ_PIO1_RX1,
    dma_1.DREQChannel.DREQ_PIO1_RX2,
    dma_1.DREQChannel.DREQ_PIO1_RX3,
];
const dreqTx1 = [
    dma_1.DREQChannel.DREQ_PIO1_TX0,
    dma_1.DREQChannel.DREQ_PIO1_TX1,
    dma_1.DREQChannel.DREQ_PIO1_TX2,
    dma_1.DREQChannel.DREQ_PIO1_TX3,
];
class StateMachine {
    constructor(rp2040, pio, index) {
        this.rp2040 = rp2040;
        this.pio = pio;
        this.index = index;
        this.enabled = false;
        // State machine registers
        this.x = 0;
        this.y = 0;
        this.pc = 0;
        this.inputShiftReg = 0;
        this.inputShiftCount = 0;
        this.outputShiftReg = 0;
        this.outputShiftCount = 0;
        this.cycles = 0;
        this.execOpcode = 0;
        this.execValid = false;
        this.updatePC = true;
        this.clockDivInt = 1;
        this.clockDivFrac = 0;
        this.execCtrl = 0x1f << 12;
        this.shiftCtrl = 0b11 << 18;
        this.pinCtrl = 0x5 << 26;
        this.rxFIFO = new fifo_1.FIFO(4);
        this.txFIFO = new fifo_1.FIFO(4);
        this.outPinValues = 0;
        this.outPinDirection = 0;
        this.waiting = false;
        this.waitType = WaitType.None;
        this.waitIndex = 0;
        this.waitPolarity = false;
        this.waitDelay = -1;
        this.dreqRx = this.pio.dreqRx[this.index];
        this.dreqTx = this.pio.dreqTx[this.index];
        this.updateDMARx();
        this.updateDMATx();
    }
    updateDMATx() {
        if (this.txFIFO.full) {
            this.rp2040.dma.clearDREQ(this.dreqTx);
        }
        else {
            this.rp2040.dma.setDREQ(this.dreqTx);
        }
    }
    updateDMARx() {
        if (this.rxFIFO.empty) {
            this.rp2040.dma.clearDREQ(this.dreqRx);
        }
        else {
            this.rp2040.dma.setDREQ(this.dreqRx);
        }
    }
    writeFIFO(value) {
        if (this.txFIFO.full) {
            this.pio.fdebug |= FDEBUG_TXOVER << this.index;
            return;
        }
        this.txFIFO.push(value);
        this.updateDMATx();
        this.checkWait();
        if (this.txFIFO.full) {
            this.pio.checkInterrupts();
        }
    }
    readFIFO() {
        if (this.rxFIFO.empty) {
            this.pio.fdebug |= FDEBUG_RXUNDER << this.index;
            return 0;
        }
        const result = this.rxFIFO.pull();
        this.updateDMARx();
        this.checkWait();
        if (this.rxFIFO.empty) {
            this.pio.checkInterrupts();
        }
        return result;
    }
    get status() {
        const statusN = this.execCtrl & 0xf;
        if (this.execCtrl & EXECCTRL_STATUS_SEL) {
            return this.rxFIFO.itemCount < statusN ? 0xffffffff : 0;
        }
        else {
            return this.txFIFO.itemCount < statusN ? 0xffffffff : 0;
        }
    }
    jmpCondition(condition) {
        switch (condition) {
            // (no condition): Always
            case 0b000:
                return true;
            // !X: scratch X zero
            case 0b001:
                return this.x === 0;
            // X--: scratch X non-zero, post-decrement
            case 0b010: {
                const oldX = this.x;
                this.x = (this.x - 1) >>> 0;
                return oldX !== 0;
            }
            // !Y: scratch Y zero
            case 0b011:
                return this.y === 0;
            // Y--: scratch Y non-zero, post-decrement
            case 0b100: {
                const oldY = this.y;
                this.y = (this.y - 1) >>> 0;
                return oldY !== 0;
            }
            // X!=Y: scratch X not equal scratch Y
            case 0b101:
                return this.x >>> 0 !== this.y >>> 0;
            // PIN: branch on input pin
            case 0b110: {
                const { gpio } = this.rp2040;
                const { jmpPin } = this;
                return jmpPin < gpio.length ? gpio[jmpPin].inputValue : false;
            }
            // !OSRE: output shift register not empty
            case 0b111:
                return this.outputShiftCount < this.pullThreshold;
        }
        this.pio.error(`jmpCondition with unsupported condition: ${condition}`);
        return false;
    }
    get inPins() {
        const { gpioValues } = this.rp2040;
        const { inBase } = this;
        return inBase ? (gpioValues << (32 - inBase)) | (gpioValues >>> inBase) : gpioValues;
    }
    inSourceValue(source) {
        switch (source) {
            // PINS
            case 0b000:
                return this.inPins;
            // X (scratch register X)
            case 0b001:
                return this.x;
            // Y (scratch register Y)
            case 0b010:
                return this.y;
            // NULL (all zeroes)
            case 0b011:
                return 0;
            // Reserved
            case 0b100:
                return 0;
            // Reserved for IN, STATUS for MOV
            case 0b101:
                return this.status;
            // ISR
            case 0b110:
                return this.inputShiftReg;
            // OSR
            case 0b111:
                return this.outputShiftReg;
        }
        this.pio.error(`inSourceValue with unsupported source: ${source}`);
        return 0;
    }
    writeOutValue(destination, value, bitCount) {
        switch (destination) {
            // PINS
            case 0b000:
                this.setOutPins(value);
                break;
            // X (scratch register X)
            case 0b001:
                this.x = value;
                break;
            // Y (scratch register Y)
            case 0b010:
                this.y = value;
                break;
            // NULL (discard data)
            case 0b011:
                break;
            // PINDIRS
            case 0b100:
                this.setOutPinDirs(value);
                break;
            // PC
            case 0b101:
                this.pc = value & 0x1f;
                this.updatePC = false;
                break;
            // ISR (also sets ISR shift counter to Bit count)
            case 0b110:
                this.inputShiftReg = value;
                this.inputShiftCount = bitCount;
                break;
            // EXEC (Execute OSR shift data as instruction)
            case 0b111:
                this.execOpcode = value;
                this.execValid = true;
                break;
        }
    }
    get pushThreshold() {
        const value = (this.shiftCtrl >> 20) & 0x1f;
        return value ? value : 32;
    }
    get pullThreshold() {
        const value = (this.shiftCtrl >> 25) & 0x1f;
        return value ? value : 32;
    }
    get sidesetCount() {
        return (this.pinCtrl >> 29) & 0x7;
    }
    get setCount() {
        return (this.pinCtrl >> 26) & 0x7;
    }
    get outCount() {
        return (this.pinCtrl >> 20) & 0x3f;
    }
    get inBase() {
        return (this.pinCtrl >> 15) & 0x1f;
    }
    get sidesetBase() {
        return (this.pinCtrl >> 10) & 0x1f;
    }
    get setBase() {
        return (this.pinCtrl >> 5) & 0x1f;
    }
    get outBase() {
        return (this.pinCtrl >> 0) & 0x1f;
    }
    get jmpPin() {
        return (this.execCtrl >> 24) & 0x1f;
    }
    get wrapTop() {
        return (this.execCtrl >> 12) & 0x1f;
    }
    get wrapBottom() {
        return (this.execCtrl >> 7) & 0x1f;
    }
    setOutPinDirs(value) {
        this.outPinDirection = value;
        this.pio.pinDirectionsChanged(value, this.outBase, this.outCount);
    }
    setOutPins(value) {
        this.outPinValues = value;
        this.pio.pinValuesChanged(value, this.outBase, this.outCount);
    }
    outInstruction(arg) {
        const bitCount = arg & 0x1f;
        const destination = arg >> 5;
        if (bitCount === 0) {
            this.writeOutValue(destination, this.outputShiftReg, 32);
            this.outputShiftCount = 32;
        }
        else {
            if (this.shiftCtrl & SHIFTCTRL_OUT_SHIFTDIR) {
                const value = this.outputShiftReg & ((1 << bitCount) - 1);
                this.outputShiftReg >>>= bitCount;
                this.writeOutValue(destination, value, bitCount);
            }
            else {
                const value = this.outputShiftReg >>> (32 - bitCount);
                this.outputShiftReg <<= bitCount;
                this.writeOutValue(destination, value, bitCount);
            }
            this.outputShiftCount += bitCount;
            if (this.outputShiftCount > 32) {
                this.outputShiftCount = 32;
            }
        }
    }
    executeInstruction(opcode) {
        const arg = opcode & 0xff;
        switch (opcode >>> 13) {
            /* JMP */
            case 0b000:
                if (this.jmpCondition(arg >> 5)) {
                    this.pc = arg & 0x1f;
                    this.updatePC = false;
                }
                break;
            /* WAIT */
            case 0b001: {
                const polarity = !!(arg & 0x80);
                const source = (arg >> 5) & 0x3;
                const index = arg & 0x1f;
                switch (source) {
                    // GPIO:
                    case 0b00:
                        this.wait(WaitType.Pin, polarity, index);
                        break;
                    // PIN:
                    case 0b01:
                        this.wait(WaitType.Pin, polarity, (index + this.inBase) % 32);
                        break;
                    // IRQ:
                    case 0b10:
                        this.wait(WaitType.IRQ, polarity, irqIndex(index, this.index));
                        break;
                }
                break;
            }
            /* IN */
            case 0b010: {
                const bitCount = arg & 0x1f;
                let sourceValue = this.inSourceValue(arg >> 5);
                if (bitCount == 0) {
                    this.inputShiftReg = sourceValue;
                    this.inputShiftCount = 32;
                }
                else {
                    sourceValue &= (1 << bitCount) - 1;
                    if (this.shiftCtrl & SHIFTCTRL_IN_SHIFTDIR) {
                        this.inputShiftReg >>>= bitCount;
                        this.inputShiftReg |= sourceValue << (32 - bitCount);
                    }
                    else {
                        this.inputShiftReg <<= bitCount;
                        this.inputShiftReg |= sourceValue;
                    }
                    this.inputShiftCount += bitCount;
                    if (this.inputShiftCount > 32) {
                        this.inputShiftCount = 32;
                    }
                }
                if (this.shiftCtrl & SHIFTCTRL_AUTOPUSH && this.inputShiftCount >= this.pushThreshold) {
                    if (!this.rxFIFO.full) {
                        this.rxFIFO.push(this.inputShiftReg);
                        this.updateDMARx();
                        this.pio.checkInterrupts();
                    }
                    else {
                        this.pio.fdebug |= FDEBUG_RXSTALL << this.index;
                        this.wait(WaitType.rxFIFO, false, this.inputShiftReg);
                    }
                    this.inputShiftCount = 0;
                    this.inputShiftReg = 0;
                }
                break;
            }
            /* OUT */
            case 0b011: {
                if (this.shiftCtrl & SHIFTCTRL_AUTOPULL && this.outputShiftCount >= this.pullThreshold) {
                    this.outputShiftCount = 0;
                    if (!this.txFIFO.empty) {
                        this.outputShiftReg = this.txFIFO.pull();
                        this.updateDMATx();
                        this.pio.checkInterrupts();
                    }
                    else {
                        this.pio.fdebug |= FDEBUG_TXSTALL << this.index;
                        this.wait(WaitType.Out, false, arg);
                    }
                }
                if (!this.waiting) {
                    this.outInstruction(arg);
                }
                break;
            }
            /* PUSH/PULL */
            case 0b100: {
                const block = !!(arg & (1 << 5));
                const ifFullOrEmpty = !!(arg & (1 << 6));
                if (arg & 0x1f) {
                    // Unknown instruction
                    break;
                }
                if (arg & 0x80) {
                    // PULL
                    if (ifFullOrEmpty &&
                        this.shiftCtrl & SHIFTCTRL_AUTOPULL &&
                        this.outputShiftCount < this.pullThreshold) {
                        break;
                    }
                    if (!this.txFIFO.empty) {
                        this.outputShiftReg = this.txFIFO.pull();
                        this.updateDMATx();
                        this.pio.checkInterrupts();
                    }
                    else {
                        this.pio.fdebug |= FDEBUG_TXSTALL << this.index;
                        if (block) {
                            this.wait(WaitType.txFIFO, false, 0);
                        }
                        else {
                            this.outputShiftReg = this.x;
                        }
                    }
                    this.outputShiftCount = 0;
                }
                else {
                    // PUSH
                    if (ifFullOrEmpty &&
                        this.shiftCtrl & SHIFTCTRL_AUTOPUSH &&
                        this.inputShiftCount < this.pushThreshold) {
                        break;
                    }
                    if (!this.rxFIFO.full) {
                        this.rxFIFO.push(this.inputShiftReg);
                        this.updateDMARx();
                        this.pio.checkInterrupts();
                    }
                    else {
                        this.pio.fdebug |= FDEBUG_RXSTALL << this.index;
                        if (block) {
                            this.wait(WaitType.rxFIFO, false, this.inputShiftReg);
                        }
                    }
                    this.inputShiftReg = 0;
                    this.inputShiftCount = 0;
                }
                break;
            }
            /* MOV */
            case 0b101: {
                const source = arg & 0x7;
                const op = (arg >> 3) & 0x3;
                const destination = (arg >> 5) & 0x7;
                const value = this.inSourceValue(source);
                const transformedValue = this.transformMovValue(value, op) >>> 0;
                this.setMovDestination(destination, transformedValue);
                break;
            }
            /* IRQ */
            case 0b110: {
                if (arg & 0x80) {
                    // Unknown instruction
                    break;
                }
                const clear = !!(arg & 0x40);
                const wait = !!(arg & 0x20);
                const irq = irqIndex(arg & 0x1f, this.index);
                if (clear) {
                    this.pio.irq &= ~(1 << irq);
                    this.pio.irqUpdated();
                }
                else {
                    this.pio.irq |= 1 << irq;
                    this.pio.irqUpdated();
                    if (wait) {
                        this.wait(WaitType.IRQ, false, irq);
                    }
                }
                break;
            }
            /* SET */
            case 0b111: {
                const data = arg & 0x1f;
                const destination = arg >> 5;
                switch (destination) {
                    case 0b000:
                        this.setSetPins(data);
                        break;
                    case 0b001:
                        this.x = data;
                        break;
                    case 0b010:
                        this.y = data;
                        break;
                    case 0b100:
                        this.setSetPinDirs(data);
                        break;
                }
                break;
            }
        }
        this.cycles++;
        const { sidesetCount, execCtrl } = this;
        const delaySideset = (opcode >> 8) & 0x1f;
        const sideEn = !!(execCtrl & EXECCTRL_SIDE_EN);
        const delay = delaySideset & ((1 << (5 - sidesetCount)) - 1);
        if (sidesetCount && (!sideEn || delaySideset & 0x10)) {
            const sideset = delaySideset >> (5 - sidesetCount);
            this.setSideset(sideset, sideEn ? sidesetCount - 1 : sidesetCount);
        }
        if (this.execValid) {
            this.execValid = false;
            this.executeInstruction(this.execOpcode);
        }
        else if (this.waiting) {
            if (this.waitDelay < 0) {
                this.waitDelay = delay;
            }
            this.checkWait();
        }
        else {
            this.cycles += delay;
        }
    }
    wait(type, polarity, index) {
        this.waiting = true;
        this.waitType = type;
        this.waitPolarity = polarity;
        this.waitIndex = index;
        this.waitDelay = -1;
        this.updatePC = false;
    }
    nextPC() {
        if (this.pc === this.wrapTop) {
            this.pc = this.wrapBottom;
        }
        else {
            this.pc = (this.pc + 1) & 0x1f;
        }
    }
    step() {
        if (this.waiting) {
            this.checkWait();
            if (this.waiting) {
                return;
            }
        }
        this.updatePC = true;
        this.executeInstruction(this.pio.instructions[this.pc]);
        if (this.updatePC) {
            this.nextPC();
        }
    }
    setSetPinDirs(value) {
        this.pio.pinDirectionsChanged(value, this.setBase, this.setCount);
    }
    setSetPins(value) {
        this.pio.pinValuesChanged(value, this.setBase, this.setCount);
    }
    setSideset(value, count) {
        if (this.execCtrl & EXECCTRL_SIDE_PINDIR) {
            this.pio.pinDirectionsChanged(value, this.sidesetBase, count);
        }
        else {
            this.pio.pinValuesChanged(value, this.sidesetBase, count);
        }
    }
    transformMovValue(value, op) {
        switch (op) {
            case 0b00:
                return value;
            case 0b01:
                return ~value;
            case 0b10:
                return bitReverse(value);
            case 0b11:
            default:
                return value; // reserved
        }
    }
    setMovDestination(destination, value) {
        switch (destination) {
            // PINS
            case 0b000:
                this.setOutPins(value);
                break;
            // X (scratch register X)
            case 0b001:
                this.x = value;
                break;
            // Y (scratch register Y)
            case 0b010:
                this.y = value;
                break;
            // reserved (discard data)
            case 0b011:
                break;
            // EXEC
            case 0b100:
                this.execOpcode = value;
                this.execValid = true;
                break;
            // PC
            case 0b101:
                this.pc = value & 0x1f;
                this.updatePC = false;
                break;
            // ISR (Input shift counter is reset to 0 by this operation, i.e. empty)
            case 0b110:
                this.inputShiftReg = value;
                this.inputShiftCount = 0;
                break;
            // OSR (Output shift counter is reset to 0 by this operation, i.e. full)
            case 0b111:
                this.outputShiftReg = value;
                this.outputShiftCount = 0;
                break;
        }
    }
    readUint32(offset) {
        switch (offset + SM0_CLKDIV) {
            case SM0_CLKDIV:
                return (this.clockDivInt << 16) | (this.clockDivFrac << 8);
            case SM0_EXECCTRL:
                return this.execCtrl;
            case SM0_SHIFTCTRL:
                return this.shiftCtrl;
            case SM0_ADDR:
                return this.pc;
            case SM0_INSTR:
                return this.pio.instructions[this.pc];
            case SM0_PINCTRL:
                return this.pinCtrl;
        }
        this.pio.error(`Read from invalid state machine register: ${offset}`);
        return 0;
    }
    writeUint32(offset, value) {
        switch (offset + SM0_CLKDIV) {
            case SM0_CLKDIV:
                this.clockDivFrac = (value >>> 8) & 0xff;
                this.clockDivInt = value >>> 16;
                break;
            case SM0_EXECCTRL:
                this.execCtrl = ((value & 0x7fffffff) | (this.execCtrl & 0x80000000)) >>> 0;
                break;
            case SM0_SHIFTCTRL:
                this.shiftCtrl = value;
                break;
            case SM0_ADDR:
                /* read-only */
                break;
            case SM0_INSTR:
                this.executeInstruction(value & 0xffff);
                if (this.waiting) {
                    this.execCtrl |= EXECCTRL_EXEC_STALLED;
                }
                break;
            case SM0_PINCTRL:
                this.pinCtrl = value;
                break;
            default:
                this.pio.error(`Write to invalid state machine register: ${offset}`);
        }
    }
    get fifoStat() {
        const result = (this.txFIFO.empty ? FSTAT_TXEMPTY : 0) |
            (this.txFIFO.full ? FSTAT_TXFULL : 0) |
            (this.rxFIFO.empty ? FSTAT_RXEMPTY : 0) |
            (this.rxFIFO.full ? FSTAT_RXFULL : 0);
        return result << this.index;
    }
    restart() {
        this.cycles = 0;
        this.inputShiftCount = 0;
        this.outputShiftCount = 32;
        this.inputShiftReg = 0;
        this.waiting = false;
        // TODO any pin write left asserted due to OUT_STICKY.
    }
    clkDivRestart() {
        this.pio.warn('clkDivRestart not implemented');
    }
    checkWait() {
        if (!this.waiting) {
            return;
        }
        switch (this.waitType) {
            case WaitType.IRQ: {
                const irqValue = !!(this.pio.irq & (1 << this.waitIndex));
                if (irqValue === this.waitPolarity) {
                    this.waiting = false;
                    if (irqValue) {
                        this.pio.irq &= ~(1 << this.waitIndex);
                    }
                }
                break;
            }
            case WaitType.Pin: {
                if (this.waitIndex < this.rp2040.gpio.length &&
                    this.rp2040.gpio[this.waitIndex].inputValue === this.waitPolarity) {
                    this.waiting = false;
                }
                break;
            }
            case WaitType.rxFIFO: {
                if (!this.rxFIFO.full) {
                    this.rxFIFO.push(this.waitIndex);
                    this.waiting = false;
                    this.updateDMARx();
                    this.pio.checkInterrupts();
                }
                break;
            }
            case WaitType.txFIFO: {
                if (!this.txFIFO.empty) {
                    this.outputShiftReg = this.txFIFO.pull();
                    this.waiting = false;
                    this.updateDMATx();
                    this.pio.checkInterrupts();
                }
                break;
            }
            case WaitType.Out: {
                if (!this.txFIFO.empty) {
                    this.outputShiftReg = this.txFIFO.pull();
                    this.outInstruction(this.waitIndex);
                    this.waiting = false;
                    this.updateDMATx();
                    this.pio.checkInterrupts();
                }
                break;
            }
        }
        if (!this.waiting) {
            this.nextPC();
            this.cycles += this.waitDelay;
            this.execCtrl &= ~EXECCTRL_EXEC_STALLED;
        }
    }
}
exports.StateMachine = StateMachine;
class RPPIO extends peripheral_1.BasePeripheral {
    constructor(rp2040, name, firstIrq, index) {
        super(rp2040, name);
        this.firstIrq = firstIrq;
        this.index = index;
        this.instructions = new Uint32Array(32);
        this.dreqRx = this.index ? dreqRx1 : dreqRx0;
        this.dreqTx = this.index ? dreqTx1 : dreqTx0;
        this.machines = [
            new StateMachine(this.rp2040, this, 0),
            new StateMachine(this.rp2040, this, 1),
            new StateMachine(this.rp2040, this, 2),
            new StateMachine(this.rp2040, this, 3),
        ];
        this.stopped = true;
        this.fdebug = 0;
        this.inputSyncBypass = 0;
        this.irq = 0;
        this.pinValues = 0;
        this.pinDirections = 0;
        this.oldPinValues = 0;
        this.oldPinDirections = 0;
        this.runTimer = null;
        this.irq0IntEnable = 0;
        this.irq0IntForce = 0;
        this.irq1IntEnable = 0;
        this.irq1IntForce = 0;
    }
    get intRaw() {
        return (((this.irq & 0xf) << 8) |
            (!this.machines[3].txFIFO.full ? 0x80 : 0) |
            (!this.machines[2].txFIFO.full ? 0x40 : 0) |
            (!this.machines[1].txFIFO.full ? 0x20 : 0) |
            (!this.machines[0].txFIFO.full ? 0x10 : 0) |
            (!this.machines[3].rxFIFO.empty ? 0x08 : 0) |
            (!this.machines[2].rxFIFO.empty ? 0x04 : 0) |
            (!this.machines[1].rxFIFO.empty ? 0x02 : 0) |
            (!this.machines[0].rxFIFO.empty ? 0x01 : 0));
    }
    get irq0IntStatus() {
        return (this.intRaw & this.irq0IntEnable) | this.irq0IntForce;
    }
    get irq1IntStatus() {
        return (this.intRaw & this.irq1IntEnable) | this.irq1IntForce;
    }
    readUint32(offset) {
        if (offset >= SM0_CLKDIV && offset <= SM0_PINCTRL) {
            return this.machines[0].readUint32(offset - SM0_CLKDIV);
        }
        if (offset >= SM1_CLKDIV && offset <= SM1_PINCTRL) {
            return this.machines[1].readUint32(offset - SM1_CLKDIV);
        }
        if (offset >= SM2_CLKDIV && offset <= SM2_PINCTRL) {
            return this.machines[2].readUint32(offset - SM2_CLKDIV);
        }
        if (offset >= SM3_CLKDIV && offset <= SM3_PINCTRL) {
            return this.machines[3].readUint32(offset - SM3_CLKDIV);
        }
        switch (offset) {
            case CTRL:
                return ((this.machines[0].enabled ? 1 << 0 : 0) |
                    (this.machines[1].enabled ? 1 << 1 : 0) |
                    (this.machines[2].enabled ? 1 << 2 : 0) |
                    (this.machines[3].enabled ? 1 << 3 : 0));
            case FSTAT:
                return (this.machines[0].fifoStat |
                    this.machines[1].fifoStat |
                    this.machines[2].fifoStat |
                    this.machines[3].fifoStat);
            case FDEBUG:
                return this.fdebug;
            case FLEVEL:
                return ((this.machines[0].txFIFO.itemCount & 0xf) |
                    ((this.machines[0].rxFIFO.itemCount & 0xf) << 4) |
                    ((this.machines[1].txFIFO.itemCount & 0xf) << 8) |
                    ((this.machines[1].rxFIFO.itemCount & 0xf) << 12) |
                    ((this.machines[2].txFIFO.itemCount & 0xf) << 16) |
                    ((this.machines[2].rxFIFO.itemCount & 0xf) << 20) |
                    ((this.machines[3].txFIFO.itemCount & 0xf) << 24) |
                    ((this.machines[3].rxFIFO.itemCount & 0xf) << 28));
            case RXF0:
                return this.machines[0].readFIFO();
            case RXF1:
                return this.machines[1].readFIFO();
            case RXF2:
                return this.machines[2].readFIFO();
            case RXF3:
                return this.machines[3].readFIFO();
            case IRQ:
                return this.irq;
            case IRQ_FORCE:
                return 0;
            case INPUT_SYNC_BYPASS:
                return this.inputSyncBypass;
            case DBG_PADOUT:
                return this.pinValues;
            case DBG_PADOE:
                return this.pinDirections;
            case DBG_CFGINFO:
                return 0x200404;
            case INTR:
                return this.intRaw;
            case IRQ0_INTE:
                return this.irq0IntEnable;
            case IRQ0_INTF:
                return this.irq0IntForce;
            case IRQ0_INTS:
                return this.irq0IntStatus;
            case IRQ1_INTE:
                return this.irq1IntEnable;
            case IRQ1_INTF:
                return this.irq1IntForce;
            case IRQ1_INTS:
                return this.irq1IntStatus;
        }
        return super.readUint32(offset);
    }
    writeUint32(offset, value) {
        if (offset >= INSTR_MEM0 && offset <= INSTR_MEM31) {
            const index = (offset - INSTR_MEM0) >> 2;
            this.instructions[index] = value & 0xffff;
            return;
        }
        if (offset >= SM0_CLKDIV && offset <= SM0_PINCTRL) {
            this.machines[0].writeUint32(offset - SM0_CLKDIV, value);
            return;
        }
        if (offset >= SM1_CLKDIV && offset <= SM1_PINCTRL) {
            this.machines[1].writeUint32(offset - SM1_CLKDIV, value);
            return;
        }
        if (offset >= SM2_CLKDIV && offset <= SM2_PINCTRL) {
            this.machines[2].writeUint32(offset - SM2_CLKDIV, value);
            return;
        }
        if (offset >= SM3_CLKDIV && offset <= SM3_PINCTRL) {
            this.machines[3].writeUint32(offset - SM3_CLKDIV, value);
            return;
        }
        switch (offset) {
            case CTRL: {
                for (let index = 0; index < 4; index++) {
                    this.machines[index].enabled = value & (1 << index) ? true : false;
                    if (value & (1 << (4 + index))) {
                        this.machines[index].restart();
                    }
                    if (value & (1 << (8 + index))) {
                        this.machines[index].clkDivRestart();
                    }
                }
                const shouldRun = value & 0xf;
                if (this.stopped && shouldRun) {
                    this.stopped = false;
                    this.run();
                }
                if (!shouldRun) {
                    this.stopped = true;
                }
                break;
            }
            case FDEBUG:
                this.fdebug &= ~this.rawWriteValue;
                break;
            case TXF0:
                this.machines[0].writeFIFO(value);
                break;
            case TXF1:
                this.machines[1].writeFIFO(value);
                break;
            case TXF2:
                this.machines[2].writeFIFO(value);
                break;
            case TXF3:
                this.machines[3].writeFIFO(value);
                break;
            case IRQ:
                this.irq &= ~this.rawWriteValue;
                this.irqUpdated();
                break;
            case INPUT_SYNC_BYPASS:
                this.inputSyncBypass = value;
                break;
            case IRQ_FORCE:
                this.irq |= value;
                this.irqUpdated();
                break;
            case IRQ0_INTE:
                this.irq0IntEnable = value & 0xfff;
                this.checkInterrupts();
                break;
            case IRQ0_INTF:
                this.irq0IntForce = value & 0xfff;
                this.checkInterrupts();
                break;
            case IRQ1_INTE:
                this.irq1IntEnable = value & 0xfff;
                this.checkInterrupts();
                break;
            case IRQ1_INTF:
                this.irq1IntForce = value & 0xfff;
                this.checkInterrupts();
                break;
            default:
                super.writeUint32(offset, value);
        }
    }
    pinValuesChanged(value, firstPin, count) {
        // TODO: wrapping after pin 31
        const mask = count > 31 ? 0xffffffff : ((1 << count) - 1) << firstPin;
        const newValue = ((this.pinValues & ~mask) | ((value << firstPin) & mask)) & 0x3fffffff;
        this.pinValues = newValue;
    }
    pinDirectionsChanged(value, firstPin, count) {
        // TODO: wrapping after pin 31
        const mask = count > 31 ? 0xffffffff : ((1 << count) - 1) << firstPin;
        const newValue = ((this.pinDirections & ~mask) | ((value << firstPin) & mask)) & 0x3fffffff;
        this.pinDirections = newValue;
    }
    checkInterrupts() {
        const { firstIrq } = this;
        this.rp2040.setInterrupt(firstIrq, !!this.irq0IntStatus);
        this.rp2040.setInterrupt(firstIrq + 1, !!this.irq1IntStatus);
    }
    irqUpdated() {
        for (const machine of this.machines) {
            machine.checkWait();
        }
        this.checkInterrupts();
    }
    checkChangedPins() {
        const changedPins = (this.oldPinDirections ^ this.pinDirections) | (this.oldPinValues ^ this.pinValues);
        if (changedPins) {
            this.oldPinDirections = this.pinDirections;
            this.oldPinValues = this.pinValues;
            // Notify GPIO about the changed pins
            const { gpio } = this.rp2040;
            for (let gpioIndex = 0; gpioIndex < gpio.length; gpioIndex++) {
                if (changedPins & (1 << gpioIndex)) {
                    gpio[gpioIndex].checkForUpdates();
                }
            }
        }
    }
    step() {
        for (const machine of this.machines) {
            machine.step();
        }
        this.checkChangedPins();
    }
    run() {
        for (let i = 0; i < 1000 && !this.stopped; i++) {
            this.step();
        }
        if (!this.stopped) {
            this.runTimer = setTimeout(() => this.run(), 0);
        }
    }
    stop() {
        for (const machine of this.machines) {
            machine.enabled = false;
        }
        this.stopped = true;
        if (this.runTimer) {
            clearTimeout(this.runTimer);
            this.runTimer = null;
        }
    }
}
exports.RPPIO = RPPIO;


/***/ }),

/***/ 3635:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RPPPB = exports.SHPR3 = exports.SHPR2 = exports.VTOR = exports.ICSR = exports.CPUID = void 0;
const irq_1 = __nccwpck_require__(679);
const peripheral_1 = __nccwpck_require__(4223);
exports.CPUID = 0xd00;
exports.ICSR = 0xd04;
exports.VTOR = 0xd08;
exports.SHPR2 = 0xd1c;
exports.SHPR3 = 0xd20;
const SYST_CSR = 0x010; // SysTick Control and Status Register
const SYST_RVR = 0x014; // SysTick Reload Value Register
const SYST_CVR = 0x018; // SysTick Current Value Register
const SYST_CALIB = 0x01c; // SysTick Calibration Value Register
const NVIC_ISER = 0x100; // Interrupt Set-Enable Register
const NVIC_ICER = 0x180; // Interrupt Clear-Enable Register
const NVIC_ISPR = 0x200; // Interrupt Set-Pending Register
const NVIC_ICPR = 0x280; // Interrupt Clear-Pending Register
// Interrupt priority registers:
const NVIC_IPR0 = 0x400;
const NVIC_IPR1 = 0x404;
const NVIC_IPR2 = 0x408;
const NVIC_IPR3 = 0x40c;
const NVIC_IPR4 = 0x410;
const NVIC_IPR5 = 0x414;
const NVIC_IPR6 = 0x418;
const NVIC_IPR7 = 0x41c;
/** ICSR Bits */
const NMIPENDSET = 1 << 31;
const PENDSVSET = 1 << 28;
const PENDSVCLR = 1 << 27;
const PENDSTSET = 1 << 26;
const PENDSTCLR = 1 << 25;
const ISRPREEMPT = 1 << 23;
const ISRPENDING = 1 << 22;
const VECTPENDING_MASK = 0x1ff;
const VECTPENDING_SHIFT = 12;
const VECTACTIVE_MASK = 0x1ff;
const VECTACTIVE_SHIFT = 0;
/** PPB stands for Private Periphral Bus.
 * These are peripherals that are part of the ARM Cortex Core, and there's one copy for each processor core.
 *
 * Included peripheral: NVIC, SysTick timer
 */
class RPPPB extends peripheral_1.BasePeripheral {
    constructor() {
        super(...arguments);
        // Systick
        this.systickCountFlag = false;
        this.systickControl = 0;
        this.systickLastZero = 0;
        this.systickReload = 0;
        this.systickTimer = null;
    }
    readUint32(offset) {
        const { rp2040 } = this;
        const { core } = rp2040;
        switch (offset) {
            case exports.CPUID:
                return 0x410cc601; /* Verified against actual hardware */
            case exports.ICSR: {
                const pendingInterrupts = core.pendingInterrupts || core.pendingPendSV || core.pendingSystick || core.pendingSVCall;
                const vectPending = core.vectPending;
                return ((core.pendingNMI ? NMIPENDSET : 0) |
                    (core.pendingPendSV ? PENDSVSET : 0) |
                    (core.pendingSystick ? PENDSTSET : 0) |
                    (pendingInterrupts ? ISRPENDING : 0) |
                    (vectPending << VECTPENDING_SHIFT) |
                    ((core.IPSR & VECTACTIVE_MASK) << VECTACTIVE_SHIFT));
            }
            case exports.VTOR:
                return core.VTOR;
            /* NVIC */
            case NVIC_ISPR:
                return core.pendingInterrupts >>> 0;
            case NVIC_ICPR:
                return core.pendingInterrupts >>> 0;
            case NVIC_ISER:
                return core.enabledInterrupts >>> 0;
            case NVIC_ICER:
                return core.enabledInterrupts >>> 0;
            case NVIC_IPR0:
            case NVIC_IPR1:
            case NVIC_IPR2:
            case NVIC_IPR3:
            case NVIC_IPR4:
            case NVIC_IPR5:
            case NVIC_IPR6:
            case NVIC_IPR7: {
                const regIndex = (offset - NVIC_IPR0) >> 2;
                let result = 0;
                for (let byteIndex = 0; byteIndex < 4; byteIndex++) {
                    const interruptNumber = regIndex * 4 + byteIndex;
                    for (let priority = 0; priority < core.interruptPriorities.length; priority++) {
                        if (core.interruptPriorities[priority] & (1 << interruptNumber)) {
                            result |= priority << (8 * byteIndex + 6);
                        }
                    }
                }
                return result;
            }
            case exports.SHPR2:
                return core.SHPR2;
            case exports.SHPR3:
                return core.SHPR3;
            /* SysTick */
            case SYST_CSR: {
                const countFlagValue = this.systickCountFlag ? 1 << 16 : 0;
                this.systickCountFlag = false;
                return countFlagValue | (this.systickControl & 0x7);
            }
            case SYST_CVR: {
                const delta = (rp2040.clock.micros - this.systickLastZero) % (this.systickReload + 1);
                if (!delta) {
                    return 0;
                }
                return this.systickReload - (delta - 1);
            }
            case SYST_RVR:
                return this.systickReload;
            case SYST_CALIB:
                return 0x0000270f;
        }
        return super.readUint32(offset);
    }
    writeUint32(offset, value) {
        const { rp2040 } = this;
        const { core } = rp2040;
        const hardwareInterruptMask = (1 << irq_1.MAX_HARDWARE_IRQ) - 1;
        switch (offset) {
            case exports.ICSR:
                if (value & NMIPENDSET) {
                    core.pendingNMI = true;
                    core.interruptsUpdated = true;
                }
                if (value & PENDSVSET) {
                    core.pendingPendSV = true;
                    core.interruptsUpdated = true;
                }
                if (value & PENDSVCLR) {
                    core.pendingPendSV = false;
                }
                if (value & PENDSTSET) {
                    core.pendingSystick = true;
                    core.interruptsUpdated = true;
                }
                if (value & PENDSTCLR) {
                    core.pendingSystick = false;
                }
                return;
            case exports.VTOR:
                core.VTOR = value;
                return;
            /* NVIC */
            case NVIC_ISPR:
                core.pendingInterrupts |= value;
                core.interruptsUpdated = true;
                return;
            case NVIC_ICPR:
                core.pendingInterrupts &= ~value | hardwareInterruptMask;
                return;
            case NVIC_ISER:
                core.enabledInterrupts |= value;
                core.interruptsUpdated = true;
                return;
            case NVIC_ICER:
                core.enabledInterrupts &= ~value;
                return;
            case NVIC_IPR0:
            case NVIC_IPR1:
            case NVIC_IPR2:
            case NVIC_IPR3:
            case NVIC_IPR4:
            case NVIC_IPR5:
            case NVIC_IPR6:
            case NVIC_IPR7: {
                const regIndex = (offset - NVIC_IPR0) >> 2;
                for (let byteIndex = 0; byteIndex < 4; byteIndex++) {
                    const interruptNumber = regIndex * 4 + byteIndex;
                    const newPriority = (value >> (8 * byteIndex + 6)) & 0x3;
                    for (let priority = 0; priority < core.interruptPriorities.length; priority++) {
                        core.interruptPriorities[priority] &= ~(1 << interruptNumber);
                    }
                    core.interruptPriorities[newPriority] |= 1 << interruptNumber;
                }
                core.interruptsUpdated = true;
                return;
            }
            case exports.SHPR2:
                core.SHPR2 = value;
                return;
            case exports.SHPR3:
                core.SHPR3 = value;
                return;
            // SysTick
            case SYST_CSR:
                {
                    const prevInterrupt = this.systickControl === 0x7;
                    const interrupt = value === 0x7;
                    if (interrupt && !prevInterrupt) {
                        // TODO: adjust the timer based on the current systick value
                        const systickCallback = () => {
                            core.pendingSystick = true;
                            core.interruptsUpdated = true;
                            if (core.waiting && core.checkForInterrupts()) {
                                core.waiting = false;
                            }
                            this.systickTimer = rp2040.clock.createTimer(this.systickReload + 1, systickCallback);
                        };
                        this.systickTimer = rp2040.clock.createTimer(this.systickReload + 1, systickCallback);
                    }
                    if (prevInterrupt && interrupt) {
                        if (this.systickTimer) {
                            rp2040.clock.deleteTimer(this.systickTimer);
                        }
                        this.systickTimer = null;
                    }
                    this.systickControl = value & 0x7;
                }
                return;
            case SYST_CVR:
                this.warn(`SYSTICK CVR: not implemented yet, value=${value}`);
                return;
            case SYST_RVR:
                this.systickReload = value;
                return;
            default:
                super.writeUint32(offset, value);
        }
    }
}
exports.RPPPB = RPPPB;


/***/ }),

/***/ 1020:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RPPWM = void 0;
const irq_1 = __nccwpck_require__(679);
const timer32_1 = __nccwpck_require__(6682);
const dma_1 = __nccwpck_require__(1253);
const peripheral_1 = __nccwpck_require__(4223);
/** Control and status register */
const CHn_CSR = 0x00;
/**
 * INT and FRAC form a fixed-point fractional number.
 * Counting rate is system clock frequency divided by this number.
 * Fractional division uses simple 1st-order sigma-delta.
 */
const CHn_DIV = 0x04;
/** Direct access to the PWM counter */
const CHn_CTR = 0x08;
/** Counter compare values */
const CHn_CC = 0x0c;
/** Counter wrap value */
const CHn_TOP = 0x10;
/**
 * This register aliases the CSR_EN bits for all channels.
 * Writing to this register allows multiple channels to be enabled
 * or disabled simultaneously, so they can run in perfect sync.
 * For each channel, there is only one physical EN register bit,
 * which can be accessed through here or CHx_CSR.
 */
const EN = 0xa0;
/** Raw Interrupts */
const INTR = 0xa4;
/** Interrupt Enable */
const INTE = 0xa8;
/** Interrupt Force */
const INTF = 0xac;
/** Interrupt status after masking & forcing */
const INTS = 0xb0;
const INT_MASK = 0xff;
/* CHn_CSR bits */
const CSR_PH_ADV = 1 << 7;
const CSR_PH_RET = 1 << 6;
const CSR_DIVMODE_SHIFT = 4;
const CSR_DIVMODE_MASK = 0x3;
const CSR_B_INV = 1 << 3;
const CSR_A_INV = 1 << 2;
const CSR_PH_CORRECT = 1 << 1;
const CSR_EN = 1 << 0;
var PWMDivMode;
(function (PWMDivMode) {
    PWMDivMode[PWMDivMode["FreeRunning"] = 0] = "FreeRunning";
    PWMDivMode[PWMDivMode["BGated"] = 1] = "BGated";
    PWMDivMode[PWMDivMode["BRisingEdge"] = 2] = "BRisingEdge";
    PWMDivMode[PWMDivMode["BFallingEdge"] = 3] = "BFallingEdge";
})(PWMDivMode || (PWMDivMode = {}));
class PWMChannel {
    constructor(pwm, clock, index) {
        this.pwm = pwm;
        this.clock = clock;
        this.index = index;
        this.timer = new timer32_1.Timer32(this.clock, this.pwm.clockFreq);
        this.alarmA = new timer32_1.Timer32PeriodicAlarm(this.timer, () => {
            this.setA(false);
        });
        this.alarmB = new timer32_1.Timer32PeriodicAlarm(this.timer, () => {
            this.setB(false);
        });
        this.alarmBottom = new timer32_1.Timer32PeriodicAlarm(this.timer, () => this.wrap());
        this.csr = 0;
        this.div = 0;
        this.cc = 0;
        this.top = 0;
        this.lastBValue = false;
        this.countingUp = true;
        this.ccUpdated = false;
        this.topUpdated = false;
        this.tickCounter = 0;
        this.divMode = PWMDivMode.FreeRunning;
        // GPIO pin indices: Table 525. Mapping of PWM channels to GPIO pins on RP2040
        this.pinA1 = this.index * 2;
        this.pinB1 = this.index * 2 + 1;
        this.pinA2 = this.index < 7 ? 16 + this.index * 2 + 1 : -1;
        this.pinB2 = this.index < 7 ? 16 + this.index * 2 + 1 : -1;
        this.alarmA.enable = true;
        this.alarmB.enable = true;
        this.alarmBottom.enable = true;
    }
    readRegister(offset) {
        switch (offset) {
            case CHn_CSR:
                return this.csr;
            case CHn_DIV:
                return this.div;
            case CHn_CTR:
                return this.timer.counter;
            case CHn_CC:
                return this.cc;
            case CHn_TOP:
                return this.top;
        }
        /* Shouldn't get here */
        return 0;
    }
    writeRegister(offset, value) {
        switch (offset) {
            case CHn_CSR:
                if (value & CSR_EN && !(this.csr & CSR_EN)) {
                    this.updateDoubleBuffered();
                }
                this.csr = value & ~(CSR_PH_ADV | CSR_PH_RET);
                if (this.csr & CSR_PH_ADV) {
                    this.timer.advance(1);
                }
                if (this.csr & CSR_PH_RET) {
                    this.timer.advance(-1);
                }
                this.divMode = (this.csr >> CSR_DIVMODE_SHIFT) & CSR_DIVMODE_MASK;
                this.setBDirection(this.divMode === PWMDivMode.FreeRunning);
                this.updateEnable();
                this.lastBValue = this.gpioBValue;
                this.timer.mode = value & CSR_PH_CORRECT ? timer32_1.TimerMode.ZigZag : timer32_1.TimerMode.Increment;
                break;
            case CHn_DIV: {
                this.div = value & 1048575;
                const intValue = (value >> 4) & 0xff;
                const fracValue = value & 0xf;
                this.timer.prescaler = (intValue ? intValue : 256) + fracValue / 16;
                break;
            }
            case CHn_CTR:
                this.timer.set(value & 0xffff);
                break;
            case CHn_CC:
                this.cc = value;
                this.ccUpdated = true;
                break;
            case CHn_TOP:
                this.top = value & 0xffff;
                this.topUpdated = true;
                break;
        }
    }
    reset() {
        this.writeRegister(CHn_CSR, 0);
        this.writeRegister(CHn_DIV, 0x01 << 4);
        this.writeRegister(CHn_CTR, 0);
        this.writeRegister(CHn_CC, 0);
        this.writeRegister(CHn_TOP, 0xffff);
        this.countingUp = true;
        this.timer.enable = false;
        this.timer.reset();
    }
    updateDoubleBuffered() {
        if (this.ccUpdated) {
            this.alarmB.target = this.cc >>> 16;
            this.alarmA.target = this.cc & 0xffff;
            this.ccUpdated = false;
        }
        if (this.topUpdated) {
            this.timer.top = this.top;
            this.topUpdated = false;
        }
    }
    wrap() {
        this.pwm.channelInterrupt(this.index);
        this.updateDoubleBuffered();
        if (!(this.csr & CSR_PH_CORRECT)) {
            this.setA(this.alarmA.target > 0);
            this.setB(this.alarmB.target > 0);
        }
    }
    setA(value) {
        if (this.csr & CSR_A_INV) {
            value = !value;
        }
        this.pwm.gpioSet(this.pinA1, value);
        if (this.pinA2 >= 0) {
            this.pwm.gpioSet(this.pinA2, value);
        }
    }
    setB(value) {
        if (this.csr & CSR_B_INV) {
            value = !value;
        }
        this.pwm.gpioSet(this.pinB1, value);
        if (this.pinB2 >= 0) {
            this.pwm.gpioSet(this.pinB2, value);
        }
    }
    get gpioBValue() {
        return (this.pwm.gpioRead(this.pinB1) || (this.pinB2 > 0 ? this.pwm.gpioRead(this.pinB2) : false));
    }
    setBDirection(value) {
        this.pwm.gpioSetDir(this.pinB1, value);
        if (this.pinB2 >= 0) {
            this.pwm.gpioSetDir(this.pinB2, value);
        }
    }
    gpioBChanged() {
        const value = this.gpioBValue;
        if (value === this.lastBValue) {
            return;
        }
        this.lastBValue = value;
        switch (this.divMode) {
            case PWMDivMode.BGated:
                this.updateEnable();
                break;
            case PWMDivMode.BRisingEdge:
                if (value) {
                    this.tickCounter++;
                }
                break;
            case PWMDivMode.BFallingEdge:
                if (!value) {
                    this.tickCounter++;
                }
                break;
        }
        if (this.tickCounter >= this.timer.prescaler) {
            this.timer.advance(1);
            this.tickCounter -= this.timer.prescaler;
        }
    }
    updateEnable() {
        const { csr, divMode } = this;
        const enable = !!(csr & CSR_EN);
        this.timer.enable =
            enable &&
                (divMode === PWMDivMode.FreeRunning || (divMode === PWMDivMode.BGated && this.gpioBValue));
    }
    set en(value) {
        if (value && !(this.csr & CSR_EN)) {
            this.updateDoubleBuffered();
        }
        if (value) {
            this.csr |= CSR_EN;
        }
        else {
            this.csr &= ~CSR_EN;
        }
        this.updateEnable();
    }
}
class RPPWM extends peripheral_1.BasePeripheral {
    constructor() {
        super(...arguments);
        this.channels = [
            new PWMChannel(this, this.rp2040.clock, 0),
            new PWMChannel(this, this.rp2040.clock, 1),
            new PWMChannel(this, this.rp2040.clock, 2),
            new PWMChannel(this, this.rp2040.clock, 3),
            new PWMChannel(this, this.rp2040.clock, 4),
            new PWMChannel(this, this.rp2040.clock, 5),
            new PWMChannel(this, this.rp2040.clock, 6),
            new PWMChannel(this, this.rp2040.clock, 7),
        ];
        this.intRaw = 0;
        this.intEnable = 0;
        this.intForce = 0;
        this.gpioValue = 0;
        this.gpioDirection = 0;
    }
    get intStatus() {
        return (this.intRaw & this.intEnable) | this.intForce;
    }
    readUint32(offset) {
        if (offset < EN) {
            const channel = Math.floor(offset / 0x14);
            return this.channels[channel].readRegister(offset % 0x14);
        }
        switch (offset) {
            case EN:
                return ((this.channels[7].en << 7) |
                    (this.channels[6].en << 6) |
                    (this.channels[5].en << 5) |
                    (this.channels[4].en << 4) |
                    (this.channels[3].en << 3) |
                    (this.channels[2].en << 2) |
                    (this.channels[1].en << 1) |
                    (this.channels[0].en << 0));
            case INTR:
                return this.intRaw;
            case INTE:
                return this.intEnable;
            case INTF:
                return this.intForce;
            case INTS:
                return this.intStatus;
        }
        return super.readUint32(offset);
    }
    writeUint32(offset, value) {
        if (offset < EN) {
            const channel = Math.floor(offset / 0x14);
            return this.channels[channel].writeRegister(offset % 0x14, value);
        }
        switch (offset) {
            case EN:
                this.channels[7].en = value & (1 << 7);
                this.channels[6].en = value & (1 << 6);
                this.channels[5].en = value & (1 << 5);
                this.channels[4].en = value & (1 << 4);
                this.channels[3].en = value & (1 << 3);
                this.channels[2].en = value & (1 << 2);
                this.channels[1].en = value & (1 << 1);
                this.channels[0].en = value & (1 << 0);
                break;
            case INTR:
                this.intRaw &= ~(value & INT_MASK);
                this.checkInterrupts();
                break;
            case INTE:
                this.intEnable = value & INT_MASK;
                this.checkInterrupts();
                break;
            case INTF:
                this.intForce = value & INT_MASK;
                this.checkInterrupts();
                break;
            default:
                super.writeUint32(offset, value);
        }
    }
    get clockFreq() {
        return this.rp2040.clkSys;
    }
    channelInterrupt(index) {
        this.intRaw |= 1 << index;
        this.checkInterrupts();
        // We also set the DMA Request (DREQ) for the channel
        this.rp2040.dma.setDREQ(dma_1.DREQChannel.DREQ_PWM_WRAP0 + index);
    }
    checkInterrupts() {
        this.rp2040.setInterrupt(irq_1.IRQ.PWM_WRAP, !!this.intStatus);
    }
    gpioSet(index, value) {
        const bit = 1 << index;
        const newGpioValue = value ? this.gpioValue | bit : this.gpioValue & ~bit;
        if (this.gpioValue != newGpioValue) {
            this.gpioValue = newGpioValue;
            this.rp2040.gpio[index].checkForUpdates();
        }
    }
    gpioSetDir(index, output) {
        const bit = 1 << index;
        const newGpioDirection = output ? this.gpioDirection | bit : this.gpioDirection & ~bit;
        if (this.gpioDirection != newGpioDirection) {
            this.gpioDirection = newGpioDirection;
            this.rp2040.gpio[index].checkForUpdates();
        }
    }
    gpioRead(index) {
        return this.rp2040.gpio[index].inputValue;
    }
    gpioOnInput(index) {
        if (this.gpioDirection && 1 << index) {
            return;
        }
        for (const channel of this.channels) {
            if (channel.pinB1 === index || channel.pinB2 === index) {
                channel.gpioBChanged();
            }
        }
    }
    reset() {
        this.gpioDirection = 0xffffffff;
        for (const channel of this.channels) {
            channel.reset();
        }
    }
}
exports.RPPWM = RPPWM;


/***/ }),

/***/ 2097:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RPReset = void 0;
const peripheral_1 = __nccwpck_require__(4223);
const RESET = 0x0; //Reset control.
const WDSEL = 0x4; //Watchdog select.
const RESET_DONE = 0x8; //Reset Done
class RPReset extends peripheral_1.BasePeripheral {
    constructor() {
        super(...arguments);
        this.reset = 0;
        this.wdsel = 0;
        this.reset_done = 0x1ffffff;
    }
    readUint32(offset) {
        switch (offset) {
            case RESET:
                return this.reset;
            case WDSEL:
                return this.wdsel;
            case RESET_DONE:
                return this.reset_done;
        }
        return super.readUint32(offset);
    }
    writeUint32(offset, value) {
        switch (offset) {
            case RESET:
                this.reset = value & 0x1ffffff;
                break;
            case WDSEL:
                this.wdsel = value & 0x1ffffff;
                break;
            default:
                super.writeUint32(offset, value);
                break;
        }
    }
}
exports.RPReset = RPReset;


/***/ }),

/***/ 5432:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RP2040RTC = void 0;
const peripheral_1 = __nccwpck_require__(4223);
const RTC_SETUP0 = 0x04;
const RTC_SETUP1 = 0x08;
const RTC_CTRL = 0x0c;
const IRQ_SETUP_0 = 0x10;
const RTC_RTC1 = 0x18;
const RTC_RTC0 = 0x1c;
const RTC_ENABLE_BITS = 0x01;
const RTC_ACTIVE_BITS = 0x2;
const RTC_LOAD_BITS = 0x10;
class RP2040RTC extends peripheral_1.BasePeripheral {
    constructor() {
        super(...arguments);
        this.setup0 = 0;
        this.setup1 = 0;
        this.rtc1 = 0;
        this.rtc0 = 0;
        this.ctrl = 0;
    }
    readUint32(offset) {
        switch (offset) {
            case RTC_SETUP0:
                return this.setup0;
            case RTC_SETUP1:
                return this.setup1;
            case RTC_CTRL:
                return this.ctrl;
            case IRQ_SETUP_0:
                return 0;
            case RTC_RTC1:
                return this.rtc1;
            case RTC_RTC0:
                return this.rtc0;
        }
        return super.readUint32(offset);
    }
    writeUint32(offset, value) {
        switch (offset) {
            case RTC_SETUP0:
                this.setup0 = value;
                break;
            case RTC_SETUP1:
                this.setup1 = value;
                break;
            case RTC_CTRL:
                // Though RTC_LOAD_BITS is type SC and should be cleared on next cycle, pico-sdk write
                // RTC_LOAD_BITS & RTC_ENABLE_BITS seperatly.
                // https://github.com/raspberrypi/pico-sdk/blob/master/src/rp2_common/hardware_rtc/rtc.c#L76-L80
                if (value & RTC_LOAD_BITS) {
                    this.ctrl |= RTC_LOAD_BITS;
                }
                if (value & RTC_ENABLE_BITS) {
                    this.ctrl |= RTC_ENABLE_BITS;
                    this.ctrl |= RTC_ACTIVE_BITS;
                    if (this.ctrl & RTC_LOAD_BITS) {
                        this.rtc1 = this.setup0;
                        this.rtc0 = this.setup1;
                        this.ctrl &= ~RTC_LOAD_BITS;
                    }
                }
                else {
                    this.ctrl &= ~RTC_ENABLE_BITS;
                    this.ctrl &= ~RTC_ACTIVE_BITS;
                }
                break;
            default:
                super.writeUint32(offset, value);
        }
    }
}
exports.RP2040RTC = RP2040RTC;


/***/ }),

/***/ 5360:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RPSPI = void 0;
const fifo_1 = __nccwpck_require__(4677);
const peripheral_1 = __nccwpck_require__(4223);
const SSPCR0 = 0x000; // Control register 0, SSPCR0 on page 3-4
const SSPCR1 = 0x004; // Control register 1, SSPCR1 on page 3-5
const SSPDR = 0x008; // Data register, SSPDR on page 3-6
const SSPSR = 0x00c; // Status register, SSPSR on page 3-7
const SSPCPSR = 0x010; // Clock prescale register, SSPCPSR on page 3-8
const SSPIMSC = 0x014; // Interrupt mask set or clear register, SSPIMSC on page 3-9
const SSPRIS = 0x018; // Raw interrupt status register, SSPRIS on page 3-10
const SSPMIS = 0x01c; // Masked interrupt status register, SSPMIS on page 3-11
const SSPICR = 0x020; // Interrupt clear register, SSPICR on page 3-11
const SSPDMACR = 0x024; // DMA control register, SSPDMACR on page 3-12
const SSPPERIPHID0 = 0xfe0; // Peripheral identification registers, SSPPeriphID0-3 on page 3-13
const SSPPERIPHID1 = 0xfe4; // Peripheral identification registers, SSPPeriphID0-3 on page 3-13
const SSPPERIPHID2 = 0xfe8; // Peripheral identification registers, SSPPeriphID0-3 on page 3-13
const SSPPERIPHID3 = 0xfec; // Peripheral identification registers, SSPPeriphID0-3 on page 3-13
const SSPPCELLID0 = 0xff0; // PrimeCell identification registers, SSPPCellID0-3 on page 3-16
const SSPPCELLID1 = 0xff4; // PrimeCell identification registers, SSPPCellID0-3 on page 3-16
const SSPPCELLID2 = 0xff8; // PrimeCell identification registers, SSPPCellID0-3 on page 3-16
const SSPPCELLID3 = 0xffc; // PrimeCell identification registers, SSPPCellID0-3 on page 3-16
// SSPCR0 bits:
const SCR_MASK = 0xff;
const SCR_SHIFT = 8;
const SPH = 1 << 7;
const SPO = 1 << 6;
const FRF_MASK = 0x3;
const FRF_SHIFT = 4;
const DSS_MASK = 0xf;
const DSS_SHIFT = 0;
// SSPCR1 bits:
const SOD = 1 << 3;
const MS = 1 << 2;
const SSE = 1 << 1;
const LBM = 1 << 0;
// SSPSR bits:
const BSY = 1 << 4;
const RFF = 1 << 3;
const RNE = 1 << 2;
const TNF = 1 << 1;
const TFE = 1 << 0;
// SSPCPSR bits:
const CPSDVSR_MASK = 0xfe;
const CPSDVSR_SHIFT = 0;
// SSPDMACR bits:
const TXDMAE = 1 << 1;
const RXDMAE = 1 << 0;
// Interrupts:
const SSPTXINTR = 1 << 3;
const SSPRXINTR = 1 << 2;
const SSPRTINTR = 1 << 1;
const SSPRORINTR = 1 << 0;
class RPSPI extends peripheral_1.BasePeripheral {
    constructor(rp2040, name, irq) {
        super(rp2040, name);
        this.irq = irq;
        this.rxFIFO = new fifo_1.FIFO(8);
        this.txFIFO = new fifo_1.FIFO(8);
        // User provided callbacks
        this.onTransmit = () => this.completeTransmit(0);
        this.busy = false;
        this.control0 = 0;
        this.control1 = 0;
        this.dmaControl = 0;
        this.clockDivisor = 0;
        this.intRaw = 0;
        this.intEnable = 0;
    }
    get intStatus() {
        return this.intRaw & this.intEnable;
    }
    get enabled() {
        return !!(this.control1 & SSE);
    }
    /** Data size in bits: 4 to 16 bits */
    get dataBits() {
        return ((this.control0 >> DSS_SHIFT) & DSS_MASK) + 1;
    }
    get masterMode() {
        return !(this.control0 & MS);
    }
    get spiMode() {
        const cpol = this.control0 & SPO;
        const cpha = this.control0 & SPH;
        return cpol ? (cpha ? 2 : 3) : cpha ? 1 : 0;
    }
    get clockFrequency() {
        if (!this.clockDivisor) {
            return 0;
        }
        const scr = (this.control0 >> SCR_SHIFT) & SCR_MASK;
        return this.rp2040.clkPeri / (this.clockDivisor * (1 + scr));
    }
    doTX() {
        if (!this.busy && !this.txFIFO.empty) {
            const value = this.txFIFO.pull();
            this.busy = true;
            this.onTransmit(value);
            this.fifosUpdated();
        }
    }
    completeTransmit(rxValue) {
        this.busy = false;
        if (!this.rxFIFO.full) {
            this.rxFIFO.push(rxValue);
        }
        else {
            this.intRaw |= SSPRORINTR;
        }
        this.fifosUpdated();
        this.doTX();
    }
    checkInterrupts() {
        this.rp2040.setInterrupt(this.irq, !!this.intStatus);
    }
    fifosUpdated() {
        const prevStatus = this.intStatus;
        if (this.txFIFO.itemCount <= this.txFIFO.size / 2) {
            this.intRaw |= SSPTXINTR;
        }
        else {
            this.intRaw &= ~SSPTXINTR;
        }
        if (this.rxFIFO.itemCount >= this.rxFIFO.size / 2) {
            this.intRaw |= SSPRXINTR;
        }
        else {
            this.intRaw &= ~SSPRXINTR;
        }
        if (this.intStatus !== prevStatus) {
            this.checkInterrupts();
        }
    }
    readUint32(offset) {
        switch (offset) {
            case SSPCR0:
                return this.control0;
            case SSPCR1:
                return this.control1;
            case SSPDR:
                if (!this.rxFIFO.empty) {
                    const value = this.rxFIFO.pull();
                    this.fifosUpdated();
                    return value;
                }
                return 0;
            case SSPSR:
                return ((this.busy || !this.txFIFO.empty ? BSY : 0) |
                    (this.rxFIFO.full ? RFF : 0) |
                    (!this.rxFIFO.empty ? RNE : 0) |
                    (!this.txFIFO.full ? TNF : 0) |
                    (this.txFIFO.empty ? TFE : 0));
            case SSPCPSR:
                return this.clockDivisor;
            case SSPIMSC:
                return this.intEnable;
            case SSPRIS:
                return this.intRaw;
            case SSPMIS:
                return this.intStatus;
            case SSPDMACR:
                return this.dmaControl;
            case SSPPERIPHID0:
                return 0x22;
            case SSPPERIPHID1:
                return 0x10;
            case SSPPERIPHID2:
                return 0x34;
            case SSPPERIPHID3:
                return 0x00;
            case SSPPCELLID0:
                return 0x0d;
            case SSPPCELLID1:
                return 0xf0;
            case SSPPCELLID2:
                return 0x05;
            case SSPPCELLID3:
                return 0xb1;
        }
        return super.readUint32(offset);
    }
    writeUint32(offset, value) {
        switch (offset) {
            case SSPCR0:
                this.control0 = value;
                return;
            case SSPCR1:
                this.control1 = value;
                return;
            case SSPDR:
                if (!this.txFIFO.full) {
                    this.txFIFO.push(value);
                    this.doTX();
                    this.fifosUpdated();
                }
                return;
            case SSPCPSR:
                this.clockDivisor = value & CPSDVSR_MASK;
                return;
            case SSPIMSC:
                this.intEnable = value;
                this.checkInterrupts();
                return;
            case SSPDMACR:
                this.dmaControl = value;
                return;
            case SSPICR:
                this.intRaw &= ~(value & (SSPRTINTR | SSPRORINTR));
                this.checkInterrupts();
                return;
            default:
                super.writeUint32(offset, value);
        }
    }
}
exports.RPSPI = RPSPI;


/***/ }),

/***/ 5160:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RPSSI = void 0;
const peripheral_1 = __nccwpck_require__(4223);
const SSI_TXFLR = 0x00000020;
const SSI_RXFLR = 0x00000024;
const SSI_SR = 0x00000028;
const SSI_DR0 = 0x00000060;
const SSI_SR_TFNF_BITS = 0x00000002;
const SSI_SR_TFE_BITS = 0x00000004;
const SSI_SR_RFNE_BITS = 0x00000008;
const CMD_READ_STATUS = 0x05;
class RPSSI extends peripheral_1.BasePeripheral {
    constructor() {
        super(...arguments);
        this.dr0 = 0;
    }
    readUint32(offset) {
        switch (offset) {
            case SSI_TXFLR:
                return 0;
            case SSI_RXFLR:
                return 0;
            case SSI_SR:
                return SSI_SR_TFE_BITS | SSI_SR_RFNE_BITS | SSI_SR_TFNF_BITS;
            case SSI_DR0:
                return this.dr0;
        }
        return super.readUint32(offset);
    }
    writeUint32(offset, value) {
        switch (offset) {
            case SSI_DR0:
                if (value === CMD_READ_STATUS) {
                    this.dr0 = 0; // tell stage2 that we completed a write
                }
                return;
            default:
                super.writeUint32(offset, value);
        }
    }
}
exports.RPSSI = RPSSI;


/***/ }),

/***/ 6197:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RP2040SysCfg = void 0;
const peripheral_1 = __nccwpck_require__(4223);
const PROC0_NMI_MASK = 0;
// eslint-disable-next-line @typescript-eslint/no-unused-vars
const PROC1_NMI_MASK = 4;
class RP2040SysCfg extends peripheral_1.BasePeripheral {
    readUint32(offset) {
        switch (offset) {
            case PROC0_NMI_MASK:
                return this.rp2040.core.interruptNMIMask;
        }
        return super.readUint32(offset);
    }
    writeUint32(offset, value) {
        switch (offset) {
            case PROC0_NMI_MASK:
                this.rp2040.core.interruptNMIMask = value;
                break;
            default:
                super.writeUint32(offset, value);
        }
    }
}
exports.RP2040SysCfg = RP2040SysCfg;


/***/ }),

/***/ 4632:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RP2040SysInfo = void 0;
const peripheral_1 = __nccwpck_require__(4223);
const CHIP_ID = 0;
const PLATFORM = 0x4;
const GITREF_RP2040 = 0x40;
class RP2040SysInfo extends peripheral_1.BasePeripheral {
    readUint32(offset) {
        // All the values here were verified against the silicon
        switch (offset) {
            case CHIP_ID:
                return 0x10002927;
            case PLATFORM:
                return 0x00000002;
            case GITREF_RP2040:
                return 0xe0c912e8;
        }
        return super.readUint32(offset);
    }
}
exports.RP2040SysInfo = RP2040SysInfo;


/***/ }),

/***/ 5591:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RPTBMAN = void 0;
const peripheral_1 = __nccwpck_require__(4223);
const PLATFORM = 0;
const ASIC = 1;
class RPTBMAN extends peripheral_1.BasePeripheral {
    readUint32(offset) {
        switch (offset) {
            case PLATFORM:
                return ASIC;
            default:
                return super.readUint32(offset);
        }
    }
}
exports.RPTBMAN = RPTBMAN;


/***/ }),

/***/ 1993:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RPTimer = void 0;
const irq_1 = __nccwpck_require__(679);
const peripheral_1 = __nccwpck_require__(4223);
const TIMEHR = 0x08;
const TIMELR = 0x0c;
const TIMERAWH = 0x24;
const TIMERAWL = 0x28;
const ALARM0 = 0x10;
const ALARM1 = 0x14;
const ALARM2 = 0x18;
const ALARM3 = 0x1c;
const ARMED = 0x20;
const PAUSE = 0x30;
const INTR = 0x34;
const INTE = 0x38;
const INTF = 0x3c;
const INTS = 0x40;
const ALARM_0 = 1 << 0;
const ALARM_1 = 1 << 1;
const ALARM_2 = 1 << 2;
const ALARM_3 = 1 << 3;
const timerInterrupts = [irq_1.IRQ.TIMER_0, irq_1.IRQ.TIMER_1, irq_1.IRQ.TIMER_2, irq_1.IRQ.TIMER_3];
class RPTimerAlarm {
    constructor(name, bitValue) {
        this.name = name;
        this.bitValue = bitValue;
        this.armed = false;
        this.targetMicros = 0;
        this.timer = null;
    }
}
class RPTimer extends peripheral_1.BasePeripheral {
    constructor(rp2040, name) {
        super(rp2040, name);
        this.latchedTimeHigh = 0;
        this.alarms = [
            new RPTimerAlarm('Alarm 0', ALARM_0),
            new RPTimerAlarm('Alarm 1', ALARM_1),
            new RPTimerAlarm('Alarm 2', ALARM_2),
            new RPTimerAlarm('Alarm 3', ALARM_3),
        ];
        this.intRaw = 0;
        this.intEnable = 0;
        this.intForce = 0;
        this.paused = false;
        this.clock = rp2040.clock;
    }
    get intStatus() {
        return (this.intRaw & this.intEnable) | this.intForce;
    }
    readUint32(offset) {
        const time = this.clock.micros;
        switch (offset) {
            case TIMEHR:
                return this.latchedTimeHigh;
            case TIMELR:
                this.latchedTimeHigh = Math.floor(time / Math.pow(2, 32));
                return time >>> 0;
            case TIMERAWH:
                return Math.floor(time / Math.pow(2, 32));
            case TIMERAWL:
                return time >>> 0;
            case ALARM0:
                return this.alarms[0].targetMicros;
            case ALARM1:
                return this.alarms[1].targetMicros;
            case ALARM2:
                return this.alarms[2].targetMicros;
            case ALARM3:
                return this.alarms[3].targetMicros;
            case PAUSE:
                return this.paused ? 1 : 0;
            case INTR:
                return this.intRaw;
            case INTE:
                return this.intEnable;
            case INTF:
                return this.intForce;
            case INTS:
                return this.intStatus;
            case ARMED:
                return ((this.alarms[0].armed ? this.alarms[0].bitValue : 0) |
                    (this.alarms[1].armed ? this.alarms[1].bitValue : 0) |
                    (this.alarms[2].armed ? this.alarms[2].bitValue : 0) |
                    (this.alarms[3].armed ? this.alarms[3].bitValue : 0));
        }
        return super.readUint32(offset);
    }
    writeUint32(offset, value) {
        switch (offset) {
            case ALARM0:
            case ALARM1:
            case ALARM2:
            case ALARM3: {
                const alarmIndex = (offset - ALARM0) / 4;
                const alarm = this.alarms[alarmIndex];
                const delta = (value - this.clock.micros) >>> 0;
                this.disarmAlarm(alarm);
                alarm.armed = true;
                alarm.targetMicros = value;
                alarm.timer = this.clock.createTimer(delta, () => this.fireAlarm(alarmIndex));
                break;
            }
            case ARMED:
                for (const alarm of this.alarms) {
                    if (this.rawWriteValue & alarm.bitValue) {
                        this.disarmAlarm(alarm);
                    }
                }
                break;
            case PAUSE:
                this.paused = !!(value & 1);
                if (this.paused) {
                    this.warn('Unimplemented Timer Pause');
                }
                // TODO actually pause the timer
                break;
            case INTR:
                this.intRaw &= ~this.rawWriteValue;
                this.checkInterrupts();
                break;
            case INTE:
                this.intEnable = value & 0xf;
                this.checkInterrupts();
                break;
            case INTF:
                this.intForce = value & 0xf;
                this.checkInterrupts();
                break;
            default:
                super.writeUint32(offset, value);
        }
    }
    fireAlarm(index) {
        const alarm = this.alarms[index];
        this.disarmAlarm(alarm);
        this.intRaw |= alarm.bitValue;
        this.checkInterrupts();
    }
    checkInterrupts() {
        const { intStatus } = this;
        for (let i = 0; i < this.alarms.length; i++) {
            this.rp2040.setInterrupt(timerInterrupts[i], !!(intStatus & (1 << i)));
        }
    }
    disarmAlarm(alarm) {
        if (alarm.timer) {
            this.clock.deleteTimer(alarm.timer);
            alarm.timer = null;
        }
        alarm.armed = false;
    }
}
exports.RPTimer = RPTimer;


/***/ }),

/***/ 4753:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RPUART = void 0;
const fifo_1 = __nccwpck_require__(4677);
const peripheral_1 = __nccwpck_require__(4223);
const UARTDR = 0x0;
const UARTFR = 0x18;
const UARTLCR_H = 0x2c;
const UARTCR = 0x30;
const UARTIMSC = 0x38;
const UARTIRIS = 0x3c;
const UARTIMIS = 0x40;
const UARTICR = 0x44;
// UARTFR bits:
const TXFE = 1 << 7;
const RXFF = 1 << 6;
const RXFE = 1 << 4;
// UARTLCR_H bits:
const FEN = 1 << 4;
// UARTCR bits:
const RXE = 1 << 9;
const TXE = 1 << 8;
const UARTEN = 1 << 0;
// Interrupt bits
const UARTRXINTR = 1 << 4;
class RPUART extends peripheral_1.BasePeripheral {
    constructor(rp2040, name, irq) {
        super(rp2040, name);
        this.irq = irq;
        this.ctrlRegister = RXE | TXE;
        this.lineCtrlRegister = 0;
        this.rxFIFO = new fifo_1.FIFO(32);
        this.interruptMask = 0;
        this.interruptStatus = 0;
    }
    get enabled() {
        return !!(this.ctrlRegister & UARTEN);
    }
    get txEnabled() {
        return !!(this.ctrlRegister & TXE);
    }
    get rxEnabled() {
        return !!(this.ctrlRegister & RXE);
    }
    get fifosEnabled() {
        return !!(this.lineCtrlRegister & FEN);
    }
    /**
     * Number of bits per UART character
     */
    get wordLength() {
        switch ((this.lineCtrlRegister >>> 5) & 0x3) {
            case 0b00:
                return 5;
            case 0b01:
                return 6;
            case 0b10:
                return 7;
            case 0b11:
                return 8;
        }
    }
    get flags() {
        return (this.rxFIFO.full ? RXFF : 0) | (this.rxFIFO.empty ? RXFE : 0) | TXFE;
    }
    checkInterrupts() {
        this.rp2040.setInterrupt(this.irq, !!(this.interruptStatus & this.interruptMask));
    }
    feedByte(value) {
        this.rxFIFO.push(value);
        // TODO check if the FIFO has reached the threshold level
        this.interruptStatus |= UARTRXINTR;
        this.checkInterrupts();
    }
    readUint32(offset) {
        switch (offset) {
            case UARTDR: {
                const value = this.rxFIFO.pull();
                if (!this.rxFIFO.empty) {
                    this.interruptStatus |= UARTRXINTR;
                    this.checkInterrupts();
                }
                return value;
            }
            case UARTFR:
                return this.flags;
            case UARTLCR_H:
                return this.lineCtrlRegister;
            case UARTCR:
                return this.ctrlRegister;
            case UARTIMSC:
                return this.interruptMask;
            case UARTIRIS:
                return this.interruptStatus;
            case UARTIMIS:
                return this.interruptStatus & this.interruptMask;
        }
        return super.readUint32(offset);
    }
    writeUint32(offset, value) {
        var _a;
        switch (offset) {
            case UARTDR:
                (_a = this.onByte) === null || _a === void 0 ? void 0 : _a.call(this, value & 0xff);
                break;
            case UARTLCR_H:
                this.lineCtrlRegister = value;
                break;
            case UARTCR:
                this.ctrlRegister = value;
                break;
            case UARTIMSC:
                this.interruptMask = value & 0x7ff;
                this.checkInterrupts();
                break;
            case UARTICR:
                this.interruptStatus &= ~this.rawWriteValue;
                this.checkInterrupts();
                break;
            default:
                super.writeUint32(offset, value);
        }
    }
}
exports.RPUART = RPUART;


/***/ }),

/***/ 5626:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RPUSBController = void 0;
const irq_1 = __nccwpck_require__(679);
const peripheral_1 = __nccwpck_require__(4223);
// USB DPSRAM Registers
const EP1_IN_CONTROL = 0x8;
const EP0_IN_BUFFER_CONTROL = 0x80;
const EP0_OUT_BUFFER_CONTROL = 0x84;
const EP15_OUT_BUFFER_CONTROL = 0xfc;
// Endpoint Control bits
const USB_CTRL_DOUBLE_BUF = 1 << 30;
const USB_CTRL_INTERRUPT_PER_TRANSFER = 1 << 29;
// Buffer Control bits
const USB_BUF_CTRL_AVAILABLE = 1 << 10;
const USB_BUF_CTRL_FULL = 1 << 15;
const USB_BUF_CTRL_LEN_MASK = 0x3ff;
// Buffer1
const USB_BUF1_SHIFT = 16;
const USB_BUF1_OFFSET = 64;
// USB Peripheral Register
const MAIN_CTRL = 0x40;
const SIE_STATUS = 0x50;
const BUFF_STATUS = 0x58;
const BUFF_CPU_SHOULD_HANDLE = 0x5c;
const USB_MUXING = 0x74;
const INTR = 0x8c;
const INTE = 0x90;
const INTF = 0x94;
const INTS = 0x98;
// MAIN_CTRL bits
const SIM_TIMING = 1 << 31;
const HOST_NDEVICE = 1 << 1;
const CONTROLLER_EN = 1 << 0;
// SIE_STATUS bits
const SIE_DATA_SEQ_ERROR = 1 << 31;
const SIE_ACK_REC = 1 << 30;
const SIE_STALL_REC = 1 << 29;
const SIE_NAK_REC = 1 << 28;
const SIE_RX_TIMEOUT = 1 << 27;
const SIE_RX_OVERFLOW = 1 << 26;
const SIE_BIT_STUFF_ERROR = 1 << 25;
const SIE_CRC_ERROR = 1 << 24;
const SIE_BUS_RESET = 1 << 19;
const SIE_TRANS_COMPLETE = 1 << 18;
const SIE_SETUP_REC = 1 << 17;
const SIE_CONNECTED = 1 << 16;
const SIE_RESUME = 1 << 11;
const SIE_VBUS_OVER_CURR = 1 << 10;
const SIE_SPEED = 1 << 9;
const SIE_SUSPENDED = 1 << 4;
const SIE_LINE_STATE_MASK = 0x3;
const SIE_LINE_STATE_SHIFT = 2;
const SIE_VBUS_DETECTED = 1 << 0;
// USB_MUXING bits
const SOFTCON = 1 << 3;
const TO_DIGITAL_PAD = 1 << 2;
const TO_EXTPHY = 1 << 1;
const TO_PHY = 1 << 0;
// INTR bits
const INTR_BUFF_STATUS = 1 << 4;
// SIE Line states
var SIELineState;
(function (SIELineState) {
    SIELineState[SIELineState["SE0"] = 0] = "SE0";
    SIELineState[SIELineState["J"] = 1] = "J";
    SIELineState[SIELineState["K"] = 2] = "K";
    SIELineState[SIELineState["SE1"] = 3] = "SE1";
})(SIELineState || (SIELineState = {}));
const SIE_WRITECLEAR_MASK = SIE_DATA_SEQ_ERROR |
    SIE_ACK_REC |
    SIE_STALL_REC |
    SIE_NAK_REC |
    SIE_RX_TIMEOUT |
    SIE_RX_OVERFLOW |
    SIE_BIT_STUFF_ERROR |
    SIE_CONNECTED |
    SIE_CRC_ERROR |
    SIE_BUS_RESET |
    SIE_TRANS_COMPLETE |
    SIE_SETUP_REC |
    SIE_RESUME;
class RPUSBController extends peripheral_1.BasePeripheral {
    constructor() {
        super(...arguments);
        this.mainCtrl = 0;
        this.intRaw = 0;
        this.intEnable = 0;
        this.intForce = 0;
        this.sieStatus = 0;
        this.buffStatus = 0;
        this.readDelayMicroseconds = 1;
        this.writeDelayMicroseconds = 1;
    }
    get intStatus() {
        return (this.intRaw & this.intEnable) | this.intForce;
    }
    readUint32(offset) {
        switch (offset) {
            case MAIN_CTRL:
                return this.mainCtrl;
            case SIE_STATUS:
                return this.sieStatus;
            case BUFF_STATUS:
                return this.buffStatus;
            case BUFF_CPU_SHOULD_HANDLE:
                return 0;
            case INTR:
                return this.intRaw;
            case INTE:
                return this.intEnable;
            case INTF:
                return this.intForce;
            case INTS:
                return this.intStatus;
        }
        return super.readUint32(offset);
    }
    writeUint32(offset, value) {
        var _a, _b;
        switch (offset) {
            case MAIN_CTRL:
                this.mainCtrl = value & (SIM_TIMING | CONTROLLER_EN | HOST_NDEVICE);
                if (value & CONTROLLER_EN && !(value & HOST_NDEVICE)) {
                    (_a = this.onUSBEnabled) === null || _a === void 0 ? void 0 : _a.call(this);
                }
                break;
            case BUFF_STATUS:
                this.buffStatus &= ~this.rawWriteValue;
                this.buffStatusUpdated();
                break;
            case USB_MUXING:
                // Workaround for busy wait in hw_enumeration_fix_force_ls_j() / hw_enumeration_fix_finish():
                if (value & TO_DIGITAL_PAD && !(value & TO_PHY)) {
                    this.sieStatus |= SIE_CONNECTED;
                }
                break;
            case SIE_STATUS:
                this.sieStatus &= ~(this.rawWriteValue & SIE_WRITECLEAR_MASK);
                if (this.rawWriteValue & SIE_BUS_RESET) {
                    (_b = this.onResetReceived) === null || _b === void 0 ? void 0 : _b.call(this);
                    this.sieStatus &= ~(SIE_LINE_STATE_MASK << SIE_LINE_STATE_SHIFT);
                    this.sieStatus |= (SIELineState.J << SIE_LINE_STATE_SHIFT) | SIE_CONNECTED;
                }
                this.sieStatusUpdated();
                break;
            case INTE:
                this.intEnable = value & 0xfffff;
                this.checkInterrupts();
                break;
            case INTF:
                this.intForce = value & 0xfffff;
                this.checkInterrupts();
                break;
            default:
                super.writeUint32(offset, value);
        }
    }
    readEndpointControlReg(endpoint, out) {
        const controlRegOffset = EP1_IN_CONTROL + 8 * (endpoint - 1) + (out ? 4 : 0);
        return this.rp2040.usbDPRAMView.getUint32(controlRegOffset, true);
    }
    getEndpointBufferOffset(endpoint, out) {
        if (endpoint === 0) {
            return 0x100;
        }
        return this.readEndpointControlReg(endpoint, out) & 0xffc0;
    }
    DPRAMUpdated(offset, value) {
        var _a, _b, _c, _d;
        if (value & USB_BUF_CTRL_AVAILABLE &&
            offset >= EP0_IN_BUFFER_CONTROL &&
            offset <= EP15_OUT_BUFFER_CONTROL) {
            const endpoint = (offset - EP0_IN_BUFFER_CONTROL) >> 3;
            const bufferOut = offset & 4 ? true : false;
            let doubleBuffer = false;
            let interrupt = true;
            if (endpoint != 0) {
                const control = this.readEndpointControlReg(endpoint, bufferOut);
                doubleBuffer = !!(control & USB_CTRL_DOUBLE_BUF);
                interrupt = !!(control & USB_CTRL_INTERRUPT_PER_TRANSFER);
            }
            const bufferLength = value & USB_BUF_CTRL_LEN_MASK;
            const bufferOffset = this.getEndpointBufferOffset(endpoint, bufferOut);
            this.debug(`Start USB transfer, endPoint=${endpoint}, direction=${bufferOut ? 'out' : 'in'} buffer=${bufferOffset.toString(16)} length=${bufferLength}`);
            value &= ~USB_BUF_CTRL_AVAILABLE;
            this.rp2040.usbDPRAMView.setUint32(offset, value, true);
            if (bufferOut) {
                (_a = this.onEndpointRead) === null || _a === void 0 ? void 0 : _a.call(this, endpoint, bufferLength);
            }
            else {
                value &= ~USB_BUF_CTRL_FULL;
                this.rp2040.usbDPRAMView.setUint32(offset, value, true);
                const buffer = this.rp2040.usbDPRAM.slice(bufferOffset, bufferOffset + bufferLength);
                if (interrupt || !doubleBuffer) {
                    this.indicateBufferReady(endpoint, false);
                }
                if (this.writeDelayMicroseconds) {
                    this.rp2040.clock.createTimer(this.writeDelayMicroseconds, () => {
                        var _a;
                        (_a = this.onEndpointWrite) === null || _a === void 0 ? void 0 : _a.call(this, endpoint, buffer);
                    });
                }
                else {
                    (_b = this.onEndpointWrite) === null || _b === void 0 ? void 0 : _b.call(this, endpoint, buffer);
                }
            }
            if (doubleBuffer && (value >> USB_BUF1_SHIFT) & USB_BUF_CTRL_AVAILABLE) {
                const bufferLength = (value >> USB_BUF1_SHIFT) & USB_BUF_CTRL_LEN_MASK;
                const bufferOffset = this.getEndpointBufferOffset(endpoint, bufferOut) + USB_BUF1_OFFSET;
                this.debug(`Start USB transfer, endPoint=${endpoint}, direction=${bufferOut ? 'out' : 'in'} buffer=${bufferOffset.toString(16)} length=${bufferLength}`);
                value &= ~(USB_BUF_CTRL_AVAILABLE << USB_BUF1_SHIFT);
                this.rp2040.usbDPRAMView.setUint32(offset, value, true);
                if (bufferOut) {
                    (_c = this.onEndpointRead) === null || _c === void 0 ? void 0 : _c.call(this, endpoint, bufferLength);
                }
                else {
                    value &= ~(USB_BUF_CTRL_FULL << USB_BUF1_SHIFT);
                    this.rp2040.usbDPRAMView.setUint32(offset, value, true);
                    const buffer = this.rp2040.usbDPRAM.slice(bufferOffset, bufferOffset + bufferLength);
                    this.indicateBufferReady(endpoint, false);
                    if (this.writeDelayMicroseconds) {
                        this.rp2040.clock.createTimer(this.writeDelayMicroseconds, () => {
                            var _a;
                            (_a = this.onEndpointWrite) === null || _a === void 0 ? void 0 : _a.call(this, endpoint, buffer);
                        });
                    }
                    else {
                        (_d = this.onEndpointWrite) === null || _d === void 0 ? void 0 : _d.call(this, endpoint, buffer);
                    }
                }
            }
        }
    }
    endpointReadDone(endpoint, buffer, delay = this.readDelayMicroseconds) {
        if (delay) {
            this.rp2040.clock.createTimer(delay, () => {
                this.finishRead(endpoint, buffer);
            });
        }
        else {
            this.finishRead(endpoint, buffer);
        }
    }
    finishRead(endpoint, buffer) {
        const bufferOffset = this.getEndpointBufferOffset(endpoint, true);
        const bufControlReg = EP0_OUT_BUFFER_CONTROL + endpoint * 8;
        let bufControl = this.rp2040.usbDPRAMView.getUint32(bufControlReg, true);
        const requestedLength = bufControl & USB_BUF_CTRL_LEN_MASK;
        const newLength = Math.min(buffer.length, requestedLength);
        bufControl |= USB_BUF_CTRL_FULL;
        bufControl = (bufControl & ~USB_BUF_CTRL_LEN_MASK) | (newLength & USB_BUF_CTRL_LEN_MASK);
        this.rp2040.usbDPRAMView.setUint32(bufControlReg, bufControl, true);
        this.rp2040.usbDPRAM.set(buffer.subarray(0, newLength), bufferOffset);
        this.indicateBufferReady(endpoint, true);
    }
    checkInterrupts() {
        const { intStatus } = this;
        this.rp2040.setInterrupt(irq_1.IRQ.USBCTRL, !!intStatus);
    }
    resetDevice() {
        this.sieStatus |= SIE_BUS_RESET;
        this.sieStatusUpdated();
    }
    sendSetupPacket(setupPacket) {
        this.rp2040.usbDPRAM.set(setupPacket);
        this.sieStatus |= SIE_SETUP_REC;
        this.sieStatusUpdated();
    }
    indicateBufferReady(endpoint, out) {
        this.buffStatus |= 1 << (endpoint * 2 + (out ? 1 : 0));
        this.buffStatusUpdated();
    }
    buffStatusUpdated() {
        if (this.buffStatus) {
            this.intRaw |= INTR_BUFF_STATUS;
        }
        else {
            this.intRaw &= ~INTR_BUFF_STATUS;
        }
        this.checkInterrupts();
    }
    sieStatusUpdated() {
        const intRegisterMap = [
            [SIE_SETUP_REC, 1 << 16],
            [SIE_RESUME, 1 << 15],
            [SIE_SUSPENDED, 1 << 14],
            [SIE_CONNECTED, 1 << 13],
            [SIE_BUS_RESET, 1 << 12],
            [SIE_VBUS_DETECTED, 1 << 11],
            [SIE_STALL_REC, 1 << 10],
            [SIE_CRC_ERROR, 1 << 9],
            [SIE_BIT_STUFF_ERROR, 1 << 8],
            [SIE_RX_OVERFLOW, 1 << 7],
            [SIE_RX_TIMEOUT, 1 << 6],
            [SIE_DATA_SEQ_ERROR, 1 << 5],
        ];
        for (const [sieBit, intRawBit] of intRegisterMap) {
            if (this.sieStatus & sieBit) {
                this.intRaw |= intRawBit;
            }
            else {
                this.intRaw &= ~intRawBit;
            }
        }
        this.checkInterrupts();
    }
}
exports.RPUSBController = RPUSBController;


/***/ }),

/***/ 1038:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RP2040 = exports.SIO_START_ADDRESS = exports.DPRAM_START_ADDRESS = exports.APB_START_ADDRESS = exports.RAM_START_ADDRESS = exports.FLASH_START_ADDRESS = void 0;
const realtime_clock_1 = __nccwpck_require__(5938);
const cortex_m0_core_1 = __nccwpck_require__(4407);
const gpio_pin_1 = __nccwpck_require__(1810);
const irq_1 = __nccwpck_require__(679);
const adc_1 = __nccwpck_require__(5826);
const clocks_1 = __nccwpck_require__(2135);
const dma_1 = __nccwpck_require__(1253);
const i2c_1 = __nccwpck_require__(8563);
const io_1 = __nccwpck_require__(6787);
const pads_1 = __nccwpck_require__(1254);
const peripheral_1 = __nccwpck_require__(4223);
const pio_1 = __nccwpck_require__(514);
const ppb_1 = __nccwpck_require__(3635);
const pwm_1 = __nccwpck_require__(1020);
const reset_1 = __nccwpck_require__(2097);
const rtc_1 = __nccwpck_require__(5432);
const spi_1 = __nccwpck_require__(5360);
const ssi_1 = __nccwpck_require__(5160);
const syscfg_1 = __nccwpck_require__(6197);
const sysinfo_1 = __nccwpck_require__(4632);
const timer_1 = __nccwpck_require__(1993);
const uart_1 = __nccwpck_require__(4753);
const usb_1 = __nccwpck_require__(5626);
const sio_1 = __nccwpck_require__(7918);
const logging_1 = __nccwpck_require__(6057);
const tbman_1 = __nccwpck_require__(5591);
exports.FLASH_START_ADDRESS = 0x10000000;
exports.RAM_START_ADDRESS = 0x20000000;
exports.APB_START_ADDRESS = 0x40000000;
exports.DPRAM_START_ADDRESS = 0x50100000;
exports.SIO_START_ADDRESS = 0xd0000000;
const LOG_NAME = 'RP2040';
const KB = 1024;
const MB = 1024 * KB;
const MHz = 1000000;
class RP2040 {
    constructor(clock = new realtime_clock_1.RealtimeClock()) {
        this.clock = clock;
        this.bootrom = new Uint32Array(4 * KB);
        this.sram = new Uint8Array(264 * KB);
        this.sramView = new DataView(this.sram.buffer);
        this.flash = new Uint8Array(16 * MB);
        this.flash16 = new Uint16Array(this.flash.buffer);
        this.flashView = new DataView(this.flash.buffer);
        this.usbDPRAM = new Uint8Array(4 * KB);
        this.usbDPRAMView = new DataView(this.usbDPRAM.buffer);
        this.core = new cortex_m0_core_1.CortexM0Core(this);
        /* Clocks */
        this.clkSys = 125 * MHz;
        this.clkPeri = 125 * MHz;
        this.ppb = new ppb_1.RPPPB(this, 'PPB');
        this.sio = new sio_1.RPSIO(this);
        this.uart = [new uart_1.RPUART(this, 'UART0', irq_1.IRQ.UART0), new uart_1.RPUART(this, 'UART1', irq_1.IRQ.UART1)];
        this.i2c = [new i2c_1.RPI2C(this, 'I2C0', irq_1.IRQ.I2C0), new i2c_1.RPI2C(this, 'I2C1', irq_1.IRQ.I2C1)];
        this.spi = [new spi_1.RPSPI(this, 'SPI0', irq_1.IRQ.SPI0), new spi_1.RPSPI(this, 'SPI1', irq_1.IRQ.SPI1)];
        this.pwm = new pwm_1.RPPWM(this, 'PWM_BASE');
        this.adc = new adc_1.RPADC(this, 'ADC');
        this.gpio = [
            new gpio_pin_1.GPIOPin(this, 0),
            new gpio_pin_1.GPIOPin(this, 1),
            new gpio_pin_1.GPIOPin(this, 2),
            new gpio_pin_1.GPIOPin(this, 3),
            new gpio_pin_1.GPIOPin(this, 4),
            new gpio_pin_1.GPIOPin(this, 5),
            new gpio_pin_1.GPIOPin(this, 6),
            new gpio_pin_1.GPIOPin(this, 7),
            new gpio_pin_1.GPIOPin(this, 8),
            new gpio_pin_1.GPIOPin(this, 9),
            new gpio_pin_1.GPIOPin(this, 10),
            new gpio_pin_1.GPIOPin(this, 11),
            new gpio_pin_1.GPIOPin(this, 12),
            new gpio_pin_1.GPIOPin(this, 13),
            new gpio_pin_1.GPIOPin(this, 14),
            new gpio_pin_1.GPIOPin(this, 15),
            new gpio_pin_1.GPIOPin(this, 16),
            new gpio_pin_1.GPIOPin(this, 17),
            new gpio_pin_1.GPIOPin(this, 18),
            new gpio_pin_1.GPIOPin(this, 19),
            new gpio_pin_1.GPIOPin(this, 20),
            new gpio_pin_1.GPIOPin(this, 21),
            new gpio_pin_1.GPIOPin(this, 22),
            new gpio_pin_1.GPIOPin(this, 23),
            new gpio_pin_1.GPIOPin(this, 24),
            new gpio_pin_1.GPIOPin(this, 25),
            new gpio_pin_1.GPIOPin(this, 26),
            new gpio_pin_1.GPIOPin(this, 27),
            new gpio_pin_1.GPIOPin(this, 28),
            new gpio_pin_1.GPIOPin(this, 29),
        ];
        this.qspi = [
            new gpio_pin_1.GPIOPin(this, 0, 'SCLK'),
            new gpio_pin_1.GPIOPin(this, 1, 'SS'),
            new gpio_pin_1.GPIOPin(this, 2, 'SD0'),
            new gpio_pin_1.GPIOPin(this, 3, 'SD1'),
            new gpio_pin_1.GPIOPin(this, 4, 'SD2'),
            new gpio_pin_1.GPIOPin(this, 5, 'SD3'),
        ];
        this.dma = new dma_1.RPDMA(this, 'DMA');
        this.pio = [
            new pio_1.RPPIO(this, 'PIO0', irq_1.IRQ.PIO0_IRQ0, 0),
            new pio_1.RPPIO(this, 'PIO1', irq_1.IRQ.PIO1_IRQ0, 1),
        ];
        this.usbCtrl = new usb_1.RPUSBController(this, 'USB');
        this.stopped = true;
        this.logger = new logging_1.ConsoleLogger(logging_1.LogLevel.Debug, true);
        this.executeTimer = null;
        this.peripherals = {
            0x18000: new ssi_1.RPSSI(this, 'SSI'),
            0x40000: new sysinfo_1.RP2040SysInfo(this, 'SYSINFO_BASE'),
            0x40004: new syscfg_1.RP2040SysCfg(this, 'SYSCFG'),
            0x40008: new clocks_1.RPClocks(this, 'CLOCKS_BASE'),
            0x4000c: new reset_1.RPReset(this, 'RESETS_BASE'),
            0x40010: new peripheral_1.UnimplementedPeripheral(this, 'PSM_BASE'),
            0x40014: new io_1.RPIO(this, 'IO_BANK0_BASE'),
            0x40018: new peripheral_1.UnimplementedPeripheral(this, 'IO_QSPI_BASE'),
            0x4001c: new pads_1.RPPADS(this, 'PADS_BANK0_BASE', 'bank0'),
            0x40020: new pads_1.RPPADS(this, 'PADS_QSPI_BASE', 'qspi'),
            0x40024: new peripheral_1.UnimplementedPeripheral(this, 'XOSC_BASE'),
            0x40028: new peripheral_1.UnimplementedPeripheral(this, 'PLL_SYS_BASE'),
            0x4002c: new peripheral_1.UnimplementedPeripheral(this, 'PLL_USB_BASE'),
            0x40030: new peripheral_1.UnimplementedPeripheral(this, 'BUSCTRL_BASE'),
            0x40034: this.uart[0],
            0x40038: this.uart[1],
            0x4003c: this.spi[0],
            0x40040: this.spi[1],
            0x40044: this.i2c[0],
            0x40048: this.i2c[1],
            0x4004c: this.adc,
            0x40050: this.pwm,
            0x40054: new timer_1.RPTimer(this, 'TIMER_BASE'),
            0x40058: new peripheral_1.UnimplementedPeripheral(this, 'WATCHDOG_BASE'),
            0x4005c: new rtc_1.RP2040RTC(this, 'RTC_BASE'),
            0x40060: new peripheral_1.UnimplementedPeripheral(this, 'ROSC_BASE'),
            0x40064: new peripheral_1.UnimplementedPeripheral(this, 'VREG_AND_CHIP_RESET_BASE'),
            0x4006c: new tbman_1.RPTBMAN(this, 'TBMAN_BASE'),
            0x50000: this.dma,
            0x50110: this.usbCtrl,
            0x50200: this.pio[0],
            0x50300: this.pio[1],
        };
        // Debugging
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        this.onBreak = (code) => {
            // TODO: raise HardFault exception
            // console.error('Breakpoint!', code);
            this.stopped = true;
        };
        this.reset();
    }
    loadBootrom(bootromData) {
        this.bootrom.set(bootromData);
        this.reset();
    }
    reset() {
        this.core.reset();
        this.pwm.reset();
        this.flash.fill(0xff);
    }
    readUint32(address) {
        address = address >>> 0; // round to 32-bits, unsigned
        if (address & 0x3) {
            this.logger.error(LOG_NAME, `read from address ${address.toString(16)}, which is not 32 bit aligned`);
        }
        const { bootrom } = this;
        if (address < bootrom.length * 4) {
            return bootrom[address / 4];
        }
        else if (address >= exports.FLASH_START_ADDRESS &&
            address < exports.FLASH_START_ADDRESS + this.flash.length) {
            return this.flashView.getUint32(address - exports.FLASH_START_ADDRESS, true);
        }
        else if (address >= exports.RAM_START_ADDRESS && address < exports.RAM_START_ADDRESS + this.sram.length) {
            return this.sramView.getUint32(address - exports.RAM_START_ADDRESS, true);
        }
        else if (address >= exports.DPRAM_START_ADDRESS &&
            address < exports.DPRAM_START_ADDRESS + this.usbDPRAM.length) {
            return this.usbDPRAMView.getUint32(address - exports.DPRAM_START_ADDRESS, true);
        }
        else if (address >>> 12 === 0xe000e) {
            return this.ppb.readUint32(address & 0xfff);
        }
        else if (address >= exports.SIO_START_ADDRESS && address < exports.SIO_START_ADDRESS + 0x10000000) {
            return this.sio.readUint32(address - exports.SIO_START_ADDRESS);
        }
        const peripheral = this.findPeripheral(address);
        if (peripheral) {
            return peripheral.readUint32(address & 0x3fff);
        }
        this.logger.warn(LOG_NAME, `Read from invalid memory address: ${address.toString(16)}`);
        return 0xffffffff;
    }
    findPeripheral(address) {
        return this.peripherals[(address >>> 14) << 2];
    }
    /** We assume the address is 16-bit aligned */
    readUint16(address) {
        if (address >= exports.FLASH_START_ADDRESS && address < exports.FLASH_START_ADDRESS + this.flash.length) {
            return this.flashView.getUint16(address - exports.FLASH_START_ADDRESS, true);
        }
        else if (address >= exports.RAM_START_ADDRESS && address < exports.RAM_START_ADDRESS + this.sram.length) {
            return this.sramView.getUint16(address - exports.RAM_START_ADDRESS, true);
        }
        const value = this.readUint32(address & 0xfffffffc);
        return address & 0x2 ? (value & 0xffff0000) >>> 16 : value & 0xffff;
    }
    readUint8(address) {
        if (address >= exports.FLASH_START_ADDRESS && address < exports.FLASH_START_ADDRESS + this.flash.length) {
            return this.flash[address - exports.FLASH_START_ADDRESS];
        }
        else if (address >= exports.RAM_START_ADDRESS && address < exports.RAM_START_ADDRESS + this.sram.length) {
            return this.sram[address - exports.RAM_START_ADDRESS];
        }
        const value = this.readUint16(address & 0xfffffffe);
        return (address & 0x1 ? (value & 0xff00) >>> 8 : value & 0xff) >>> 0;
    }
    writeUint32(address, value) {
        address = address >>> 0;
        const { bootrom } = this;
        const peripheral = this.findPeripheral(address);
        if (peripheral) {
            const atomicType = (address & 0x3000) >> 12;
            const offset = address & 0xfff;
            peripheral.writeUint32Atomic(offset, value, atomicType);
        }
        else if (address < bootrom.length * 4) {
            bootrom[address / 4] = value;
        }
        else if (address >= exports.FLASH_START_ADDRESS &&
            address < exports.FLASH_START_ADDRESS + this.flash.length) {
            this.flashView.setUint32(address - exports.FLASH_START_ADDRESS, value, true);
        }
        else if (address >= exports.RAM_START_ADDRESS && address < exports.RAM_START_ADDRESS + this.sram.length) {
            this.sramView.setUint32(address - exports.RAM_START_ADDRESS, value, true);
        }
        else if (address >= exports.DPRAM_START_ADDRESS &&
            address < exports.DPRAM_START_ADDRESS + this.usbDPRAM.length) {
            const offset = address - exports.DPRAM_START_ADDRESS;
            this.usbDPRAMView.setUint32(offset, value, true);
            this.usbCtrl.DPRAMUpdated(offset, value);
        }
        else if (address >= exports.SIO_START_ADDRESS && address < exports.SIO_START_ADDRESS + 0x10000000) {
            this.sio.writeUint32(address - exports.SIO_START_ADDRESS, value);
        }
        else if (address >>> 12 === 0xe000e) {
            this.ppb.writeUint32(address & 0xfff, value);
        }
        else {
            this.logger.warn(LOG_NAME, `Write to undefined address: ${address.toString(16)}`);
        }
    }
    writeUint8(address, value) {
        if (address >= exports.RAM_START_ADDRESS && address < exports.RAM_START_ADDRESS + this.sram.length) {
            this.sram[address - exports.RAM_START_ADDRESS] = value;
            return;
        }
        const alignedAddress = (address & 0xfffffffc) >>> 0;
        const offset = address & 0x3;
        const peripheral = this.findPeripheral(address);
        if (peripheral) {
            const atomicType = (alignedAddress & 0x3000) >> 12;
            const offset = alignedAddress & 0xfff;
            peripheral.writeUint32Atomic(offset, (value & 0xff) | ((value & 0xff) << 8) | ((value & 0xff) << 16) | ((value & 0xff) << 24), atomicType);
            return;
        }
        const originalValue = this.readUint32(alignedAddress);
        const newValue = new Uint32Array([originalValue]);
        new DataView(newValue.buffer).setUint8(offset, value);
        this.writeUint32(alignedAddress, newValue[0]);
    }
    writeUint16(address, value) {
        // we assume that addess is 16-bit aligned.
        // Ideally we should generate a fault if not!
        if (address >= exports.RAM_START_ADDRESS && address < exports.RAM_START_ADDRESS + this.sram.length) {
            this.sramView.setUint16(address - exports.RAM_START_ADDRESS, value, true);
            return;
        }
        const alignedAddress = (address & 0xfffffffc) >>> 0;
        const offset = address & 0x3;
        const peripheral = this.findPeripheral(address);
        if (peripheral) {
            const atomicType = (alignedAddress & 0x3000) >> 12;
            const offset = alignedAddress & 0xfff;
            peripheral.writeUint32Atomic(offset, (value & 0xffff) | ((value & 0xffff) << 16), atomicType);
            return;
        }
        const originalValue = this.readUint32(alignedAddress);
        const newValue = new Uint32Array([originalValue]);
        new DataView(newValue.buffer).setUint16(offset, value, true);
        this.writeUint32(alignedAddress, newValue[0]);
    }
    get gpioValues() {
        const { gpio } = this;
        let result = 0;
        for (let gpioIndex = 0; gpioIndex < gpio.length; gpioIndex++) {
            if (gpio[gpioIndex].inputValue) {
                result |= 1 << gpioIndex;
            }
        }
        return result;
    }
    setInterrupt(irq, value) {
        this.core.setInterrupt(irq, value);
    }
    updateIOInterrupt() {
        let interruptValue = false;
        for (const pin of this.gpio) {
            if (pin.irqValue) {
                interruptValue = true;
            }
        }
        this.setInterrupt(irq_1.IRQ.IO_BANK0, interruptValue);
    }
    step() {
        this.core.executeInstruction();
    }
    execute() {
        this.clock.resume();
        this.executeTimer = null;
        this.stopped = false;
        for (let i = 0; i < 100000 && !this.stopped && !this.core.waiting; i++) {
            this.core.executeInstruction();
        }
        if (!this.stopped) {
            this.executeTimer = setTimeout(() => this.execute(), 0);
        }
    }
    stop() {
        this.stopped = true;
        if (this.executeTimer != null) {
            clearTimeout(this.executeTimer);
            this.executeTimer = null;
        }
        this.clock.pause();
    }
    get executing() {
        return !this.stopped;
    }
}
exports.RP2040 = RP2040;


/***/ }),

/***/ 7918:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RPSIO = void 0;
const interpolator_1 = __nccwpck_require__(5033);
const CPUID = 0x000;
// GPIO
const GPIO_IN = 0x004; // Input value for GPIO pins
const GPIO_HI_IN = 0x008; // Input value for QSPI pins
const GPIO_OUT = 0x010; // GPIO output value
const GPIO_OUT_SET = 0x014; // GPIO output value set
const GPIO_OUT_CLR = 0x018; // GPIO output value clear
const GPIO_OUT_XOR = 0x01c; // GPIO output value XOR
const GPIO_OE = 0x020; // GPIO output enable
const GPIO_OE_SET = 0x024; // GPIO output enable set
const GPIO_OE_CLR = 0x028; // GPIO output enable clear
const GPIO_OE_XOR = 0x02c; // GPIO output enable XOR
const GPIO_HI_OUT = 0x030; // QSPI output value
const GPIO_HI_OUT_SET = 0x034; // QSPI output value set
const GPIO_HI_OUT_CLR = 0x038; // QSPI output value clear
const GPIO_HI_OUT_XOR = 0x03c; // QSPI output value XOR
const GPIO_HI_OE = 0x040; // QSPI output enable
const GPIO_HI_OE_SET = 0x044; // QSPI output enable set
const GPIO_HI_OE_CLR = 0x048; // QSPI output enable clear
const GPIO_HI_OE_XOR = 0x04c; // QSPI output enable XOR
const GPIO_MASK = 0x3fffffff;
//HARDWARE DIVIDER
const DIV_UDIVIDEND = 0x060; //  Divider unsigned dividend
const DIV_UDIVISOR = 0x064; //  Divider unsigned divisor
const DIV_SDIVIDEND = 0x068; //  Divider signed dividend
const DIV_SDIVISOR = 0x06c; //  Divider signed divisor
const DIV_QUOTIENT = 0x070; //  Divider result quotient
const DIV_REMAINDER = 0x074; //Divider result remainder
const DIV_CSR = 0x078;
//INTERPOLATOR
const INTERP0_ACCUM0 = 0x080; // Read/write access to accumulator 0
const INTERP0_ACCUM1 = 0x084; // Read/write access to accumulator 1
const INTERP0_BASE0 = 0x088; // Read/write access to BASE0 register
const INTERP0_BASE1 = 0x08c; // Read/write access to BASE1 register
const INTERP0_BASE2 = 0x090; // Read/write access to BASE2 register
const INTERP0_POP_LANE0 = 0x094; // Read LANE0 result, and simultaneously write lane results to both accumulators (POP)
const INTERP0_POP_LANE1 = 0x098; // Read LANE1 result, and simultaneously write lane results to both accumulators (POP)
const INTERP0_POP_FULL = 0x09c; // Read FULL result, and simultaneously write lane results to both accumulators (POP)
const INTERP0_PEEK_LANE0 = 0x0a0; // Read LANE0 result, without altering any internal state (PEEK)
const INTERP0_PEEK_LANE1 = 0x0a4; // Read LANE1 result, without altering any internal state (PEEK)
const INTERP0_PEEK_FULL = 0x0a8; // Read FULL result, without altering any internal state (PEEK)
const INTERP0_CTRL_LANE0 = 0x0ac; // Control register for lane 0
const INTERP0_CTRL_LANE1 = 0x0b0; // Control register for lane 1
const INTERP0_ACCUM0_ADD = 0x0b4; // Values written here are atomically added to ACCUM0
const INTERP0_ACCUM1_ADD = 0x0b8; // Values written here are atomically added to ACCUM1
const INTERP0_BASE_1AND0 = 0x0bc; // On write, the lower 16 bits go to BASE0, upper bits to BASE1 simultaneously
const INTERP1_ACCUM0 = 0x0c0; // Read/write access to accumulator 0
const INTERP1_ACCUM1 = 0x0c4; // Read/write access to accumulator 1
const INTERP1_BASE0 = 0x0c8; // Read/write access to BASE0 register
const INTERP1_BASE1 = 0x0cc; // Read/write access to BASE1 register
const INTERP1_BASE2 = 0x0d0; // Read/write access to BASE2 register
const INTERP1_POP_LANE0 = 0x0d4; // Read LANE0 result, and simultaneously write lane results to both accumulators (POP)
const INTERP1_POP_LANE1 = 0x0d8; // Read LANE1 result, and simultaneously write lane results to both accumulators (POP)
const INTERP1_POP_FULL = 0x0dc; // Read FULL result, and simultaneously write lane results to both accumulators (POP)
const INTERP1_PEEK_LANE0 = 0x0e0; // Read LANE0 result, without altering any internal state (PEEK)
const INTERP1_PEEK_LANE1 = 0x0e4; // Read LANE1 result, without altering any internal state (PEEK)
const INTERP1_PEEK_FULL = 0x0e8; // Read FULL result, without altering any internal state (PEEK)
const INTERP1_CTRL_LANE0 = 0x0ec; // Control register for lane 0
const INTERP1_CTRL_LANE1 = 0x0f0; // Control register for lane 1
const INTERP1_ACCUM0_ADD = 0x0f4; // Values written here are atomically added to ACCUM0
const INTERP1_ACCUM1_ADD = 0x0f8; // Values written here are atomically added to ACCUM1
const INTERP1_BASE_1AND0 = 0x0fc; // On write, the lower 16 bits go to BASE0, upper bits to BASE1 simultaneously
//SPINLOCK
const SPINLOCK_ST = 0x5c;
const SPINLOCK0 = 0x100;
const SPINLOCK31 = 0x17c;
class RPSIO {
    constructor(rp2040) {
        this.rp2040 = rp2040;
        this.gpioValue = 0;
        this.gpioOutputEnable = 0;
        this.qspiGpioValue = 0;
        this.qspiGpioOutputEnable = 0;
        this.divDividend = 0;
        this.divDivisor = 1;
        this.divQuotient = 0;
        this.divRemainder = 0;
        this.divCSR = 0;
        this.spinLock = 0;
        this.interp0 = new interpolator_1.Interpolator(0);
        this.interp1 = new interpolator_1.Interpolator(1);
    }
    updateHardwareDivider(signed) {
        if (this.divDivisor == 0) {
            this.divQuotient = this.divDividend > 0 ? -1 : 1;
            this.divRemainder = this.divDividend;
        }
        else {
            if (signed) {
                this.divQuotient = (this.divDividend | 0) / (this.divDivisor | 0);
                this.divRemainder = (this.divDividend | 0) % (this.divDivisor | 0);
            }
            else {
                this.divQuotient = (this.divDividend >>> 0) / (this.divDivisor >>> 0);
                this.divRemainder = (this.divDividend >>> 0) % (this.divDivisor >>> 0);
            }
        }
        this.divCSR = 0b11;
        this.rp2040.core.cycles += 8;
    }
    readUint32(offset) {
        if (offset >= SPINLOCK0 && offset <= SPINLOCK31) {
            const bitIndexMask = 1 << ((offset - SPINLOCK0) / 4);
            if (this.spinLock & bitIndexMask) {
                return 0;
            }
            else {
                this.spinLock |= bitIndexMask;
                return bitIndexMask;
            }
        }
        switch (offset) {
            case GPIO_IN:
                return this.rp2040.gpioValues;
            case GPIO_HI_IN: {
                const { qspi } = this.rp2040;
                let result = 0;
                for (let qspiIndex = 0; qspiIndex < qspi.length; qspiIndex++) {
                    if (qspi[qspiIndex].inputValue) {
                        result |= 1 << qspiIndex;
                    }
                }
                return result;
            }
            case GPIO_OUT:
                return this.gpioValue;
            case GPIO_OE:
                return this.gpioOutputEnable;
            case GPIO_HI_OUT:
                return this.qspiGpioValue;
            case GPIO_HI_OE:
                return this.qspiGpioOutputEnable;
            case GPIO_OUT_SET:
            case GPIO_OUT_CLR:
            case GPIO_OUT_XOR:
            case GPIO_OE_SET:
            case GPIO_OE_CLR:
            case GPIO_OE_XOR:
            case GPIO_HI_OUT_SET:
            case GPIO_HI_OUT_CLR:
            case GPIO_HI_OUT_XOR:
            case GPIO_HI_OE_SET:
            case GPIO_HI_OE_CLR:
            case GPIO_HI_OE_XOR:
                return 0; // TODO verify with silicone
            case CPUID:
                // Returns the current CPU core id (always 0 for now)
                return 0;
            case SPINLOCK_ST:
                return this.spinLock;
            case DIV_UDIVIDEND:
                return this.divDividend;
            case DIV_SDIVIDEND:
                return this.divDividend;
            case DIV_UDIVISOR:
                return this.divDivisor;
            case DIV_SDIVISOR:
                return this.divDivisor;
            case DIV_QUOTIENT:
                this.divCSR &= ~0b10;
                return this.divQuotient;
            case DIV_REMAINDER:
                return this.divRemainder;
            case DIV_CSR:
                return this.divCSR;
            case INTERP0_ACCUM0:
                return this.interp0.accum0;
            case INTERP0_ACCUM1:
                return this.interp0.accum1;
            case INTERP0_BASE0:
                return this.interp0.base0;
            case INTERP0_BASE1:
                return this.interp0.base1;
            case INTERP0_BASE2:
                return this.interp0.base2;
            case INTERP0_CTRL_LANE0:
                return this.interp0.ctrl0;
            case INTERP0_CTRL_LANE1:
                return this.interp0.ctrl1;
            case INTERP0_PEEK_LANE0:
                return this.interp0.result0;
            case INTERP0_PEEK_LANE1:
                return this.interp0.result1;
            case INTERP0_PEEK_FULL:
                return this.interp0.result2;
            case INTERP0_POP_LANE0: {
                const value = this.interp0.result0;
                this.interp0.writeback();
                return value;
            }
            case INTERP0_POP_LANE1: {
                const value = this.interp0.result1;
                this.interp0.writeback();
                return value;
            }
            case INTERP0_POP_FULL: {
                const value = this.interp0.result2;
                this.interp0.writeback();
                return value;
            }
            case INTERP0_ACCUM0_ADD:
                return this.interp0.smresult0;
            case INTERP0_ACCUM1_ADD:
                return this.interp0.smresult1;
            case INTERP1_ACCUM0:
                return this.interp1.accum0;
            case INTERP1_ACCUM1:
                return this.interp1.accum1;
            case INTERP1_BASE0:
                return this.interp1.base0;
            case INTERP1_BASE1:
                return this.interp1.base1;
            case INTERP1_BASE2:
                return this.interp1.base2;
            case INTERP1_CTRL_LANE0:
                return this.interp1.ctrl0;
            case INTERP1_CTRL_LANE1:
                return this.interp1.ctrl1;
            case INTERP1_PEEK_LANE0:
                return this.interp1.result0;
            case INTERP1_PEEK_LANE1:
                return this.interp1.result1;
            case INTERP1_PEEK_FULL:
                return this.interp1.result2;
            case INTERP1_POP_LANE0: {
                const value = this.interp1.result0;
                this.interp1.writeback();
                return value;
            }
            case INTERP1_POP_LANE1: {
                const value = this.interp1.result1;
                this.interp1.writeback();
                return value;
            }
            case INTERP1_POP_FULL: {
                const value = this.interp1.result2;
                this.interp1.writeback();
                return value;
            }
            case INTERP1_ACCUM0_ADD:
                return this.interp1.smresult0;
            case INTERP1_ACCUM1_ADD:
                return this.interp1.smresult1;
        }
        console.warn(`Read from invalid SIO address: ${offset.toString(16)}`);
        return 0xffffffff;
    }
    writeUint32(offset, value) {
        if (offset >= SPINLOCK0 && offset <= SPINLOCK31) {
            const bitIndexMask = ~(1 << ((offset - SPINLOCK0) / 4));
            this.spinLock &= bitIndexMask;
            return;
        }
        const prevGpioValue = this.gpioValue;
        const prevGpioOutputEnable = this.gpioOutputEnable;
        switch (offset) {
            case GPIO_OUT:
                this.gpioValue = value & GPIO_MASK;
                break;
            case GPIO_OUT_SET:
                this.gpioValue |= value & GPIO_MASK;
                break;
            case GPIO_OUT_CLR:
                this.gpioValue &= ~value;
                break;
            case GPIO_OUT_XOR:
                this.gpioValue ^= value & GPIO_MASK;
                break;
            case GPIO_OE:
                this.gpioOutputEnable = value & GPIO_MASK;
                break;
            case GPIO_OE_SET:
                this.gpioOutputEnable |= value & GPIO_MASK;
                break;
            case GPIO_OE_CLR:
                this.gpioOutputEnable &= ~value;
                break;
            case GPIO_OE_XOR:
                this.gpioOutputEnable ^= value & GPIO_MASK;
                break;
            case GPIO_HI_OUT:
                this.qspiGpioValue = value & GPIO_MASK;
                break;
            case GPIO_HI_OUT_SET:
                this.qspiGpioValue |= value & GPIO_MASK;
                break;
            case GPIO_HI_OUT_CLR:
                this.qspiGpioValue &= ~value;
                break;
            case GPIO_HI_OUT_XOR:
                this.qspiGpioValue ^= value & GPIO_MASK;
                break;
            case GPIO_HI_OE:
                this.qspiGpioOutputEnable = value & GPIO_MASK;
                break;
            case GPIO_HI_OE_SET:
                this.qspiGpioOutputEnable |= value & GPIO_MASK;
                break;
            case GPIO_HI_OE_CLR:
                this.qspiGpioOutputEnable &= ~value;
                break;
            case GPIO_HI_OE_XOR:
                this.qspiGpioOutputEnable ^= value & GPIO_MASK;
                break;
            case DIV_UDIVIDEND:
                this.divDividend = value;
                this.updateHardwareDivider(false);
                break;
            case DIV_SDIVIDEND:
                this.divDividend = value;
                this.updateHardwareDivider(true);
                break;
            case DIV_UDIVISOR:
                this.divDivisor = value;
                this.updateHardwareDivider(false);
                break;
            case DIV_SDIVISOR:
                this.divDivisor = value;
                this.updateHardwareDivider(true);
                break;
            case DIV_QUOTIENT:
                this.divQuotient = value;
                this.divCSR = 0b11;
                break;
            case DIV_REMAINDER:
                this.divRemainder = value;
                this.divCSR = 0b11;
                break;
            case INTERP0_ACCUM0:
                this.interp0.accum0 = value;
                this.interp0.update();
                break;
            case INTERP0_ACCUM1:
                this.interp0.accum1 = value;
                this.interp0.update();
                break;
            case INTERP0_BASE0:
                this.interp0.base0 = value;
                this.interp0.update();
                break;
            case INTERP0_BASE1:
                this.interp0.base1 = value;
                this.interp0.update();
                break;
            case INTERP0_BASE2:
                this.interp0.base2 = value;
                this.interp0.update();
                break;
            case INTERP0_CTRL_LANE0:
                this.interp0.ctrl0 = value;
                this.interp0.update();
                break;
            case INTERP0_CTRL_LANE1:
                this.interp0.ctrl1 = value;
                this.interp0.update();
                break;
            case INTERP0_ACCUM0_ADD:
                this.interp0.accum0 += value;
                this.interp0.update();
                break;
            case INTERP0_ACCUM1_ADD:
                this.interp0.accum1 += value;
                this.interp0.update();
                break;
            case INTERP0_BASE_1AND0:
                this.interp0.setBase01(value);
                break;
            case INTERP1_ACCUM0:
                this.interp1.accum0 = value;
                this.interp1.update();
                break;
            case INTERP1_ACCUM1:
                this.interp1.accum1 = value;
                this.interp1.update();
                break;
            case INTERP1_BASE0:
                this.interp1.base0 = value;
                this.interp1.update();
                break;
            case INTERP1_BASE1:
                this.interp1.base1 = value;
                this.interp1.update();
                break;
            case INTERP1_BASE2:
                this.interp1.base2 = value;
                this.interp1.update();
                break;
            case INTERP1_CTRL_LANE0:
                this.interp1.ctrl0 = value;
                this.interp1.update();
                break;
            case INTERP1_CTRL_LANE1:
                this.interp1.ctrl1 = value;
                this.interp1.update();
                break;
            case INTERP1_ACCUM0_ADD:
                this.interp1.accum0 += value;
                this.interp1.update();
                break;
            case INTERP1_ACCUM1_ADD:
                this.interp1.accum1 += value;
                this.interp1.update();
                break;
            case INTERP1_BASE_1AND0:
                this.interp1.setBase01(value);
                break;
            default:
                console.warn(`Write to invalid SIO address: ${offset.toString(16)}, value=${value.toString(16)}`);
        }
        const pinsToUpdate = (this.gpioValue ^ prevGpioValue) | (this.gpioOutputEnable ^ prevGpioOutputEnable);
        if (pinsToUpdate) {
            const { gpio } = this.rp2040;
            for (let gpioIndex = 0; gpioIndex < gpio.length; gpioIndex++) {
                if (pinsToUpdate & (1 << gpioIndex)) {
                    gpio[gpioIndex].checkForUpdates();
                }
            }
        }
    }
}
exports.RPSIO = RPSIO;


/***/ }),

/***/ 9631:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.USBCDC = exports.extractEndpointNumbers = void 0;
const fifo_1 = __nccwpck_require__(4677);
const interfaces_1 = __nccwpck_require__(285);
const setup_1 = __nccwpck_require__(8603);
// CDC stuff
const CDC_REQUEST_SET_CONTROL_LINE_STATE = 0x22;
const CDC_DTR = 1 << 0;
const CDC_RTS = 1 << 1;
const CDC_DATA_CLASS = 10;
const ENDPOINT_BULK = 2;
const TX_FIFO_SIZE = 512;
const ENDPOINT_ZERO = 0;
const CONFIGURATION_DESCRIPTOR_SIZE = 9;
function extractEndpointNumbers(descriptors) {
    let index = 0;
    let foundInterface = false;
    const result = {
        in: -1,
        out: -1,
    };
    while (index < descriptors.length) {
        const len = descriptors[index];
        if (len < 2 || descriptors.length < index + len) {
            break;
        }
        const type = descriptors[index + 1];
        if (type === interfaces_1.DescriptorType.Interface && len === 9) {
            const numEndpoints = descriptors[index + 4];
            const interfaceClass = descriptors[index + 5];
            foundInterface = numEndpoints === 2 && interfaceClass === CDC_DATA_CLASS;
        }
        if (foundInterface && type === interfaces_1.DescriptorType.Endpoint && len === 7) {
            const address = descriptors[index + 2];
            const attributes = descriptors[index + 3];
            if ((attributes & 0x3) === ENDPOINT_BULK) {
                if (address & 0x80) {
                    result.in = address & 0xf;
                }
                else {
                    result.out = address & 0xf;
                }
            }
        }
        index += descriptors[index];
    }
    return result;
}
exports.extractEndpointNumbers = extractEndpointNumbers;
class USBCDC {
    constructor(usb) {
        this.usb = usb;
        this.txFIFO = new fifo_1.FIFO(TX_FIFO_SIZE);
        this.initialized = false;
        this.descriptorsSize = null;
        this.descriptors = [];
        this.outEndpoint = -1;
        this.inEndpoint = -1;
        this.usb.onUSBEnabled = () => {
            this.usb.resetDevice();
        };
        this.usb.onResetReceived = () => {
            this.usb.sendSetupPacket(setup_1.setDeviceAddressPacket(1));
        };
        this.usb.onEndpointWrite = (endpoint, buffer) => {
            var _a, _b;
            if (endpoint === ENDPOINT_ZERO && buffer.length === 0) {
                if (this.descriptorsSize == null) {
                    this.usb.sendSetupPacket(setup_1.getDescriptorPacket(interfaces_1.DescriptorType.Configration, CONFIGURATION_DESCRIPTOR_SIZE));
                }
                // Acknowledgement
                else if (!this.initialized) {
                    this.cdcSetControlLineState();
                    (_a = this.onDeviceConnected) === null || _a === void 0 ? void 0 : _a.call(this);
                }
            }
            if (endpoint === ENDPOINT_ZERO && buffer.length > 1) {
                if (buffer.length === CONFIGURATION_DESCRIPTOR_SIZE &&
                    buffer[1] === interfaces_1.DescriptorType.Configration &&
                    this.descriptorsSize == null) {
                    this.descriptorsSize = (buffer[3] << 8) | buffer[2];
                    this.usb.sendSetupPacket(setup_1.getDescriptorPacket(interfaces_1.DescriptorType.Configration, this.descriptorsSize));
                }
                else if (this.descriptorsSize != null && this.descriptors.length < this.descriptorsSize) {
                    this.descriptors.push(...buffer);
                }
                if (this.descriptorsSize === this.descriptors.length) {
                    const endpoints = extractEndpointNumbers(this.descriptors);
                    this.inEndpoint = endpoints.in;
                    this.outEndpoint = endpoints.out;
                    // Now configure the device
                    this.usb.sendSetupPacket(setup_1.setDeviceConfigurationPacket(1));
                }
            }
            if (endpoint === this.inEndpoint) {
                (_b = this.onSerialData) === null || _b === void 0 ? void 0 : _b.call(this, buffer);
            }
        };
        this.usb.onEndpointRead = (endpoint, size) => {
            if (endpoint === this.outEndpoint) {
                const buffer = new Uint8Array(Math.min(size, this.txFIFO.itemCount));
                for (let i = 0; i < buffer.length; i++) {
                    buffer[i] = this.txFIFO.pull();
                }
                this.usb.endpointReadDone(this.outEndpoint, buffer);
            }
        };
    }
    cdcSetControlLineState(value = CDC_DTR | CDC_RTS, interfaceNumber = 0) {
        this.usb.sendSetupPacket(setup_1.createSetupPacket({
            dataDirection: interfaces_1.DataDirection.HostToDevice,
            type: interfaces_1.SetupType.Class,
            recipient: interfaces_1.SetupRecipient.Device,
            bRequest: CDC_REQUEST_SET_CONTROL_LINE_STATE,
            wValue: value,
            wIndex: interfaceNumber,
            wLength: 0,
        }));
        this.initialized = true;
    }
    sendSerialByte(data) {
        this.txFIFO.push(data);
    }
}
exports.USBCDC = USBCDC;


/***/ }),

/***/ 285:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DescriptorType = exports.SetupRequest = exports.SetupRecipient = exports.SetupType = exports.DataDirection = void 0;
var DataDirection;
(function (DataDirection) {
    DataDirection[DataDirection["HostToDevice"] = 0] = "HostToDevice";
    DataDirection[DataDirection["DeviceToHost"] = 1] = "DeviceToHost";
})(DataDirection = exports.DataDirection || (exports.DataDirection = {}));
var SetupType;
(function (SetupType) {
    SetupType[SetupType["Standard"] = 0] = "Standard";
    SetupType[SetupType["Class"] = 1] = "Class";
    SetupType[SetupType["Vendor"] = 2] = "Vendor";
    SetupType[SetupType["Reserved"] = 3] = "Reserved";
})(SetupType = exports.SetupType || (exports.SetupType = {}));
var SetupRecipient;
(function (SetupRecipient) {
    SetupRecipient[SetupRecipient["Device"] = 0] = "Device";
    SetupRecipient[SetupRecipient["Interface"] = 1] = "Interface";
    SetupRecipient[SetupRecipient["Endpoint"] = 2] = "Endpoint";
    SetupRecipient[SetupRecipient["Other"] = 3] = "Other";
})(SetupRecipient = exports.SetupRecipient || (exports.SetupRecipient = {}));
var SetupRequest;
(function (SetupRequest) {
    SetupRequest[SetupRequest["GetStatus"] = 0] = "GetStatus";
    SetupRequest[SetupRequest["ClearFeature"] = 1] = "ClearFeature";
    SetupRequest[SetupRequest["Reserved1"] = 2] = "Reserved1";
    SetupRequest[SetupRequest["SetFeature"] = 3] = "SetFeature";
    SetupRequest[SetupRequest["Reserved2"] = 4] = "Reserved2";
    SetupRequest[SetupRequest["SetAddress"] = 5] = "SetAddress";
    SetupRequest[SetupRequest["GetDescriptor"] = 6] = "GetDescriptor";
    SetupRequest[SetupRequest["SetDescriptor"] = 7] = "SetDescriptor";
    SetupRequest[SetupRequest["GetConfiguration"] = 8] = "GetConfiguration";
    SetupRequest[SetupRequest["SetDeviceConfiguration"] = 9] = "SetDeviceConfiguration";
    SetupRequest[SetupRequest["GetInterface"] = 10] = "GetInterface";
    SetupRequest[SetupRequest["SetInterface"] = 11] = "SetInterface";
    SetupRequest[SetupRequest["SynchFrame"] = 12] = "SynchFrame";
})(SetupRequest = exports.SetupRequest || (exports.SetupRequest = {}));
var DescriptorType;
(function (DescriptorType) {
    DescriptorType[DescriptorType["Device"] = 1] = "Device";
    DescriptorType[DescriptorType["Configration"] = 2] = "Configration";
    DescriptorType[DescriptorType["String"] = 3] = "String";
    DescriptorType[DescriptorType["Interface"] = 4] = "Interface";
    DescriptorType[DescriptorType["Endpoint"] = 5] = "Endpoint";
})(DescriptorType = exports.DescriptorType || (exports.DescriptorType = {}));


/***/ }),

/***/ 8603:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setDeviceConfigurationPacket = exports.getDescriptorPacket = exports.setDeviceAddressPacket = exports.createSetupPacket = void 0;
const interfaces_1 = __nccwpck_require__(285);
function createSetupPacket(params) {
    const setupPacket = new Uint8Array(8);
    setupPacket[0] = (params.dataDirection << 7) | (params.type << 5) | params.recipient;
    setupPacket[1] = params.bRequest;
    setupPacket[2] = params.wValue & 0xff;
    setupPacket[3] = (params.wValue >> 8) & 0xff;
    setupPacket[4] = params.wIndex & 0xff;
    setupPacket[5] = (params.wIndex >> 8) & 0xff;
    setupPacket[6] = params.wLength & 0xff;
    setupPacket[7] = (params.wLength >> 8) & 0xff;
    return setupPacket;
}
exports.createSetupPacket = createSetupPacket;
function setDeviceAddressPacket(address) {
    return createSetupPacket({
        dataDirection: interfaces_1.DataDirection.HostToDevice,
        type: interfaces_1.SetupType.Standard,
        recipient: interfaces_1.SetupRecipient.Device,
        bRequest: interfaces_1.SetupRequest.SetAddress,
        wValue: address,
        wIndex: 0,
        wLength: 0,
    });
}
exports.setDeviceAddressPacket = setDeviceAddressPacket;
function getDescriptorPacket(type, length, index = 0) {
    return createSetupPacket({
        dataDirection: interfaces_1.DataDirection.DeviceToHost,
        type: interfaces_1.SetupType.Standard,
        recipient: interfaces_1.SetupRecipient.Device,
        bRequest: interfaces_1.SetupRequest.GetDescriptor,
        wValue: type << 8,
        wIndex: index,
        wLength: length,
    });
}
exports.getDescriptorPacket = getDescriptorPacket;
function setDeviceConfigurationPacket(configurationNumber) {
    return createSetupPacket({
        dataDirection: interfaces_1.DataDirection.HostToDevice,
        type: interfaces_1.SetupType.Standard,
        recipient: interfaces_1.SetupRecipient.Device,
        bRequest: interfaces_1.SetupRequest.SetDeviceConfiguration,
        wValue: configurationNumber,
        wIndex: 0,
        wLength: 0,
    });
}
exports.setDeviceConfigurationPacket = setDeviceConfigurationPacket;


/***/ }),

/***/ 92:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.u32 = exports.s32 = exports.bit = void 0;
function bit(n) {
    return 1 << n;
}
exports.bit = bit;
function s32(n) {
    return n | 0;
}
exports.s32 = s32;
function u32(n) {
    return n >>> 0;
}
exports.u32 = u32;


/***/ }),

/***/ 4677:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FIFO = void 0;
class FIFO {
    constructor(size) {
        this.start = 0;
        this.used = 0;
        this.buffer = new Uint32Array(size);
    }
    get size() {
        return this.buffer.length;
    }
    get itemCount() {
        return this.used;
    }
    push(value) {
        const { length } = this.buffer;
        const { start, used } = this;
        if (this.used < length) {
            this.buffer[(start + used) % length] = value;
            this.used++;
        }
    }
    pull() {
        const { start, used } = this;
        const { length } = this.buffer;
        if (used) {
            this.start = (start + 1) % length;
            this.used--;
            return this.buffer[start];
        }
        return 0;
    }
    peek() {
        return this.used ? this.buffer[this.start] : 0;
    }
    reset() {
        this.used = 0;
    }
    get empty() {
        return this.used == 0;
    }
    get full() {
        return this.used === this.buffer.length;
    }
    get items() {
        const { start, used, buffer } = this;
        const { length } = buffer;
        const result = [];
        for (let i = 0; i < used; i++) {
            result[i] = buffer[(start + i) % length];
        }
        return result;
    }
}
exports.FIFO = FIFO;


/***/ }),

/***/ 6057:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConsoleLogger = exports.LogLevel = void 0;
const time_1 = __nccwpck_require__(3802);
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["Debug"] = 0] = "Debug";
    LogLevel[LogLevel["Info"] = 1] = "Info";
    LogLevel[LogLevel["Warn"] = 2] = "Warn";
    LogLevel[LogLevel["Error"] = 3] = "Error";
})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
class ConsoleLogger {
    constructor(currentLogLevel, throwOnError = true) {
        this.currentLogLevel = currentLogLevel;
        this.throwOnError = throwOnError;
    }
    aboveLogLevel(logLevel) {
        return logLevel >= this.currentLogLevel ? true : false;
    }
    formatMessage(componentName, message) {
        const currentTime = time_1.formatTime(new Date());
        return `${currentTime} [${componentName}] ${message}`;
    }
    debug(componetName, message) {
        if (this.aboveLogLevel(LogLevel.Debug)) {
            console.debug(this.formatMessage(componetName, message));
        }
    }
    warn(componetName, message) {
        if (this.aboveLogLevel(LogLevel.Warn)) {
            console.warn(this.formatMessage(componetName, message));
        }
    }
    error(componentName, message) {
        if (this.aboveLogLevel(LogLevel.Error)) {
            console.error(this.formatMessage(componentName, message));
            if (this.throwOnError) {
                throw new Error(`[${componentName}] ${message}`);
            }
        }
    }
    info(componentName, message) {
        if (this.aboveLogLevel(LogLevel.Info)) {
            console.info(this.formatMessage(componentName, message));
        }
    }
}
exports.ConsoleLogger = ConsoleLogger;


/***/ }),

/***/ 3802:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.formatTime = exports.getCurrentMicroseconds = void 0;
function getCurrentMicroseconds() {
    if (typeof performance != 'undefined') {
        return Math.floor(performance.now() * 1000);
    }
    else {
        return Math.floor(eval('require')('perf_hooks').performance.now() * 1000);
    }
}
exports.getCurrentMicroseconds = getCurrentMicroseconds;
function leftPad(value, minLength, padChar = ' ') {
    if (value.length < minLength) {
        value = padChar + value;
    }
    return value;
}
function rightPad(value, minLength, padChar = ' ') {
    if (value.length < minLength) {
        value += padChar;
    }
    return value;
}
function formatTime(date) {
    const hours = leftPad(date.getHours().toString(), 2, '0');
    const minutes = leftPad(date.getMinutes().toString(), 2, '0');
    const seconds = leftPad(date.getSeconds().toString(), 2, '0');
    const milliseconds = rightPad(date.getMilliseconds().toString(), 3);
    return `${hours}:${minutes}:${seconds}.${milliseconds}`;
}
exports.formatTime = formatTime;


/***/ }),

/***/ 6682:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Timer32PeriodicAlarm = exports.Timer32 = exports.TimerMode = void 0;
var TimerMode;
(function (TimerMode) {
    TimerMode[TimerMode["Increment"] = 0] = "Increment";
    TimerMode[TimerMode["Decrement"] = 1] = "Decrement";
    TimerMode[TimerMode["ZigZag"] = 2] = "ZigZag";
})(TimerMode = exports.TimerMode || (exports.TimerMode = {}));
class Timer32 {
    constructor(clock, baseFreq) {
        this.clock = clock;
        this.baseFreq = baseFreq;
        this.baseValue = 0;
        this.baseMicros = 0;
        this.topValue = 0xffffffff;
        this.prescalerValue = 1;
        this.timerMode = TimerMode.Increment;
        this.enabled = true;
        this.listeners = [];
    }
    reset() {
        this.baseMicros = this.clock.micros;
        this.baseValue = 0;
        this.updated();
    }
    set(value, zigZagDown = false) {
        this.baseValue = zigZagDown ? this.topValue * 2 - value : value;
        this.baseMicros = this.clock.micros;
        this.updated();
    }
    /**
     * Advances the counter by the given amount. Note that this will
     * decrease the counter if the timer is running in Decrement mode.
     *
     * @param delta The value to add to the counter. Can be negative.
     */
    advance(delta) {
        this.baseValue += delta;
    }
    get rawCounter() {
        const { baseFreq, prescalerValue, baseMicros, baseValue, enabled, timerMode } = this;
        if (!baseFreq || !prescalerValue || !enabled) {
            return this.baseValue;
        }
        const zigzag = timerMode == TimerMode.ZigZag;
        const ticks = ((this.clock.micros - baseMicros) / 1e6) * (baseFreq / prescalerValue);
        const topModulo = zigzag ? this.topValue * 2 : this.topValue + 1;
        const delta = timerMode == TimerMode.Decrement ? topModulo - (ticks % topModulo) : ticks;
        let currentValue = Math.round(baseValue + delta);
        if (this.topValue != 0xffffffff) {
            currentValue %= topModulo;
        }
        return currentValue;
    }
    get counter() {
        let currentValue = this.rawCounter;
        if (this.timerMode == TimerMode.ZigZag && currentValue > this.topValue) {
            currentValue = this.topValue * 2 - currentValue;
        }
        return currentValue >>> 0;
    }
    get top() {
        return this.topValue;
    }
    set top(value) {
        const { counter } = this;
        this.topValue = value;
        this.set(counter <= this.topValue ? counter : 0);
    }
    get frequency() {
        return this.baseFreq;
    }
    set frequency(value) {
        this.baseValue = this.counter;
        this.baseMicros = this.clock.micros;
        this.baseFreq = value;
        this.updated();
    }
    get prescaler() {
        return this.prescalerValue;
    }
    set prescaler(value) {
        this.baseValue = this.counter;
        this.baseMicros = this.clock.micros;
        this.enabled = this.prescalerValue !== 0;
        this.prescalerValue = value;
        this.updated();
    }
    toMicros(cycles) {
        const { baseFreq, prescalerValue } = this;
        return (cycles * 1e6) / (baseFreq / prescalerValue);
    }
    get enable() {
        return this.enabled;
    }
    set enable(value) {
        if (value !== this.enabled) {
            if (value) {
                this.baseMicros = this.clock.micros;
            }
            else {
                this.baseValue = this.counter;
            }
            this.enabled = value;
            this.updated();
        }
    }
    get mode() {
        return this.timerMode;
    }
    set mode(value) {
        if (this.timerMode !== value) {
            const { counter } = this;
            this.timerMode = value;
            this.set(counter);
        }
    }
    updated() {
        for (const listener of this.listeners) {
            listener();
        }
    }
}
exports.Timer32 = Timer32;
class Timer32PeriodicAlarm {
    constructor(timer, callback) {
        this.timer = timer;
        this.callback = callback;
        this.targetValue = 0;
        this.enabled = false;
        this.handleAlarm = () => {
            this.callback();
            if (this.enabled && this.timer.enable) {
                this.schedule();
            }
        };
        this.update = () => {
            this.cancel();
            if (this.enabled && this.timer.enable) {
                this.schedule();
            }
        };
        timer.listeners.push(this.update);
    }
    get enable() {
        return this.enabled;
    }
    set enable(value) {
        if (value !== this.enabled) {
            this.enabled = value;
            if (value && this.timer.enable) {
                this.schedule();
            }
            else {
                this.cancel();
            }
        }
    }
    get target() {
        return this.targetValue;
    }
    set target(value) {
        if (value === this.targetValue) {
            return;
        }
        this.targetValue = value;
        if (this.enabled && this.timer.enable) {
            this.cancel();
            this.schedule();
        }
    }
    schedule() {
        const { timer, targetValue } = this;
        const { top, mode, rawCounter } = timer;
        let cycleDelta = targetValue - rawCounter;
        if (mode === TimerMode.ZigZag && cycleDelta < 0) {
            if (cycleDelta < -top) {
                cycleDelta += 2 * top;
            }
            else {
                cycleDelta = top * 2 - targetValue - rawCounter;
            }
        }
        if (top != 0xffffffff) {
            if (cycleDelta < 0) {
                cycleDelta += top + 1;
            }
            if (targetValue > top) {
                // Skip alarm
                return;
            }
        }
        if (mode === TimerMode.Decrement) {
            cycleDelta = top - cycleDelta;
        }
        const cyclesToAlarm = cycleDelta >>> 0;
        const microsToAlarm = timer.toMicros(cyclesToAlarm);
        this.clockTimer = this.timer.clock.createTimer(microsToAlarm, this.handleAlarm);
    }
    cancel() {
        if (this.clockTimer) {
            this.timer.clock.deleteTimer(this.clockTimer);
            this.clockTimer = undefined;
        }
    }
}
exports.Timer32PeriodicAlarm = Timer32PeriodicAlarm;


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nccwpck_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			__webpack_modules__[moduleId].call(module.exports, module, module.exports, __nccwpck_require__);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete __webpack_module_cache__[moduleId];
/******/ 		}
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat */
/******/ 	
/******/ 	if (typeof __nccwpck_require__ !== 'undefined') __nccwpck_require__.ab = __dirname + "/";
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __nccwpck_require__(3109);
/******/ 	module.exports = __webpack_exports__;
/******/ 	
/******/ })()
;
//# sourceMappingURL=index.js.map